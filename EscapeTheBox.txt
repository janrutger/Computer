### Game Design Document: "Escape the Box"

#### 1. Core Concept

"Escape the Box" is a single-player arcade game. 
The player is confined within a U-shaped arena and must collect coins to earn points. 
These points can then be spent to break through sections of the arena's walls to escape.

#### 2. Gameplay Loop

The core gameplay loop is centered on risk and reward:
1.  The player collects a moving coin to accumulate points.
2.  The player can attempt to break through a wall segment by colliding with it.
3.  If the player has enough points, the wall segment is destroyed, and the points are deducted from their score.
4.  If the player does not have enough points, they are penalized by the full cost of the wall, potentially putting their score into a negative "debt" state.
5.  The coin is reused, respawning in a new location each time it is collected.

#### 3. Key Features

*   **Dynamic Difficulty:** 
    A dynamic difficulty system will be implemented. 
    As the player collects more coins, the coin will begin to move faster, but it will also award more points upon collection, 
    increasing both the challenge and the reward.
*   **Variable Pricing:** 
    Different wall segments will have different point costs to break, 
    forcing the player to make strategic decisions about their escape route. 
    The main "roof" tile will be the most expensive exit.
*   **Random Movement:** 
    The Stacks's `RND` (random) function will be used to determine the respawn location of the coin, 
    and potentially the movement of a future "monster" tile, ensuring each playthrough feels slightly different.

#### 4. Level Design and Asset Strategy

*   **Layout:** 
    The level will be designed as an open, upside-down U-shape, using the bottom of the screen as the "floor" of the box. 
    This creates a defined play area without requiring tiles for all four sides.
*   **Player and Coin:** 
    For simplicity of design and collision, both the player and the coin will be represented by simple 1x1 tile sprites.
*   **Special Tile:** 
    The reserved tile (ID 7) for the "golden coin" or "monster" will use a larger 2x2 sprite. 
    This makes the reward easier to find when in debt, and the monster a more significant obstacle to avoid when in credit.
*   **Composite Walls:** 
    To efficiently use the limited number of dynamic tiles, the walls will be constructed from composite sprites 
    (e.g., 1xN or Nx1 shapes) rather than individual 1x1 blocks. The top wall will be a single tile with an 11x1 sprite, 
    creating an effective 9-tile wide play area.
*   **Segmented Walls:** 
    To enhance gameplay, the vertical walls will each be composed of two separate tile segments 
    (e.g., a small, cheap segment and a larger, more expensive one), providing multiple breakout options.

#### 5. Resource Management (Tile Budget)

The game will be designed within the engine's 8-tile limit. The planned allocation is as follows:
*   **Total Tiles Used:** 7
*   **Tiles Remaining:** 1 (goldencoin/monster)

This leaves one tile available for a future feature, such as a hidden "golden coin" that appears after a certain score is reached, 
or a "monster" tile that acts as a moving obstacle.

#### 6. Tile ID Bookkeeping

To ensure the game logic is clear and easy to manage, the following Tile ID allocation will be used:
*   **ID 0:** Player
*   **ID 1:** Coin
*   **ID 2:** Top Wall (most expensive)
*   **IDs 3, 4:** Left Wall segments
*   **IDs 5, 6:** Right Wall segments
*   **ID 7:** Reserved for the Monster or Golden Coin

#### 7. User Interface (UI) and Player Feedback

To provide essential feedback to the player, the current score will be displayed on-screen at all times.

*   **Display Method:** 
    As the engine operates in a sprite-based graphics mode, the score will not be rendered as text. 
    Instead, it will be constructed from a set of dedicated digit sprites (0-9).
*   **Layout:** 
    The score will be displayed in a fixed position outside of the main play area 
    (e.g., the top-left corner of the screen) to ensure it is always visible and does not interfere with gameplay.
*   **Implementation:** 
    This will require a new helper function that can take the numerical `score` variable, separate it into individual digits, 
    and draw the corresponding sprite for each digit at the correct screen location. 
    (we gonne ask the system architect where to put this helper function)




SOME IMPLEMENTATION NOTES TO REMEMBER

Based on the positions of your walls and roof, we first need to define the boundaries of the playable area.

The Roof is at Y=34.
The Left Wall is at X=26.
The Right Wall is at X=52.
The Floor is the bottom of the screen at Y=59.
This means the valid, playable area for a 1x1 tile is:

X-Range: from 27 to 51
Y-Range: from 35 to 58


Calculation random X Y values
RND 25 * 999 // 27 + AS newX
RND 24 * 999 // 35 + AS newY


RND 25 % 27 + AS newX
RND 24 % 35 + AS newY


* SCORE BOARD
    Prints at location 10,10 the current credits of the player
    This can be an positive or negative number
    i reserve 4 position for the score one-sign and 3 digits
    The routine must overwtrite all 4 because the number can be smaller

    for the programmer: <current credit> print_score
    must be fast, its all overhead for the game experiance


    DEF print_score {
        # Expects score on the stack

        # 1. Handle the Sign
        IF score < 0 {
            Draw the "minus" sprite at X=10.
            Make the score positive (e.g., score * -1).
        } ELSE {
            Draw a "blank" or "plus" sprite at X=10.
        }

        # 2. Directly Calculate Each Digit
        hundreds_digit = score / 100
        tens_digit = (score % 100) / 10
        ones_digit = score % 10

        # 3. Draw All Three Digits
        # (This assumes you have a way to get the sprite for a digit,
        #  like a lookup list) (the sprite has his ASCII value as sprie_id)
        Draw the sprite for hundreds_digit at X=11.
        Draw the sprite for tens_digit at X=12.
        Draw the sprite for ones_digit at X=13.
}



### Game Plot & Mechanics

The player's goal is to escape the box by breaking through a wall segment. 
The path to victory is paved with coins, risk, and a lurking monster.

#### The Core Loop: Earning and Spending

1.  **Earning Credits:** The player collects coins to increase their `score`. 
    Each coin is worth 1 credit.

2.  **"Powering Up" Walls:** Each wall segment has a `cost`. 
    When the player's `score` is greater than or equal to a wall's `cost`, 
    that wall segment turns **green**. 
    This visually signals that a "Safe Breakout" is possible through that segment.

#### The Escape: The Final Breakout

The player can attempt to break any wall segment by colliding with it. 
The outcome depends on whether **all** walls have been powered up.

*   **Safe Breakout (Win Condition):**
    *   **Condition:** **All** wall segments are green, and the player collides with any one of them.
    *   **Outcome:** The wall is destroyed. The game ends in a **victory**. 
        The player's final score is their current `score`.

*   **Failed Attempt (Penalty):**
    *   **Condition:** The player collides with any wall segment before **all** segments are green.
    *   **Outcome:** The wall remains, but the player is penalized. 
        The full `cost` of the wall is subtracted from the `score`, 
        potentially resulting in a negative "debt". 
        This does **not** end the game. 
        This penalty applies even if the specific wall collided with was already green.

#### The Monster: A Dynamic Threat

The monster (Tile ID 7) adds a dynamic challenge and a path to redemption.

*   **The Hunt:** The monster becomes active and starts hunting the player whenever the player's `score` is positive.

*   **Getting Caught (Penalty):**
    *   **Condition:** The monster catches the player while the `score` is positive.
    *   **Outcome:** The player's `score` is halved (`score / 2`). The monster becomes dormant for a short period before hunting again.

*   **Fighting Back (Redemption):**
    *   **Condition:** The player, while having a negative `score` (in "debt"), catches the dormant monster.
    *   **Outcome:** The player's `score` is reset to **0**. The monster remains dormant for a short period.

#### Game Over

The game concludes when the player achieves a "Safe Breakout". At this point, all tiles (player, coin, monster, walls) are removed from the screen, and the final score is displayed.
