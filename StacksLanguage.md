# Stacks Language Manual

## Introduction

"Stacks" is a stack-based, Forth-like programming language designed for the Stern-XT computer. It features a simple, postfix notation and can be used interactively or to run compiled programs. Its core is a compact interpreter and compiler that runs directly on the Stern-XT hardware.

## Execution Modes

The Stacks interpreter can operate in two distinct modes: Immediate Mode and Program Mode.

### Immediate Mode (REPL)

This mode provides a Read-Eval-Print Loop (REPL) environment. You can type commands, and they are executed immediately. It's useful for quick calculations, inspecting variables, and testing small snippets of logic.

-   **How it works:** The interpreter reads a token, executes it, and then reads the next.
-   **Limitations:** Control flow structures that require compilation (like `if/else/end`, `while/do/done`, `goto`, and function definitions) are not available in this mode.

**Example:**
```
> 10 20 + print
30
> 5 dup * print
25
```

### Program Mode

This mode is for running complete programs. When you execute a program, it goes through a three-phase process: Scan, Compile, and Execute. This allows for more complex structures like loops, conditionals, and functions.

1.  **Phase 1: Scan:** The interpreter first scans the entire program to identify all labels (`:mylabel`) and function definitions (`def myfunc { ... }`). It builds tables to map these names to their future memory addresses. This step ensures that jumps and calls can be resolved correctly during compilation.

2.  **Phase 2: Compile:** The interpreter translates the human-readable Stacks code into a compact bytecode. It resolves `goto` targets and handles the complex address patching required for control flow structures like `if/else/end` and `while/do/done`. Function bodies are compiled into a separate memory space.

3.  **Phase 3: Execute:** The CPU executes the generated bytecode. The program runs sequentially, performing stack operations, arithmetic, and control flow jumps as defined by the compiled instructions.

## Syntax

### Numbers and Variables

-   **Numbers:** Any sequence of digits is treated as a number and is pushed onto the data stack when encountered.
-   **Variables:** Variables are defined in assembly and can be accessed by their name. When a variable name is used, its memory address is pushed onto the stack. Use `@` (fetch/restore) and `!` (store) to read from or write to the address.

### Comments

The Stacks language itself does not have a dedicated comment syntax within the code passed to the interpreter. Comments are typically handled at the assembler level (using `#` or `;`).

### Labels

Labels define a named location in the code for use with `goto`. They are defined with a colon prefix.

**Syntax:**
```
:mylabel
```

### Functions

Functions are reusable blocks of code. They are defined with the `def` keyword and can be called by name.

-   **Definition:**
    ```
    def my_function {
        ... function body ...
    }
    ```
    A `ret` (return) instruction is implicitly added to the end of every function.

-   **Calling:**
    To call a function, simply use its name.
    ```
    my_function
    ```
    When a function is called, the interpreter saves the current execution address, jumps to the function's code, and executes it. When it hits a `ret`, it restores the saved address and continues execution from where it left off.

## Core Instructions

The following is a list of built-in words (instructions) supported by the Stacks language. The stack effect is shown as `( before -- after )`.

### Stack Manipulation

| Word | Stack Effect | Description |
|---|---|---|
| `dup` | `( n -- n n )` | Duplicates the top item on the stack. |
| `swap`| `( n1 n2 -- n2 n1 )` | Swaps the top two items on the stack. |
| `drop`| `( n -- )` | Discards the top item on the stack. |
| `over`| `( n1 n2 -- n1 n2 n1 )` | Copies the second item from the top of the stack to the top. |

### Arithmetic

| Word | Stack Effect | Description |
|---|---|---|
| `+` | `( n1 n2 -- sum )` | Adds the top two items. |
| `-` | `( n1 n2 -- diff )` | Subtracts the top item from the second item. |
| `*` | `( n1 n2 -- prod )` | Multiplies the top two items. |
| `/` | `( n1 n2 -- quot )` | Divides the second item by the top item. |
| `mod` | `( n1 n2 -- rem )` | Computes the remainder of dividing the second item by the top item. |

### Memory Access

| Word | Stack Effect | Description |
|---|---|---|
| `@` | `( addr -- value )` | Fetches the value from the given memory address and pushes it onto the stack. |
| `!` | `( value addr -- )` | Stores the value at the given memory address. |

### Comparison Operators

Comparison operators consume two values from the stack and push a result: `1` for true, `0` for false.

| Word | Stack Effect | Description |
|---|---|---|
| `==` | `( n1 n2 -- flag )` | Returns true if `n1` is equal to `n2`. |
| `!=` | `( n1 n2 -- flag )` | Returns true if `n1` is not equal to `n2`. |
| `>` | `( n1 n2 -- flag )` | Returns true if `n1` is greater than `n2`. |
| `<` | `( n1 n2 -- flag )` | Returns true if `n1` is less than `n2`. |

### Control Flow

These words are only available in **Program Mode**.

| Word | Syntax | Description |
|---|---|---|
| `goto` | `goto <label>` | Unconditionally jumps to the specified `:label`. |
| `if` | `<flag> if ... end` | If `flag` is non-zero, executes the code between `if` and `end` (or `else`). |
| `else` | `if ... else ... end` | Executes the code between `else` and `end` if the `if` condition was false. |
| `end` | `if ... [else ...] end` | Marks the end of an `if` or `if/else` block. |
| `while`| `while ... do ... done` | Marks the beginning of a loop's condition. |
| `do` | `while <condition> do ... done` | Evaluates the condition. If true, executes the loop body. If false, jumps past `done`. |
| `done` | `while ... do ... done` | Marks the end of the loop body and jumps back to the `while` to re-evaluate the condition. |
| `ret` | `( -- )` | Returns from the current function. Implicitly added at the end of a `def` block. |

### I/O

| Word | Stack Effect | Description |
|---|---|---|
| `print` | `( n -- )` | Pops the top value from the stack and prints it to the screen. |
| `io` | `( ... -- ... )` | A generic instruction for device I/O. Its behavior depends on the arguments provided. |
