;-------------------------------------------------------------------------------
; loader_keyboard_routines.asm
;
; Routines for handling buffered keyboard input for the OS Kernel.
;-------------------------------------------------------------------------------

EQU ~KBD_BUFFER_SIZE 64
EQU ~KEY_RETURN 13
EQU ~KEY_BACKSPACE 8

; --- Keyboard Buffer Data ---
. $kbd_buffer_head 1            ; Pointer to the next free spot
. $kbd_buffer_tail 1            ; Pointer to the next char to read
. $kbd_buffer 64                ; ~KBD_BUFFER_SIZE bytes for the circular buffer


; base adrs for the IO registers
. $KBD_IO_BASE_POINTER 1        ; IO memory base adres

@KBD_INIT
    ; Initialize IO memory register
    ldi M ~VAR_START
    subi M 8
    sto M $KBD_IO_BASE_POINTER  ; set KBD IO base adres in memory

    ; Initialize buffer pointers
    ldi A 0
    sto A $kbd_buffer_head
    sto A $kbd_buffer_tail
    ret

;-------------------------------------------------------------------------------
; Keyboard Interrupt Service Routine (@KBD_ISR)
;
; Reads a character from the keyboard device, echoes it to the screen,
; and places it in a circular buffer. Handles backspace.
;-------------------------------------------------------------------------------
@KBD_ISR
    ; --- Get character from keyboard ---
    ldi I 0                     ; KBD read register is 0
    ldx C $KBD_IO_BASE_POINTER  ; Read character from device into C
    nop
    ld M C                      ; Save character in M for later

    ; --- Handle Backspace --- 
    tst C ~KEY_BACKSPACE
    jmpf :check_return          ; If not backspace, check for return
    
    ; Backspace logic
    ldm A $kbd_buffer_head
    ldm B $kbd_buffer_tail
    tste A B                    ; Is buffer head == buffer tail? (is buffer empty?)
    jmpt :isr_done              ; If empty, nothing to do

    ; Decrement head pointer (with wrap-around)
    subi A 1
    tst A 0                     ; Did it underflow?
    jmpt :head_wrap_around
    jmp :store_head
:head_wrap_around
    ldi A ~KBD_BUFFER_SIZE
    subi A 1
:store_head
    sto A $kbd_buffer_head

    ; Echo backspace to screen (assuming @print_char handles it)
    ldi C ~KEY_BACKSPACE
    call @print_char
    jmp :isr_done

:check_return
    ; --- Save character ---
    ld M C                      ; Save character from keyboard in M

    ; --- Buffer Full Check ---
    ldm A $kbd_buffer_head
    ldm B $kbd_buffer_tail

    ; Calculate next head to check for full
    ldi C 1
    add C A
    tst C ~KBD_BUFFER_SIZE
    jmpf :head_ok
    ldi C 0
:head_ok
    tste C B                  ; Is next_head == tail?
    jmpt :isr_done              ; If full, ignore key

    ; --- Store character in buffer ---
    ldm I $kbd_buffer_head      ; <<< FIX: Load head pointer directly into Index Register I
    ld C M                      ; Restore the character into C
    stx C $kbd_buffer           ; Store C at kbd_buffer[I]

    ; --- Increment head pointer ---
    ldm A $kbd_buffer_head      ; Reload A (since we used it for the check)
    addi A 1
    tst A ~KBD_BUFFER_SIZE
    jmpf :store_new_head
    ldi A 0
:store_new_head
    sto A $kbd_buffer_head

    ; --- Echo character to screen ---
    ld C M                      ; Restore the character for printing
    call @print_char

:isr_done
    rti                         ; Return from interrupt