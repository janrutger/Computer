# Adding Structs to the Stacks Language

## 1. Design Philosophy: Contiguous Memory
Refined approach: Instead of a list of pointers (which causes double indirection and fragmentation), a Struct will be a **single contiguous block of memory** on the heap.

*   **Efficiency:** 1 allocation per struct instance, not 1 per field.
*   **Simplicity:** Fields are just offsets from the base pointer.
*   **"Everything is a Word":** Every field is 1 word (integer). It can be a raw value (e.g., HP=100) or a pointer to another object (e.g., Inventory=Address).
*   **Consumer Responsibility:** The library returns a generic integer. The programmer must know if that integer represents a value or a pointer to another structure/array.

## 2. Implementation Strategy: Runtime Library
Since we want to avoid modifying the compiler, we will implement a **Dynamic Type System** in a library (`std_struct.stacks`).

*   **No Compiler Changes:** We use standard Stacks syntax.
*   **Runtime Resolution:** Field names are resolved to memory offsets while the program runs.
*   **Hashing:** Field names are hashed into integers *before* calling the library functions.

## 3. Data Structures

### The Struct Type (The Blueprint)
Created once. Stores the mapping between Field Names (Hashes) and Offsets.
*   **Heap Layout:**
    *   `[0]`: Number of Fields (N)
    *   `[1]`: Hash of Field 1 Name
    *   `[2]`: Hash of Field 2 Name
    *   `...`: ...

### The Struct Instance (The Object)
Created many times. Stores the actual data.
*   **Heap Layout:**
    *   `[0]`: **Pointer to Struct Type** (Crucial for looking up field names!)
    *   `[1]`: Value of Field 1
    *   `[2]`: Value of Field 2
    *   `...`: ...

## 4. API Reference

### Defining a Type
`STRUCT.new_type`
*   **Stack:** `( field_hash_1 ... field_hash_N N -- type_ptr )`
*   **Action:** Creates the Blueprint. Stores the provided hashes.
*   **Example:** `\"hp" HASH.stack \"xp" HASH.stack 2 STRUCT.new_type AS player_type`

### Creating an Instance
`STRUCT.new`
*   **Stack:** `( type_ptr -- instance_ptr )`
*   **Action:** Allocates memory (Size = N + 1). Stores `type_ptr` in slot 0.
*   **Example:** `player_type STRUCT.new AS my_player`

### Writing to a Field
`STRUCT.put`
*   **Stack:** `( value field_hash instance_ptr -- )`
*   **Action:**
    1.  Read `type_ptr` from `instance_ptr`.
    2.  Search `type_ptr` for `field_hash`.
    3.  Write `value` to `instance_ptr + found_index`.

### Reading from a Field
`STRUCT.get`
*   **Stack:** `( field_hash instance_ptr -- value )`
*   **Action:** Similar to put, but reads the value.

### Note on Field Hashes
The Struct library expects **Integer Hashes**, not strings.
*   **Immediate:** Use `\"name" HASH.stack` to generate a hash on the fly.
*   **Stored:** Use `HASH.string` on a stored string variable.
*   **Optimized:** Define hashes as `CONST` values to avoid runtime hashing entirely.





## 5. Helper Functions (New Library: std_hash)  Done

The `std_string` library provides the `STRhash' function for runtime hashing of string pointers (e.g. user input).
For static strings (like field names), the compiler now supports **Compile-Time Hashing** using the `\"string"` syntax.

### Compile-Time Hashing
*   **Syntax:** `\"string"`
*   **Action:** The compiler calculates the DJB2 hash of the string and pushes the resulting integer onto the stack.
*   **Cost:** 0 Runtime CPU cycles. 0 RAM bytes.

### Runtime Hashing (`std_string`)
For strings stored in memory (pointers), use `STRhash`.


## 6. Future Development: Advanced Data Structures

Building on the success of `std_struct`, the next phase involves creating more flexible dynamic containers.

### 6.1 Dictionary (`std_dict`)
While `std_struct` is optimized for fixed-shape objects (like C structs), a Dictionary allows keys to be added and removed dynamically at runtime.

*   **Design:** Linear Dictionary (Packed Array of Key-Value pairs).
    *   **Memory Layout:** `[Capacity, Count, Key1, Value1, Key2, Value2, ...]`
    *   **Lookup:** Linear scan (loop through keys). Efficient for small collections.
    *   **Removal:** "Swap-with-Last" (Move last pair to empty slot, decrement count).
    *   **Fixed Capacity:** No resizing to prevent heap fragmentation.
    *   **Constraint:** Key `0` is reserved as "Empty" and cannot be used as a valid key.
*   **Key Difference:** Unlike Structs, the "Type" (list of keys) is not shared or fixed. Each instance manages its own keys.
*   **API:**
    *   `DICT.new`: Creates a new empty dictionary with a fixed capacity. All keys initialized to 0.
    *   `DICT.put`: Adds or updates a key-value pair. Fails if full.
    *   `DICT.get`: Retrieves a value by key hash.
    *   `DICT.remove`: Removes a key by swapping it with the last element.
    *   `DICT.has_key`: Checks existence.
    *   `DICT.count`: Returns the current number of items.
    *   `DICT.item`: Retrieves key and value by index (0..count-1). Stack: `( index dict_ptr -- key value )`.

### 6.2 Deque (`std_deque`)
A Double-Ended Queue, optimized for adding and removing elements from both the front and back.

*   **Design:** Doubly Linked List using a **Dynamic Node Pool (Slab Allocator)**.
    *   **Problem:** Fixed pools limit capacity; standard allocation fragments memory.
    *   **Solution:** A pool that grows on demand by allocating "Pages" of nodes from the heap.
    *   **Mechanism:** When the `Free_List` is empty, a new page is allocated and linked to the free list.
    *   **Node Layout:** `[Value, Next_Ptr, Prev_Ptr]` (3 words).
*   **Use Case:** Queues, Stacks, or chains for Hash Map collision handling.
*   **API:**
    *   `DEQUE.init_pool`: Initializes the pool with an initial page size. Stack: `( page_size -- )`.
    *   `DEQUE.new`: Creates a deque controller `[Head_Ptr, Tail_Ptr]` on the heap. Stack: `( -- deque_ptr )`.
    *   `DEQUE.push`: Gets node from pool (growing if needed), adds to start. Stack: `( value deque_ptr -- )`.
    *   `DEQUE.append`: Gets node from pool (growing if needed), adds to end. Stack: `( value deque_ptr -- )`.
    *   `DEQUE.pop`: Removes the first node (head), returns its value, and recycles the node. Stack: `( deque_ptr -- value )`.
    *   `DEQUE.pop_tail`: Removes the last node (tail), returns its value, and recycles the node. Stack: `( deque_ptr -- value )`.
    *   `DEQUE.is_empty`: Checks if empty. Stack: `( deque_ptr -- bool )`.
    *   `DEQUE.head`: Returns the pointer to the first node (or 0 if empty). Stack: `( deque_ptr -- node_ptr )`.
    *   `DEQUE.tail`: Returns the pointer to the last node (or 0 if empty). Stack: `( deque_ptr -- node_ptr )`.
    *   `DEQUE.next`: Given a node pointer, returns the next node pointer (or 0). Stack: `( node_ptr -- next_node_ptr )`.
    *   `DEQUE.prev`: Given a node pointer, returns the previous node pointer (or 0). Stack: `( node_ptr -- prev_node_ptr )`.
    *   `DEQUE.value`: Given a node pointer, returns the stored value. Stack: `( node_ptr -- value )`.


    
