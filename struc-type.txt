# Adding Structs to the Stacks Language

## 1. Design Philosophy: Contiguous Memory
Refined approach: Instead of a list of pointers (which causes double indirection and fragmentation), a Struct will be a **single contiguous block of memory** on the heap.

*   **Efficiency:** 1 allocation per struct instance, not 1 per field.
*   **Simplicity:** Fields are just offsets from the base pointer.
*   **"Everything is a Word":** Every field is 1 word (integer). It can be a raw value (e.g., HP=100) or a pointer to another object (e.g., Inventory=Address).
*   **Consumer Responsibility:** The library returns a generic integer. The programmer must know if that integer represents a value or a pointer to another structure/array.

## 2. Implementation Strategy: Runtime Library
Since we want to avoid modifying the compiler, we will implement a **Dynamic Type System** in a library (`std_struct.stacks`).

*   **No Compiler Changes:** We use standard Stacks syntax.
*   **Runtime Resolution:** Field names are resolved to memory offsets while the program runs.
*   **Hashing:** Field names are hashed into integers *before* calling the library functions.

## 3. Data Structures

### The Struct Type (The Blueprint)
Created once. Stores the mapping between Field Names (Hashes) and Offsets.
*   **Heap Layout:**
    *   `[0]`: Number of Fields (N)
    *   `[1]`: Hash of Field 1 Name
    *   `[2]`: Hash of Field 2 Name
    *   `...`: ...

### The Struct Instance (The Object)
Created many times. Stores the actual data.
*   **Heap Layout:**
    *   `[0]`: **Pointer to Struct Type** (Crucial for looking up field names!)
    *   `[1]`: Value of Field 1
    *   `[2]`: Value of Field 2
    *   `...`: ...

## 4. API Reference

### Defining a Type
`STRUCT.new_type`
*   **Stack:** `( field_hash_1 ... field_hash_N N -- type_ptr )`
*   **Action:** Creates the Blueprint. Stores the provided hashes.
*   **Example:** `\"hp" HASH.stack \"xp" HASH.stack 2 STRUCT.new_type AS player_type`

### Creating an Instance
`STRUCT.new`
*   **Stack:** `( type_ptr -- instance_ptr )`
*   **Action:** Allocates memory (Size = N + 1). Stores `type_ptr` in slot 0.
*   **Example:** `player_type STRUCT.new AS my_player`

### Writing to a Field
`STRUCT.put`
*   **Stack:** `( value field_hash instance_ptr -- )`
*   **Action:**
    1.  Read `type_ptr` from `instance_ptr`.
    2.  Search `type_ptr` for `field_hash`.
    3.  Write `value` to `instance_ptr + found_index`.

### Reading from a Field
`STRUCT.get`
*   **Stack:** `( field_hash instance_ptr -- value )`
*   **Action:** Similar to put, but reads the value.

### Note on Field Hashes
The Struct library expects **Integer Hashes**, not strings.
*   **Immediate:** Use `\"name" HASH.stack` to generate a hash on the fly.
*   **Stored:** Use `HASH.string` on a stored string variable.
*   **Optimized:** Define hashes as `CONST` values to avoid runtime hashing entirely.





## 5. Helper Functions (New Library: std_hash)

The `std_string` library provides the `STRhash' function for runtime hashing of string pointers (e.g. user input).
For static strings (like field names), the compiler now supports **Compile-Time Hashing** using the `\"string"` syntax.

### Compile-Time Hashing
*   **Syntax:** `\"string"`
*   **Action:** The compiler calculates the DJB2 hash of the string and pushes the resulting integer onto the stack.
*   **Cost:** 0 Runtime CPU cycles. 0 RAM bytes.

### Runtime Hashing (`std_string`)
For strings stored in memory (pointers), use `STRhash`.

