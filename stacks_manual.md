
+----------------------------------+
|                                  |
|   THE STACKS PROGRAMMING BIBLE   |
|                                  |
|      FOR THE STERN-XT COMPUTER   |
|                                  |
+----------------------------------+

SECTION 1: INTRODUCTION
-------------------------

STACKS IS A FORTH-LIKE PROGRAMMING LANGUAGE FOR THE STERN-XT COMPUTER. IT IS A STACK-BASED LANGUAGE THAT USES REVERSE POLISH NOTATION (RPN).

THE LANGUAGE IS PROCESSED BY A THREE-PHASE INTERPRETER THAT SUPPORTS BOTH DIRECT "IMMEDIATE MODE" EXECUTION AND THE COMPILATION AND EXECUTION OF PROGRAMS.


SECTION 2: CORE CONCEPTS
--------------------------

### THE DATA STACK

ALL OPERATIONS IN STACKS WORK ON A CENTRAL DATA STACK. NUMBERS ARE PUSHED ONTO THE STACK, AND OPERATORS POP VALUES FROM THE STACK, PERFORM AN OPERATION, AND PUSH THE RESULT BACK ONTO THE STACK.

FOR EXAMPLE, TO CALCULATE (5 + 3) * 2, YOU WOULD WRITE:
> 5 3 + 2 *

1. 5 IS PUSHED. STACK: [5]
2. 3 IS PUSHED. STACK: [5, 3]
3. + POPS 3 AND 5, ADDS THEM, AND PUSHES 8. STACK: [8]
4. 2 IS PUSHED. STACK: [8, 2]
5. * POPS 2 AND 8, MULTIPLIES THEM, AND PUSHES 16. STACK: [16]

### IMMEDIATE MODE VS. PROGRAM MODE

*   **IMMEDIATE MODE:** TYPE COMMANDS DIRECTLY AT THE PROMPT FOR INSTANT EXECUTION. USEFUL FOR QUICK CALCULATIONS. COMPLEX CONTROL FLOW LIKE IF OR GOTO IS NOT SUPPORTED.

*   **PROGRAM MODE:** LOAD A SCRIPT FROM THE VIRTUAL DISK (E.G., `load my_program.txt`) AND EXECUTE THE ENTIRE PROGRAM AT ONCE WITH THE `run` COMMAND.


SECTION 3: LANGUAGE REFERENCE
-------------------------------

### STACK MANIPULATION

*   `DUP`: DUPLICATES THE TOP ITEM ON THE STACK.
*   `SWAP`: SWAPS THE TOP TWO ITEMS ON THE STACK.
*   `DROP`: REMOVES THE TOP ITEM FROM THE STACK.
*   `OVER`: COPIES THE SECOND ITEM FROM THE TOP AND PUSHES IT ONTO THE STACK.

### ARITHMETIC

*   `+`, `-`, `*`, `/`, `%`: STANDARD ARITHMETIC OPERATORS.

### VARIABLES

STACKS SUPPORTS 26 SINGLE-LETTER VARIABLES (A-Z).

*   `<value> A !`: STORES THE <value> FROM THE TOP OF THE STACK INTO VARIABLE A.
*   `A @`: RETRIEVES THE VALUE FROM VARIABLE A AND PUSHES IT ONTO THE STACK.

### OUTPUT

*   `PRINT`: POPS THE TOP VALUE FROM THE STACK AND PRINTS IT TO THE SCREEN.

### COMPARISONS

THESE OPERATORS PUSH 1 FOR TRUE OR 0 FOR FALSE.

*   `==`: EQUAL
*   `!=`: NOT EQUAL
*   `>`: GREATER THAN
*   `<`: LESS THAN

### CONDITIONAL LOGIC

**SYNTAX:** `condition IF ... ELSE ... END`

THE `ELSE` BLOCK IS OPTIONAL.

**EXAMPLE:**
```
10 5 > IF
    1 PRINT # WILL EXECUTE
ELSE
    0 PRINT
END
```

### LOOPS

**SYNTAX:** `condition WHILE ... DO ... DONE`

THE LOOP FIRST EVALUATES THE `WHILE` PART. IF THE RESULT IS TRUE (NON-ZERO), THE `DO` BLOCK IS EXECUTED.

**EXAMPLE:**
```
0 A ! # INITIALIZE A TO 0
WHILE A @ 5 < DO
    A @ PRINT
    A @ 1 + A !
DONE
# OUTPUT: 0 1 2 3 4
```

### LABELS AND GOTO

*   `:my_label`: DEFINES A LABEL NAMED `my_label`.
*   `GOTO my_label`: IMMEDIATELY JUMPS EXECUTION TO THAT LABEL.

### FUNCTIONS

**SYNTAX:** `DEF function_name { ... body ... }`

FUNCTIONS ARE REUSABLE BLOCKS OF CODE.

**EXAMPLE:**
```
# DEFINE A FUNCTION TO SQUARE A NUMBER
DEF square {
    DUP *
}

# CALL THE FUNCTION
5 square PRINT # PUSHES 5, CALLS SQUARE, PRINTS THE RESULT (25)
```

SECTION 4: THE KERNEL AND INTERPRETER
---------------------------------------

THE STACKS INTERPRETER IS A COMPLEX SYSTEM THAT USES SEVERAL MEMORY AREAS (STACKS) TO MANAGE PROGRAM EXECUTION. THESE ARE DEFINED IN `kernel_stacks.asm`.

### THE THREE PHASES

1.  **SCAN PHASE (`@_1_scan_phase`):** THE INTERPRETER SCANS FOR ALL `:label` DEFINITIONS TO BUILD A JUMP TABLE. THIS ALLOWS `GOTO` TO WORK.

2.  **COMPILE PHASE (`@_2_compile_phase`):** THE SOURCE CODE IS TRANSLATED INTO EFFICIENT BYTECODE. CONTROL STRUCTURES LIKE `IF` AND `WHILE` USE PLACEHOLDERS THAT ARE PATCHED AT THE END OF THIS PHASE.

3.  **EXECUTION PHASE (`@_3_execution_phase`):** THE BYTECODE IS EXECUTED. FUNCTION CALLS ARE HANDLED BY SEARCHING A HASH TABLE AND JUMPING TO THE FUNCTION'S CODE.

### KERNEL STACKS

THE INTERPRETER USES THE FOLLOWING STACKS:

*   `$DATASTACK`: THE MAIN STACK FOR ALL YOUR CALCULATIONS.
*   `$PLACEHOLDER_STACK`: USED BY THE COMPILER TO REMEMBER FORWARD-JUMP ADDRESSES FOR `IF` AND `DO` THAT NEED TO BE PATCHED.
*   `$LOOP_STACK`: USED BY THE COMPILER TO REMEMBER THE STARTING ADDRESS OF A `WHILE..DO..DONE` LOOP.
*   `$CALL_STACK`: USED DURING EXECUTION TO STORE THE RETURN ADDRESS WHEN A FUNCTION IS CALLED.
*   `$COMPILER_STATE_STACK`: USED BY THE COMPILER TO SAVE ITS STATE WHEN IT SWITCHES TO COMPILING A FUNCTION BODY.

