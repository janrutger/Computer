
# This program draw an function y=f(x) on the grid
# where x=[-10 .. 10] and y=[0 .. 100]

INCLUDE math_lib
INCLUDE fixed_point_lib
INCLUDE turtle_lib
USE std_stern_io
USE std_time

; --- Constants ---
CONST SCREEN_WIDTH 640
CONST SCREEN_HEIGHT 480

; --- Drawing transformation ---
; World coordinate range to be drawn
; X-axis: -7 to +7
; Y-axis: will be scaled by SCALE_Y

; Center of the screen
CONST X_OFFSET 320 ; SCREEN_WIDTH / 2
CONST Y_OFFSET 240 ; SCREEN_HEIGHT - 40, to move axis down

; Scale factor for the axes for X-axis: -3.1 to +3.1
; To draw from -3.1 to +3.1 on a 640px wide screen,
; the scale factor is 640 / 6.2 = ~103.
CONST SCALE_X 103  ; 1 unit in world space = 103 pixels

; This value needs to be adjusted based on the range of the function being plotted.
; For sin(x), the range is [-1, 1]. A scale of 100 makes this visible.
VALUE SCALE_Y 0  ; For Taylor series y=x-(x^3/6) with x=[-10,10], y range is approx [-157, 157]. Scale 1 fits.


; Converts a screen x-coordinate to a world x-coordinate.
DEF screen_to_world_x { ; ( screen_x_int -- world_x_fp )
    FP.from_int
    X_OFFSET FP.from_int
    FP.sub
    SCALE_X FP.from_int 
    FP.div
}

; Converts a world x-coordinate to a screen x-coordinate.
DEF world_to_screen_x { ; ( world_x_fp -- screen_x_int )
    ; Correct formula: (world_x * SCALE_X) + X_OFFSET
    SCALE_X FP.from_int
    FP.mul
    X_OFFSET FP.from_int
    FP.add
    FP.to_int
}

; Converts a world y-coordinate to a screen y-coordinate.
DEF world_to_screen_y { ; ( world_y_fp -- screen_y_int )
    SCALE_Y
    FP.mul
    Y_OFFSET FP.from_int SWAP
    FP.sub
    FP.to_int
}


; Calculates the Taylor series for sin(x) with 2 terms: y = x - (x^3 / 6)
DEF function_to_draw2 { ; ( x_fp -- result_fp )
    ; Stack: [x]
    ; Calculate x^3 / 6
    DUP DUP DUP     ; Stack: [x, x, x, x]
    FP.mul          ; Stack: [x, x, x*x]
    FP.mul          ; Stack: [x, x^3]
    6 FP.from_int   ; Stack: [x, x^3, 6_fp]
    FP.div          ; Stack: [x, (x^3 / 6)]
    
    ; Calculate x - (x^3 / 6)
    # SWAP            ; Stack: [(x^3 / 6), x]
    FP.sub          ; Stack: [x - (x^3 / 6)]
}

; Calculates the Taylor series for sin(x) with 3 terms: y = x - (x^3 / 6) + (x^5 / 120)
DEF function_to_draw3 { ; ( x_fp -- result_fp )
    # apply the 2-term
    DUP function_to_draw2     ; Stack: [x, x-(x^3 / 6)]
    SWAP                      ; Stack: [x-(x^3 / 6), x]

    DUP DUP DUP DUP           ; Stack: [x-(x^3 / 6), x, x, x, x, x]
    FP.mul                    ; Stack: [x-(x^3 / 6), x, x, x, x^2]
    FP.mul                    ; Stack: [x-(x^3 / 6), x, x, x^3]
    FP.mul                    ; Stack: [x-(x^3 / 6), x, x^4]
    FP.mul                    ; Stack: [x-(x^3 / 6), x^5]

    120 FP.from_int           ; Stack: [x-(x^3 / 6), x^5, 120_fp]
    FP.div                    ; Stack: [x-(x^3 / 6), (x^5 / 120)]
         
    FP.add                    ; Stack: [x-(x^3 / 6) + (x^5 / 120)]
}

; Calculates the Taylor series for sin(x) with 4 terms: y = x - (x^3 / 6) + (x^5 / 120) - (x^7 / 5040)
DEF function_to_draw4 { ; ( x_fp -- result_fp )
    # apply the 3-term
    DUP function_to_draw3     ; Stack: [x, 3-term-result]
    SWAP                      ; Stack: [3-term-result, x]

    # calculate x^7
    DUP DUP DUP DUP DUP DUP   ; Stack: [3-term-result, x, x, x, x, x, x, x]
    FP.mul                    ; x^2
    FP.mul                    ; x^3
    FP.mul                    ; x^4
    FP.mul                    ; x^5
    FP.mul                    ; x^6
    FP.mul                    ; x^7
                              ; Stack: [3-term-result, x^7]

    5040 FP.from_int          ; Stack: [3-term-result, x^7, 5040_fp]
    FP.div                    ; Stack: [3-term-result, (x^7 / 5040)]
         
    FP.sub                    ; Stack: [3-term-result - (x^7 / 5040)]
}

; --- Drawing Functions ---

; Draws the X and Y axes
DEF draw_axes {
    white TURTLE.color
    ; Y-axis (x is constant at X_OFFSET)
    X_OFFSET 0 
    X_OFFSET SCREEN_HEIGHT 1 - TURTLE.line
    ; X-axis (y is constant at Y_OFFSET)
    0 Y_OFFSET 
    SCREEN_WIDTH 1 - Y_OFFSET TURTLE.line
}


; Draws a function plot by calling the taylor function
DEF draw_plot2 { ; ( color -- )
    AS color
    color TURTLE.color

    ; Variables for screen coordinates
    0 AS sx1 
    0 AS sy1 
    0 AS prev_sx 
    0 AS prev_sy 
    1 AS is_first_point 
    0 AS world_x 
    
    ; Loop from -31 to 31, representing world_x from -3.1 to 3.1 with a step of 0.1
    31 negate AS i
    :loop_draw2
    
    ; Loop exit condition: jump to the end if i > 31
    i 31 > IF
        GOTO end_draw_plot2
    END
    ; --- Loop Body ---
    
    ; Convert loop counter `i` to FP world_x
    i FP.from_int 10 FP.from_int FP.div AS world_x

    ; Convert world coordinates to screen coordinates
    world_x world_to_screen_x AS sx1
    world_x function_to_draw2
    world_to_screen_y AS sy1


    is_first_point IF
        ; For the first point, we only store it as "previous" and don't draw.
        0 AS is_first_point
    ELSE
        ; For subsequent points, draw a line from the previous point.
        prev_sx prev_sy sx1 sy1 TURTLE.line
    END

    ; Save current screen coordinates for the next iteration.
    sx1 AS prev_sx
    sy1 AS prev_sy

    ; Increment counter and loop
    i 1 + AS i
    GOTO loop_draw2

    :end_draw_plot2
}

; Draws a function plot by calling the taylor function
DEF draw_plot3 { ; ( color -- )
    AS color
    color TURTLE.color

    ; Variables for screen coordinates
    0 AS sx1 
    0 AS sy1 
    0 AS prev_sx 
    0 AS prev_sy 
    1 AS is_first_point 
    0 AS world_x 
    
    ; Loop from -31 to 31, representing world_x from -3.1 to 3.1 with a step of 0.1
    31 negate AS i
    :loop_draw3
    
    ; Loop exit condition: jump to the end if i > 31
    i 31 > IF
        GOTO end_draw_plot3
    END
    ; --- Loop Body ---
    
    ; Convert loop counter `i` to FP world_x
    i FP.from_int 10 FP.from_int FP.div AS world_x

    ; Convert world coordinates to screen coordinates
    world_x world_to_screen_x AS sx1
    world_x function_to_draw3
    world_to_screen_y AS sy1


    is_first_point IF
        ; For the first point, we only store it as "previous" and don't draw.
        0 AS is_first_point
    ELSE
        ; For subsequent points, draw a line from the previous point.
        prev_sx prev_sy sx1 sy1 TURTLE.line
    END

    ; Save current screen coordinates for the next iteration.
    sx1 AS prev_sx
    sy1 AS prev_sy

    ; Increment counter and loop
    i 1 + AS i
    GOTO loop_draw3

    :end_draw_plot3
}

; Draws a function plot by calling the taylor function
DEF draw_plot4 { ; ( color -- )
    AS color
    color TURTLE.color

    ; Variables for screen coordinates
    0 AS sx1 
    0 AS sy1 
    0 AS prev_sx 
    0 AS prev_sy 
    1 AS is_first_point 
    0 AS world_x 
    
    ; Loop from -31 to 31, representing world_x from -3.1 to 3.1 with a step of 0.1
    31 negate AS i
    :loop_draw4
    
    ; Loop exit condition: jump to the end if i > 31
    i 31 > IF
        GOTO end_draw_plot4
    END
    ; --- Loop Body ---
    
    ; Convert loop counter `i` to FP world_x
    i FP.from_int 10 FP.from_int FP.div AS world_x

    ; Convert world coordinates to screen coordinates
    world_x world_to_screen_x AS sx1
    world_x function_to_draw4
    world_to_screen_y AS sy1


    is_first_point IF
        ; For the first point, we only store it as "previous" and don't draw.
        0 AS is_first_point
    ELSE
        ; For subsequent points, draw a line from the previous point.
        prev_sx prev_sy sx1 sy1 TURTLE.line
    END

    ; Save current screen coordinates for the next iteration.
    sx1 AS prev_sx
    sy1 AS prev_sy

    ; Increment counter and loop
    i 1 + AS i
    GOTO loop_draw4

    :end_draw_plot4
}


; --- Main Program ---
DEF main {
    ; Set fixed-point precision (e.g., 3 decimal places)
    1000 FP.set_scale


    TURTLE.start
    pixel TURTLE.mode
    
    ; Draw the X and Y axes
    draw_axes
    
    "Drawing 2-term (green) series..." PRTstring
    "100" FP.from_string AS SCALE_Y
    green draw_plot2

    "Drawing 3-term (red) series..." PRTstring
    "100" FP.from_string AS SCALE_Y
    red draw_plot3

    "Drawing 4-term (cyan) series..." PRTstring
    "100" FP.from_string AS SCALE_Y
    cyan draw_plot4

    "All done!" PRTstring
}

# main

    # 7 FP.from_int function_to_draw2 FP.print 13 PRTchar
    # 7 FP.from_int function_to_draw3 FP.print 13 PRTchar
    # 7 FP.from_int function_to_draw4 FP.print 13 PRTchar


    "3.0" FP.from_string function_to_draw2 FP.print 13 PRTchar
    "3.0" FP.from_string function_to_draw3 FP.print 13 PRTchar
    "3.0" FP.from_string function_to_draw4 FP.print 13 PRTchar

main