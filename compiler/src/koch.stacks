## L-System with Manual Stack for Recursion (v4)
# This version uses a purely stack-based approach inside the recursive
# function to avoid issues with global variables.

INCLUDE turtle_lib
USE std_stern_io

# -----------------------------------------------------------------------------
# Manual Stack Implementation for Recursion
# -----------------------------------------------------------------------------

CONST MAX_DEPTH 16
LIST level_stack 16             # Memory for our manual stack
VALUE stack_ptr 0 

&level_stack AS stack_ptr       # Pointer for our manual stack

# Pushes a value from the main program stack onto our manual stack.
# Usage: <value> stack_push
DEF stack_push {
    AS *stack_ptr              # Store value from stack to address in stack_ptr
    stack_ptr 1 + AS stack_ptr # Increment pointer
}

# Pops a value from our manual stack and puts it on the main program stack.
# Usage: stack_pop (leaves <value> on the stack)
DEF stack_pop {
    stack_ptr 1 - AS stack_ptr # Decrement pointer
    *stack_ptr                 # Load value from new address, leave on main stack
}

# -----------------------------------------------------------------------------
# Recursive L-System Drawing Function (Purely Stack-Based)
# -----------------------------------------------------------------------------
DEF draw_koch {
    # The current level is expected to be on top of the stack.
    # Pop the level from the manual stack.
    stack_pop

    # Check if level is 0 (the base case).
    DUP 0 == IF 
        DROP # Get rid of the level value (0)
        7 TURTLE.forward # Increased distance for high-res screen
        GOTO draw_koch_end # Finished
    END

    # --- Recursive Step ---
    # The level (n) is on the stack. Decrement it to get (n-1).
    1 - 

    # Now (n-1) is on the stack. We need it for all 5 recursive calls.
    
    # Call 1
    DUP stack_push # Duplicate (n-1) and push it to the manual stack
    draw_koch TURTLE.flip

    90 TURTLE.right

    # Call 2
    DUP stack_push
    draw_koch TURTLE.flip

    270 TURTLE.right

    # Call 3
    DUP stack_push
    draw_koch TURTLE.flip

    270 TURTLE.right

    # Call 4
    DUP stack_push
    draw_koch TURTLE.flip

    90 TURTLE.right

    # Call 5 (no DUP needed as we consume the last copy)
    stack_push
    draw_koch TURTLE.flip

:draw_koch_end
}

# -----------------------------------------------------------------------------
# Main Program
# -----------------------------------------------------------------------------


TURTLE.start                # 1. Initialize the turtle
db_pixel TURTLE.mode        # pixel TURTLE.mode


TOS.check IF               # check is something on the stack
    red TURTLE.color            # 2. Prepare for drawing
    &level_stack AS stack_ptr   # Reset stack pointer
    30 30 TURTLE.goto
    stack_push draw_koch
    TURTLE.flip
ELSE
    "\nUse of Koch: [0..4] 6144 USR \n" PRTstring
END

# red TURTLE.color            # 2. Prepare for drawing
# &level_stack AS stack_ptr   # Reset stack pointer
# 30 30 TURTLE.goto           # Adjusted starting position for better visibility
# 4 stack_push draw_koch      # 3. Push the starting level onto our manual stack and start the recursion
# TURTLE.flip                 # 4. Finalize drawing

# green TURTLE.color
# &level_stack AS stack_ptr   # Reset stack pointer
# 30 30 TURTLE.goto       # Adjusted starting position for better visibility
# 3 stack_push draw_koch  # 3 genearions
# TURTLE.flip

# blue TURTLE.color
# &level_stack AS stack_ptr   # Reset stack pointer
# 30 30 TURTLE.goto       # Adjusted starting position for better visibility
# 2 stack_push draw_koch  # 2 generations
# TURTLE.flip

# orange TURTLE.color
# &level_stack AS stack_ptr   # Reset stack pointer
# 30 30 TURTLE.goto       # Adjusted starting position for better visibility
# 1 stack_push draw_koch  # 1 generation
# TURTLE.flip

# white TURTLE.color
# &level_stack AS stack_ptr   # Reset stack pointer
# 30 30 TURTLE.goto       # Adjusted starting position for better visibility
# 0 stack_push draw_koch  # 0 generations
# TURTLE.flip
