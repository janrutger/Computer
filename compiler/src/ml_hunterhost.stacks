USE std_heap
USE std_time
USE std_stern_io

INCLUDE math_lib
INCLUDE fixed_point_lib
INCLUDE gpu3_lib
INCLUDE mlnn_gpu3_optimized_lib
INCLUDE turtle_lib

USE vvm_env_lib
USE vvm_core_lib

# the VVM instanes at the top of Extended memory
VALUE VVM0 30720        ; The memory address for VVM0, stored in a variable.
VALUE VVM1 31744        ; The memory address for VVM1, stored in a variable.

VALUE vvm_timeslice 50  ; Max instructions per VVM per frame to prevent infinite loops.
VALUE loop_counter  0   ; A temporary counter for the run loop.


VALUE network_ptr   0
CONST HOST.predict  100 ; Syscall ID for the predict function
CONST HOST.train    101 ; Syscall ID for the train function
CONST HOST.plot     102 ; Syscall ID for the plot function

VALUE target_x 0
VALUE target_y 0

VALUE input_arr  0       ; 0 is X, 1 is Y
VALUE output_ptr 0
VALUE dx_fp 0
VALUE dy_fp 0
VALUE vx_fp 0
VALUE vy_fp 0
VALUE reward_fp 0
VALUE tx_fp 0
VALUE ty_fp 0
VALUE target_arr 0
; VALUE _temp_ptr 0      ; Already defined


CONST Xoffset 100
CONST Yoffset 20
CONST radius   2
CONST screensize 440

# Fixedpoint scale
CONST SCALE 10000

# VVM Deque pointers and agent ID
VALUE VVM0_host_dq 0
VALUE VVM1_host_dq 0
VALUE AGENT_code   0

# Storage for previous positions to clear them (x, y for agent 0 and 1)
VALUE old_x0 0
VALUE old_y0 0
VALUE old_x1 0
VALUE old_y1 0



# create an NN-network and return its pointer
DEF create_neural_network {
    2 NEW.array AS input_arr
    2 NEW.array AS target_arr

    2 4 2 NN.new_network
    DUP PRTnum " Network address\n" PRTstring
}

DEF random_xy {   # returns an random XY values
    RND screensize 1 - * 999 //       # Push X
    RND screensize 1 - * 999 //       # Push Y
}

DEF init_playground {
    TURTLE.start        # Start the turtle graphics
    2 TURTLE.mode       # Double Buffer Pixel mode
    IO 2 NEW            # Start with a blank screen


    # Playground size 440x440
    # X-bounds: [100, 540]
    # Y-bounds: [20, 460]

    gray TURTLE.color
    100  20 540  20 TURTLE.line
    100 460 540 460 TURTLE.line
    100  20 100 460 TURTLE.line
    540  20 540 460 TURTLE.line
    TURTLE.flip

    
    # random_xy AS target_y AS target_x
    # for debugging the target is in the middle of the playground
    120 AS target_x
    320 AS target_y


    # Draw the target 
    green TURTLE.color
    target_x Xoffset +
    target_y Yoffset +
    radius TURTLE.circle
    TURTLE.flip
}


DEF _HOST.predict { 
    input_arr ARRAY.clear           ; an heap-lib function

    # expects dx dy on the host datastack
    # Normalize inputs to approx [-2, 2] range (screensize / 2 = 220)
    # FP.from_int screensize 2 // FP.from_int FP.div AS dy_fp
    # FP.from_int screensize 2 // FP.from_int FP.div AS dx_fp
    FP.from_int screensize 2 // // AS dy_fp
    FP.from_int screensize 2 // // AS dx_fp

    dx_fp input_arr ARRAY.append
    dy_fp input_arr ARRAY.append

    network_ptr input_arr NN.predict AS output_ptr
 
    # Get the fixed-point `vx_fp`, `vy_fp` from the result.
    # Rescale from Sigmoid [0, 1] to Tanh [-1, 1] range: (val * 2) - SCALE
    0 output_ptr ARRAY.get 2 * SCALE - AS vx_fp
    1 output_ptr ARRAY.get 2 * SCALE - AS vy_fp

    # Epsilon-Greedy Exploration: 10% chance to move randomly
    # This forces the agent to try directions it hasn't learned yet (like North/West)
    RND 100 % 10 < IF
        # Random move -1, 0, or 1
        RND 3 % 1 -
        RND 3 % 1 -
    ELSE
        # Convert `vx_fp`, `vy_fp` to integer steps (`-1`, `0`, `1`) using the `0.3` threshold logic.
        vx_fp 3000 > IF 1 ELSE vx_fp 3000 NEGATE < IF 1 NEGATE ELSE 0 END END
        vy_fp 3000 > IF 1 ELSE vy_fp 3000 NEGATE < IF 1 NEGATE ELSE 0 END END
    END

    # The FFI interface is responceble to move from host-stack to VVM-stack
}



DEF _HOST.train {
    # Pop `dx`, `dy`, `vx`, `vy`, `reward` (all integers) from the host stack.
    AS reward_fp   # Re-using var for integer reward
    AS vy_fp       # Re-using var for integer vy
    AS vx_fp       # Re-using var for integer vx
    
    # Convert dx, dy to normalized fixed-point
    FP.from_int screensize 2 // // AS dy_fp
    FP.from_int screensize 2 // // AS dx_fp

    # Prepare Input Array
    input_arr ARRAY.clear
    dx_fp input_arr ARRAY.append
    dy_fp input_arr ARRAY.append

    # --- Bounded Target Calculation ---
    # The training target should be the "ideal" velocity, which is in the range [-1, 1].
    # We calculate the integer target first, then convert to fixed point.
    # This prevents the massive target values that were destabilizing the network.
    vx_fp reward_fp * FP.from_int AS tx_fp
    vy_fp reward_fp * FP.from_int AS ty_fp

    # # Smart Correction (Teacher Forcing):
    # # If we are far from the target (abs(d) > 200), ensure the training target
    # # points towards the target. This prevents "Cross-talk" where a bad move
    # # on one axis causes the network to unlearn the correct move on the other.
    
    # dx_fp 200 > IF SCALE AS tx_fp END
    # dx_fp 200 NEGATE < IF SCALE NEGATE AS tx_fp END
    
    # dy_fp 200 > IF SCALE AS ty_fp END
    # dy_fp 200 NEGATE < IF SCALE NEGATE AS ty_fp END

    # Rescale targets from [-1, 1] to [0, 1] for Sigmoid activation: (val + SCALE) / 2
    tx_fp SCALE + 2 // AS tx_fp
    ty_fp SCALE + 2 // AS ty_fp

    # Prepare Target Array
    target_arr ARRAY.clear
    tx_fp target_arr ARRAY.append
    ty_fp target_arr ARRAY.append

    # Call NN.train (learning rate 0.1 = 1000)
    network_ptr input_arr target_arr 2000 NN.train
}


DEF _HOST.plot {
    # Pop `agent_id`, `x`, `y` from the host stack.
    AS dy_fp    # reusing var for y
    AS dx_fp    # reusing var for x
    AS vx_fp    # reusing var for agent_id

    vx_fp 0 == IF
        # Agent 0
        darkGray TURTLE.color      # lightGray leave an trace on the screen, otherwise black
        old_x0 Xoffset + old_y0 Yoffset + radius TURTLE.circle
        dx_fp AS old_x0 dy_fp AS old_y0
        red TURTLE.color
        old_x0 Xoffset + old_y0 Yoffset + radius TURTLE.circle
    ELSE
        # Agent 1
        darkGray TURTLE.color
        old_x1 Xoffset + old_y1 Yoffset + radius TURTLE.circle
        dx_fp AS old_x1 dy_fp AS old_y1
        yellow TURTLE.color
        old_x1 Xoffset + old_y1 Yoffset + radius TURTLE.circle
    END
    TURTLE.flip
}




DEF _init_main {
    HEAP.free
    50 DEQUE.init_pool "Pool initialized (size 50).\n" PRTstring
    SCALE FP.set_scale      # Set the fixed point scale factor
    SCALE NN.set_scale

    # RND DROP                # set some sort of seed for the random number generator
    # RND DROP
    # RND DROP
    # RND DROP


    DEQUE.new AS VVM0_host_dq       # Get a pointer for the host communication deque
    DEQUE.new AS VVM1_host_dq       # Get a pointer for the host communication deque
    DEQUE.new AS AGENT_code         # Get a pointer for the SIMPL code buffer for the agent
    
    VVM.init                        # init VVM environment
    "VVM Environment Initialized:\n" PRTstring

    &_HOST.predict HOST.predict VVM.bind
    &_HOST.train   HOST.train   VVM.bind
    &_HOST.plot    HOST.plot    VVM.bind


    # Load and create VVM0
    AGENT_code "sbc_hunter_agent" VVM.loadcode
    &AGENT_code 1024 &VVM0_host_dq &VVM0 VVM.create
    "VVM0 instance created \n\n" PRTstring

    # The agent code must be reloaded from disk for the second VVM,
    # as VVM.create consumes the deque.
    AGENT_code "sbc_hunter_agent" VVM.loadcode
    &AGENT_code 1024 &VVM1_host_dq &VVM1 VVM.create
    "VVM1 instance created \n\n" PRTstring


}





##### Main code from here
_init_main

# initialize the neural network
create_neural_network AS network_ptr


# initialize the playground start posistion
init_playground     # this will set 
                    # the target_x target_y values
                    # Draws the target circle



# Starting both VVMs.
# ADVICE: These arguments are placeholders. They should be replaced with
# target_x, target_y, and agent_id (0 or 1) from your project plan.
# ( arg1 ... argn argc &VVM-pointer -- )
target_x target_y 0 3 &VVM0 VVM.start
"VVM0 started \n" PRTstring

target_x target_y 1 3 &VVM1 VVM.start
"VVM1 started \n" PRTstring

# # Run/Crank the VVMs
# 1 TIME.start
WHILE   VVM_status &VVM0 VVMpeek VVM_Halted != 
        VVM_status &VVM1 VVMpeek VVM_Halted != + DO

    # The loop_counter must be reset each frame to avoid a stall.
    vvm_timeslice AS loop_counter
    WHILE loop_counter DO
        VVM_status &VVM0 VVMpeek VVM_Halted != IF
            &VVM0 VVM.run
        END

        VVM_status &VVM1 VVMpeek VVM_Halted != IF
            &VVM1 VVM.run
        END

        loop_counter 1 - AS loop_counter
    DONE

    # Check for any pending syscalls from either VVM
    &VVM0 VVM.check_syscalls
    &VVM1 VVM.check_syscalls

    # ADVICE: For better performance, consider a "run-until-block" loop for each VVM.
    # Example: WHILE VVM_status &VVM0 VVMpeek VVM_Running == DO &VVM0 VVM.run DONE

    # Redraw the target for visability
    green TURTLE.color
    target_x Xoffset +
    target_y Yoffset +
    radius TURTLE.circle

    # "." PRTstring                 # Print heartbeat
DONE
# 1 TIME.read TIME.as_string
