# This program draw an function y=f(x) on the grid
# where x=[-10 .. 10] and y=[0 .. 100]

INCLUDE math_lib
INCLUDE fixed_point_lib
INCLUDE turtle_lib
USE std_stern_io
USE std_time

; --- Constants ---
CONST SCREEN_WIDTH 640
CONST SCREEN_HEIGHT 480

; --- Drawing transformation ---
; World coordinate range to be drawn
; X-axis: -2pi to +2pi (6.3)
; Y-axis: will be scaled by SCALE_Y

; Center of the screen
CONST X_OFFSET 320 ; SCREEN_WIDTH / 2
CONST Y_OFFSET 240 ; SCREEN_HEIGHT - 40, to move axis down

; Scale factor for the axes for X-axis: -6.3 to +6.3 (2*PI)
; To draw from -6.3 to +6.3 on a 640px wide screen,
; the scale factor is 640 / 12.6 = ~51.
CONST SCALE_X 51  ; 1 unit in world space = 51 pixels

; This value needs to be adjusted based on the range of the function being plotted.
; For sin(x), the range is [-1, 1]. A scale of 100 makes this visible.
VALUE SCALE_Y 0  ; For Taylor series y=x-(x^3/6) with x=[-10,10], y range is approx [-157, 157]. Scale 1 fits.


; Converts a screen x-coordinate to a world x-coordinate.
DEF screen_to_world_x { ; ( screen_x_int -- world_x_fp )
    FP.from_int
    X_OFFSET FP.from_int
    FP.sub
    SCALE_X FP.from_int 
    FP.div
}

; Converts a world x-coordinate to a screen x-coordinate.
DEF world_to_screen_x { ; ( world_x_fp -- screen_x_int )
    ; Correct formula: (world_x * SCALE_X) + X_OFFSET
    SCALE_X FP.from_int
    FP.mul
    X_OFFSET FP.from_int
    FP.add
    FP.to_int
}

; Converts a world y-coordinate to a screen y-coordinate.
DEF world_to_screen_y { ; ( world_y_fp -- screen_y_int )
    SCALE_Y
    FP.mul
    Y_OFFSET FP.from_int SWAP
    FP.sub
    FP.to_int
}


DEF function_to_draw1 { ; ( x_fp -- result_fp )
    # Draw y=x
}


; Calculates the Taylor series for sin(x) with 2 terms: y = x - (x^3 / 6)
DEF function_to_draw2 { ; ( x_fp -- result_fp )
    ; Stack: [x]
    ; Calculate x^3 / 6
    DUP 3 FP.power  ; results in [x, x^3] on the stack
    #6 FP.from_int   ; Stack: [x, x^3, 6_fp]
    3 factorial FP.from_int   ; Stack: [x, x^3, 6_fp]
    FP.div          ; Stack: [x, (x^3 / 6)]
    
    ; Calculate x - (x^3 / 6)
    FP.sub          ; Stack: [x - (x^3 / 6)]
}

; Calculates the Taylor series for sin(x) with 3 terms: y = x - (x^3 / 6) + (x^5 / 120)
DEF function_to_draw3 { ; ( x_fp -- result_fp )
    # apply the 2-term
    DUP function_to_draw2     ; Stack: [x, x-(x^3 / 6)]
    SWAP                      ; Stack: [x-(x^3 / 6), x]

    # calculate x^5
    # DUP 5 FP.power
    # SWAP DROP                 ; drop x, stack: [res, x^5]
    5 FP.power


    # 120 FP.from_int           ; Stack: [x-(x^3 / 6), x^5, 120_fp]
    5 factorial FP.from_int   ; Stack: [x-(x^3 / 6), x^5, 120_fp]
    FP.div                    ; Stack: [x-(x^3 / 6), (x^5 / 120)]
         
    FP.add                    ; Stack: [x-(x^3 / 6) + (x^5 / 120)]
}

; Calculates the Taylor series for sin(x) with 4 terms: y = x - (x^3 / 6) + (x^5 / 120) - (x^7 / 5040)
DEF function_to_draw4 { ; ( x_fp -- result_fp )
    # apply the 3-term
    DUP function_to_draw3     ; Stack: [x, 3-term-result]
    SWAP                      ; Stack: [3-term-result, x]

    # calculate x^7
    # DUP 7 FP.power
    # SWAP DROP
    7 FP.power


    # 5040 FP.from_int          ; Stack: [3-term-result, x^7, 5040_fp]
    7 factorial FP.from_int    ; Stack: [3-term-result, x^7, 5040_fp]
    FP.div                    ; Stack: [3-term-result, (x^7 / 5040)]
         
    FP.sub                    ; Stack: [3-term-result - (x^7 / 5040)]
}

; Calculates the Taylor series for sin(x) with 5 terms: y = x - (x^3 / 6) + (x^5 / 120) - (x^7 / 5040) + (x^9 / 362880)
DEF function_to_draw5 { ; ( x_fp -- result_fp )
    # apply the 4-term
    DUP function_to_draw4     ; Stack: [x, 4-term-result]
    SWAP                      ; Stack: [4-term-result, x]

    # calculate x^9
    # DUP 9 FP.power
    # SWAP DROP
    9 FP.power


    # 362880 FP.from_int        ; Stack: [4-term-result, x^9, 362880_fp]
    9 factorial FP.from_int    ; Stack: [4-term-result, x^9, 362880_fp]
    FP.div                    ; Stack: [4-term-result, (x^9 / 362880)]
         
    FP.add                    ; Stack: [4-term-result + (x^9 / 362880)]
}

; Calculates the Taylor series for sin(x) with 6 terms: y = x - (x^3 / 6) + (x^5 / 120) - (x^7 / 5040) + (x^9 / 362880) - (x^11 / 39916800)
DEF function_to_draw6 { ; ( x_fp -- result_fp )
    # apply the 5-term
    DUP function_to_draw5     ; Stack: [x, 5-term-result]
    SWAP                      ; Stack: [5-term-result, x]

    # calculate x^11
    # DUP 11 FP.power
    # SWAP DROP
    11 FP.power



    # 39916800 FP.from_int      ; Stack: [5-term-result, x^11, 39916800_fp]
    11 factorial FP.from_int    ; Stack: [5-term-result, x^11, 39916800_fp]
    FP.div                    ; Stack: [5-term-result, (x^11 / 39916800)]
         
    FP.sub                    ; Stack: [5-term-result - (x^11 / 39916800)]
}

; Calculates the Taylor series for sin(x) with 7 terms: ... + (x^13 / 6227020800)
DEF function_to_draw7 { ; ( x_fp -- result_fp )
    # apply the 6-term
    DUP function_to_draw6     ; Stack: [x, 6-term-result]
    SWAP                      ; Stack: [6-term-result, x]

    # calculate x^13
        # DUP 13 FP.power
        # SWAP DROP
        13 FP.power
        

    # 6227020800 FP.from_int      ; Stack: [6-term-result, x^13, 13!_fp]
    # 13 factorial FP.from_int    ; Stack: [6-term-result, x^13, 13!_fp]
    # FP.div                    ; Stack: [6-term-result, (x^13 / 13!)]
    13 factorial FP.from_int
    FP.div                    ; Stack: [7-term-result, (x^15 / 15!)]
         
    FP.add                    ; Stack: [6-term-result + (x^13 / 13!)]
}

; Calculates the Taylor series for sin(x) with 8 terms: ... - (x^15 / 1307674368000)
DEF function_to_draw8 { ; ( x_fp -- result_fp )
    # apply the 7-term
    DUP function_to_draw7     ; Stack: [x, 7-term-result]
    SWAP                      ; Stack: [7-term-result, x]

    # calculate x^15
    # DUP 15 FP.power
    # SWAP DROP
    15 FP.power


    # 1307674368000 FP.from_int      ; Stack: [7-term-result, x^15, 15!_fp]
    15 factorial FP.from_int    ; Stack: [7-term-result, x^15, 15!_fp]
    FP.div                    ; Stack: [7-term-result, (x^15 / 15!)]
         
    FP.sub                    ; Stack: [7-term-result - (x^15 / 15!)]
}

; Calculates the Taylor series for sin(x) with 9 terms: ... + (x^17 / 355687428096000)
DEF function_to_draw9 { ; ( x_fp -- result_fp )
    # apply the 8-term
    DUP function_to_draw8     ; Stack: [x, 8-term-result]
    SWAP                      ; Stack: [8-term-result, x]

    # calculate x^17
    # DUP 17 FP.power
    # SWAP DROP
    17 FP.power



    # 355687428096000 FP.from_int      ; Stack: [8-term-result, x^17, 17!_fp]
    17 factorial FP.from_int    ; Stack: [8-term-result, x^17, 17!_fp]
    FP.div                    ; Stack: [8-term-result, (x^17 / 17!)]
         
    FP.add                    ; Stack: [8-term-result + (x^17 / 17!)]
}

; --- Drawing Functions ---

; Draws the X and Y axes
DEF draw_axes {
    lightGray TURTLE.color
    ; Y-axis (x is constant at X_OFFSET)
    X_OFFSET 20 ; a small offset from the top (20) to show the text line
    X_OFFSET SCREEN_HEIGHT 1 - TURTLE.line
    ; X-axis (y is constant at Y_OFFSET)
    0 Y_OFFSET 
    SCREEN_WIDTH 1 - Y_OFFSET TURTLE.line
}



; Draws a function plot by calling the specified function
DEF draw_plot { ; ( color function_index -- )
    AS function_index
    AS color
    color TURTLE.color

    ; Variables for screen coordinates
    0 AS sx1 
    0 AS sy1 
    0 AS prev_sx 
    0 AS prev_sy 
    1 AS is_first_point 
    0 AS world_x 
    
    ; Loop from -63 to 63, representing world_x from -6.3 to 6.3 with a step of 0.1
    63 negate AS i
    :loop_draw
    
    ; Loop exit condition: jump to the end if i > 63
    i 63 > IF
        GOTO end_draw_plot
    END
    ; --- Loop Body ---
    
    ; Convert loop counter `i` to FP world_x
    i FP.from_int 10 FP.from_int FP.div AS world_x

    ; Convert world coordinates to screen coordinates
    world_x world_to_screen_x AS sx1
    
    ; Call the selected function
    world_x
    function_index 1 == IF
        function_to_draw1
    ELSE
        function_index 2 == IF
            function_to_draw2
        ELSE
            function_index 3 == IF
                function_to_draw3
            ELSE
                function_index 4 == IF
                    function_to_draw4
                ELSE
                    function_index 5 == IF
                        function_to_draw5
                    ELSE
                        function_index 6 == IF
                            function_to_draw6
                        ELSE 
                            function_index 7 == IF
                                function_to_draw7
                            ELSE
                                function_index 8 == IF
                                    function_to_draw8
                                ELSE function_index 9 == IF
                                        function_to_draw9
                                    END
                                END
                            END
                        END
                    END
                END
            END
        END
    END

    world_to_screen_y AS sy1

    ; --- Clipping and Drawing Logic ---
    sy1 0 > IF
        sy1 480 < IF
            is_first_point IF
                ; For the first point, we only store it as "previous" and don't draw.
                0 AS is_first_point
            ELSE
                ; For subsequent points, draw a line from the previous point.
                prev_sx prev_sy sx1 sy1 TURTLE.line
            END
    END END

    ; Save current screen coordinates for the next iteration.
    sx1 AS prev_sx
    sy1 AS prev_sy

    ; Increment counter and loop
    i 1 + AS i
    GOTO loop_draw

    :end_draw_plot
}


; --- Main Program ---
DEF main {
    ; Set fixed-point precision (e.g., 3 decimal places)
    1000 FP.set_scale

    TURTLE.start
    pixel TURTLE.mode
    
    ; Draw the X and Y axes
    draw_axes
    
    "120" FP.from_string AS SCALE_Y

    "Drawing 1-term (blue) y=x........\n" PRTstring
    blue 1 draw_plot

    "Drawing 2-term (green) series....\n" PRTstring
    green 2 draw_plot

    "Drawing 3-term (red) series......\n" PRTstring
    red 3 draw_plot

    "Drawing 4-term (cyan) series.....\n" PRTstring
    cyan 4 draw_plot

    "Drawing 5-term (yellow) series...\n" PRTstring
    yellow 5 draw_plot

    "Drawing 6-term (magenta) series..\n" PRTstring
    orange 6 draw_plot

    "Drawing 7-term (lightBlue) series\n" PRTstring
    lightBlue 7 draw_plot

    "Drawing 8-term (lightRed) series.\n" PRTstring
    lightRed 8 draw_plot

    "Drawing 9-term (white) series....\n" PRTstring
    white 9 draw_plot

    "All done! in " PRTstring
}

0 TIME.start
main
0 TIME.read TIME.as_string 13 PRTchar