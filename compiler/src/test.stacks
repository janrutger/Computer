# for a new program


USE std_stern_io
USE std_time
USE std_string

# Some colors
CONST purple 4
CONST green 5
CONST blue 6
CONST yellow 7
CONST orange 8

CONST WIDTH  80
CONST HEIGHT 60
VALUE current_x 0
VALUE current_y 0
VALUE current_color 1
CONST solid_block 203
CONST star 42


# First item : tile width
# Second item: tile height
# spritedata Width x Height, where value 0 is the transparent sprite
#   
LIST tile_data0 10      ; First tile data
ASM {
   # % $tile_data 1 4 56 50 0 54  ; where 0 is an transparant sprite
    % $tile_data0 2 4  129 130  91 93  91 93  203 203
}
&tile_data0 AS tile   ; the pointer to the tile 


LIST tile_data1 11      ; Second tile data
ASM {
    % $tile_data1 3 3 203 203 203 203 0 203 203 203 203
}
&tile_data1 AS tile1

LIST tile_data2 6      ; Third tile data
ASM {
    % $tile_data2 2 2 42 42 42 42 
}
&tile_data2 AS tile1

CONST up    56 ; key '8'
CONST down  50 ; key '2'
CONST left  52 ; key '4'
CONST right 54 ; key '6'
CONST exit  32 ; spacebar

# VALUE tile_x 40
# VALUE tile_y 30
# VALUE old_tile_x 40
# VALUE old_tile_y 30
# VALUE tile_is_moved 0


VALUE background 0  ; black
VALUE foreground 5  ; green

# to keep track of mulitple tiles we need some bookkeeping
# We need to keep track of 7 items of tile information
CONST TILE_X 0
CONST TILE_Y 1
CONST TILE_OLD_X 2
CONST TILE_OLD_Y 3
CONST TILE_IS_MOVED 4
CONST TILE_COLOR 5
CONST TILE_DATA 6

CONST NO_X 0
CONST NO_Y 200

CONST TILE_OBJ_SIZE 7     # The total size of one tile object structure

# create an structure to keep the books
# each Tile need 7 items
# 2 Tiles = 2x7
LIST TILE_INFO 14   ; an LIST size must be one integer, cannotbe calculated
&TILE_INFO AS tile_info     # Pointer to Tile Information structure

VALUE KEYBOARD_TILE 1       # index of the Tile on keyboard controll

# Initializes a single tile object in the TILE_INFO list.
# Expects on stack: tile_id, start_x, start_y, data_ptr, color
DEF init_single_tile {
    AS color_new
    AS data_ptr_new
    AS start_y_new
    AS start_x_new
    AS tile_id

    0 AS item_pointer

    # Calculate the base address for this tile object
    tile_info tile_id TILE_OBJ_SIZE * + AS tile_base_prt

    # Set values using the base pointer and field offsets
    tile_base_prt TILE_X + AS item_pointer           # Current X.Y
    start_x_new AS *item_pointer
    tile_base_prt TILE_Y + AS item_pointer
    start_y_new AS *item_pointer

    tile_base_prt TILE_OLD_X + AS item_pointer       # Old X.Y
    start_x_new AS *item_pointer
    tile_base_prt TILE_OLD_Y + AS item_pointer
    start_y_new AS *item_pointer

    tile_base_prt TILE_IS_MOVED + AS item_pointer    # Moving flag
    0 AS *item_pointer

    tile_base_prt TILE_COLOR + AS item_pointer       # Color flag
    color_new AS *item_pointer

    tile_base_prt TILE_DATA + AS item_pointer        # Data pointer to draw
    data_ptr_new AS *item_pointer
}

# Draws a rectangular shape of sprites.
# Expects on stack: start_x, start_y, width, height, sprite_id
DEF clear_rect {
    AS sprite_id
    AS shape_h
    AS shape_w
    AS start_y
    AS start_x

    0 AS rect_y
    start_y AS rect_y
    WHILE rect_y start_y shape_h + < DO
        rect_y IO 2 Y
        0 AS rect_x
        start_x AS rect_x
        WHILE rect_x start_x shape_w + < DO
            rect_x IO 2 X
            sprite_id IO 2 DRAW
            rect_x 1 + AS rect_x
        DONE
        rect_y 1 + AS rect_y
    DONE
}

# Draws a tile defined in a LIST.
# Expects on stack: start_x, start_y, tile_ptr
DEF draw_tile_from_data {
    AS tile_ptr
    AS start_y
    AS start_x

    0 AS temp_ptr # Temporary pointer for calculations

    # Read width and height from the tile data
    *tile_ptr AS tile_w
    tile_ptr 1 + AS temp_ptr
    *temp_ptr AS tile_h

    0 AS loop_y
    WHILE loop_y tile_h < DO
        0 AS loop_x
        WHILE loop_x tile_w < DO
            # Calculate index: data_offset = 2 + (y * width) + x
            tile_ptr loop_y tile_w * loop_x + 2 + + AS temp_ptr
            *temp_ptr AS sprite_id

            sprite_id IF # Draw only if sprite_id is not 0 (transparent)
                start_x loop_x + IO 2 X
                start_y loop_y + IO 2 Y
                sprite_id IO 2 DRAW
            END
            loop_x 1 + AS loop_x
        DONE
        loop_y 1 + AS loop_y
    DONE
}

# Checks if a tile at a potential new position collides with any other tile.
# Expects on stack: potential_x, potential_y, moving_tile_id
# Returns: 1 if collision detected, 0 otherwise.
DEF check_collision {
    AS moving_tile_id
    AS pot_y  # potential y
    AS pot_x  # potential x

    0 AS collision_found # Return value flag, default to 0 (no collision)
    0 AS temp_ptr
    # Get dimensions of the moving tile
    tile_info moving_tile_id TILE_OBJ_SIZE * + TILE_DATA + AS temp_ptr
    *temp_ptr AS moving_data_ptr
    *moving_data_ptr AS pot_w # potential width
    moving_data_ptr 1 + AS temp_ptr
    *temp_ptr AS pot_h # potential height

    0 AS i
    WHILE i 2 < DO # Loop through all tiles to check against
        i moving_tile_id != IF # Don't check a tile against itself
            # Get properties of the other tile
            tile_info i TILE_OBJ_SIZE * + AS other_tile_ptr
            other_tile_ptr TILE_X + AS temp_ptr
            *temp_ptr AS other_x
            other_tile_ptr TILE_Y + AS temp_ptr
            *temp_ptr AS other_y
            other_tile_ptr TILE_DATA + AS temp_ptr
            *temp_ptr AS other_data_ptr
            *other_data_ptr AS other_w
            other_data_ptr 1 + AS temp_ptr
            *temp_ptr AS other_h

            # AABB Collision Check Logic:
            # A collision does NOT exist if any of these are true:
            # 1. Moving box is entirely to the left of the other box.
            pot_x pot_w + 1 - other_x < IF GOTO no_collision_found END
            # 2. Moving box is entirely to the right of the other box.
            other_x other_w + 1 - pot_x < IF GOTO no_collision_found END
            # 3. Moving box is entirely above the other box.
            pot_y pot_h + 1 - other_y < IF GOTO no_collision_found END
            # 4. Moving box is entirely below the other box.
            other_y other_h + 1 - pot_y < IF GOTO no_collision_found END

            # If none of the above are true, the boxes are overlapping.
            1 AS collision_found
            GOTO collision_check_end # Exit loop and function

            :no_collision_found
        END
        i 1 + AS i
    DONE

    :collision_check_end
    collision_found # Place the result on the stack to be returned
}

# Handles keyboard input to move the active tile
DEF handle_input {
    KEYpressed IF
        AS KEYvalue

        tile_info KEYBOARD_TILE TILE_OBJ_SIZE * + AS active_tile_ptr
        0 AS temp_ptr
        active_tile_ptr TILE_X + AS temp_ptr
        *temp_ptr AS current_x
        active_tile_ptr TILE_Y + AS temp_ptr
        *temp_ptr AS current_y

        KEYvalue up    == IF current_y 1 - AS current_y END
        KEYvalue down  == IF current_y 1 + AS current_y END
        KEYvalue left  == IF current_x 1 - AS current_x END
        KEYvalue right == IF current_x 1 + AS current_x END
        KEYvalue exit  == IF 0 AS running END

        # Check for collision at the potential new position
        current_x current_y KEYBOARD_TILE check_collision
        IF ELSE # If no collision (check_collision returned 0)
            # Commit the move
            active_tile_ptr TILE_X + AS temp_ptr
            current_x AS *temp_ptr
            active_tile_ptr TILE_Y + AS temp_ptr
            current_y AS *temp_ptr
            active_tile_ptr TILE_IS_MOVED + AS temp_ptr
            1 AS *temp_ptr
        END
    END
}

# Redraws all tiles that have moved since the last frame
DEF redraw_all_moved_tiles {
    0 AS i
    0 AS any_tile_moved
    0 AS temp_ptr

    # --- Erase all moved tiles first ---
    WHILE i 2 < DO # Loop for 2 tiles
        tile_info i TILE_OBJ_SIZE * + AS tile_obj_ptr
        tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
        *temp_ptr AS is_moved

        is_moved IF
            1 AS any_tile_moved
            background IO 2 COLOR
            
            tile_obj_ptr TILE_DATA + AS temp_ptr
            *temp_ptr AS data_ptr
            
            *data_ptr AS tile_w
            data_ptr 1 + AS temp_ptr
            *temp_ptr AS tile_h

            tile_obj_ptr TILE_OLD_X + AS temp_ptr
            *temp_ptr AS old_x
            tile_obj_ptr TILE_OLD_Y + AS temp_ptr 
            *temp_ptr AS old_y
            old_x old_y tile_w tile_h solid_block clear_rect
        END
        i 1 + AS i
    DONE

    # --- Draw all moved tiles in their new positions ---
    0 AS i
    WHILE i 2 < DO # Loop for 2 tiles
        tile_info i TILE_OBJ_SIZE * + AS tile_obj_ptr
        tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
        *temp_ptr AS is_moved

        is_moved IF
            tile_obj_ptr TILE_COLOR + AS temp_ptr
            *temp_ptr IO 2 COLOR
            
            tile_obj_ptr TILE_DATA + AS temp_ptr
            *temp_ptr AS data_ptr
            
            tile_obj_ptr TILE_X + AS temp_ptr
            *temp_ptr AS new_x
            tile_obj_ptr TILE_Y + AS temp_ptr
            *temp_ptr AS new_y
            new_x new_y data_ptr draw_tile_from_data

            # Update old coords and reset flag
            tile_obj_ptr TILE_OLD_X + AS temp_ptr
            new_x AS *temp_ptr
            tile_obj_ptr TILE_OLD_Y + AS temp_ptr
            new_y AS *temp_ptr
            tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
            0 AS *temp_ptr
        END
        i 1 + AS i
    DONE

    # --- Flip the buffer once if anything was redrawn ---
    any_tile_moved IF
        IO 2 FLIP
    END
}

# Draws a single tile specified by its ID. Does NOT flip the buffer.
# Expects on stack: tile_id
DEF draw_tile_by_id {
    AS tile_id
    0 AS temp_ptr

    # Get the base pointer for the specified tile object
    tile_info tile_id TILE_OBJ_SIZE * + AS tile_obj_ptr

    # Get color, data pointer, and coordinates, then draw.
    tile_obj_ptr TILE_COLOR + AS temp_ptr
    *temp_ptr IO 2 COLOR
    tile_obj_ptr TILE_DATA + AS temp_ptr
    *temp_ptr AS data_ptr
    tile_obj_ptr TILE_X + AS temp_ptr
    *temp_ptr AS current_x
    tile_obj_ptr TILE_Y + AS temp_ptr
    *temp_ptr AS current_y
    
    current_x current_y data_ptr draw_tile_from_data
}

# "Deletes" a tile by moving it off-screen.
# This function marks the tile as moved and sets its coordinates
# to a position outside the visible area.
# Expects on stack: tile_id
DEF delete_tile {
    AS tile_id
    0 AS temp_ptr

    # Get the base pointer for the specified tile object
    tile_info tile_id TILE_OBJ_SIZE * + AS tile_obj_ptr

    # Set the new coordinates to be off-screen
    tile_obj_ptr TILE_X + AS temp_ptr
    NO_X AS *temp_ptr
    tile_obj_ptr TILE_Y + AS temp_ptr
    NO_Y AS *temp_ptr # Move far below the screen (HEIGHT is 60)

    # Mark the tile as moved so it gets erased from its old position
    tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
    1 AS *temp_ptr
}

# Draws all tiles at their current position, regardless of moved status.
# Useful for the initial screen draw.
DEF draw_all_tiles {
    0 AS i
    WHILE i 2 < DO # Loop for 2 tiles
        i draw_tile_by_id
        i 1 + AS i
    DONE

    IO 2 FLIP # Flip the buffer to make the initial drawing visible
}

DEF refresh_tiles {
    IO 2 FLIP
}

# Main function
DEF main {
    IO 2 ONLINE
    IO 2 NEW
    3 IO 2 MODE     # doublebuffer sprite mode

    # Initialize our two tiles, expects argumnt on the stack
    # [ tile_id, start_x, start_y, data_ptr, color ] 
    0 40 30 tile  foreground init_single_tile    # Tile 0
    1 20 50 tile1 purple     init_single_tile    # Tile 1

    # Perform the initial draw of all tiles
    # draw_all_tiles
    0 draw_tile_by_id
    1 draw_tile_by_id
    refresh_tiles
    
    # Example of deleting tile 0
    # 0 delete_tile


    1 AS running
    WHILE running DO
        handle_input
        redraw_all_moved_tiles
    DONE
}





main