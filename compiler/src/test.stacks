# for a new program


USE std_stern_io
USE std_time
USE std_string

# Some colors
CONST purple 4
CONST green 5
CONST blue 6
CONST yellow 7
CONST orange 8

CONST WIDTH  80
CONST HEIGHT 60
VALUE current_x 0
VALUE current_y 0
VALUE current_color 1
CONST solid_block 203
CONST star 42

LIST tile_data 10 ; NOTE: Duplicate LIST TILE removed
ASM {
   # % $tile_data 1 4 56 50 0 54  ; where 0 is an transparant sprite
    % $tile_data 2 4  0 94  91 93  91 93  203 203
}
&tile_data AS tile   ; the pointer to the tile ; NOTE: Duplicate &TILE AS tile removed

CONST up    56 ; key '8'
CONST down  50 ; key '2'
CONST left  52 ; key '4'
CONST right 54 ; key '6'
CONST exit  32 ; spacebar

VALUE tile_x 40
VALUE tile_y 30
VALUE old_tile_x 40
VALUE old_tile_y 30
VALUE tile_is_moved 0


VALUE background 0  ; black
VALUE foreground 5  ; green

# Takes the color as argument
DEF draw_screen {
    IO 2 COLOR
    0 AS current_y
    WHILE current_y HEIGHT < DO
        current_y IO 2 Y
        0 AS current_x
        WHILE current_x WIDTH < DO
            current_x IO 2 X
            solid_block IO 2 DRAW
            current_x 1 + AS current_x
        DONE

        current_y 1 + AS current_y
    DONE
    IO 2 FLIP
}

# Draws a rectangular shape of sprites.
# Expects on stack: start_x, start_y, width, height, sprite_id
DEF clear_rect {
    AS sprite_id
    AS shape_h
    AS shape_w
    AS start_y
    AS start_x

    0 AS rect_y
    start_y AS rect_y
    WHILE rect_y start_y shape_h + < DO
        rect_y IO 2 Y
        0 AS rect_x
        start_x AS rect_x
        WHILE rect_x start_x shape_w + < DO
            rect_x IO 2 X
            sprite_id IO 2 DRAW
            rect_x 1 + AS rect_x
        DONE
        rect_y 1 + AS rect_y
    DONE
}

# Draws a tile defined in a LIST.
# Expects on stack: start_x, start_y, tile_ptr
DEF draw_tile_from_data {
    AS tile_ptr
    AS start_y
    AS start_x

    0 AS temp_ptr # Temporary pointer for calculations

    # Read width and height from the tile data
    *tile_ptr AS tile_w
    tile_ptr 1 + AS temp_ptr
    *temp_ptr AS tile_h

    0 AS loop_y
    WHILE loop_y tile_h < DO
        0 AS loop_x
        WHILE loop_x tile_w < DO
            # Calculate index: data_offset = 2 + (y * width) + x
            tile_ptr loop_y tile_w * loop_x + 2 + + AS temp_ptr
            *temp_ptr AS sprite_id

            sprite_id IF # Draw only if sprite_id is not 0 (transparent)
                start_x loop_x + IO 2 X
                start_y loop_y + IO 2 Y
                sprite_id IO 2 DRAW
            END
            loop_x 1 + AS loop_x
        DONE
        loop_y 1 + AS loop_y
    DONE
}

# draw/move 1x1 sprite Tile
DEF draw_tile {
   
    KEYpressed IF
        AS KEYvalue
        "Key pressed " PRTstring KEYvalue PRINT

        KEYvalue up == IF
            tile_y 1 - AS tile_y
            1 AS tile_is_moved
        END
        KEYvalue down == IF
            tile_y 1 + AS tile_y
            1 AS tile_is_moved
        END
        KEYvalue left == IF
            tile_x 1 - AS tile_x
            1 AS tile_is_moved
        END
        KEYvalue right == IF
            tile_x 1 +  AS tile_x
            1 AS tile_is_moved
        END
        KEYvalue exit == IF
            0 AS running
        END
    
    END


    tile_is_moved IF
        ; A move happened, so redraw the tile.

        ; 1. Erase the shape at its old position
        background IO 2 COLOR
        0 AS temp_ptr
        *tile AS tile_w
        tile 1 + AS temp_ptr
        *temp_ptr AS tile_h
        old_tile_x old_tile_y tile_w tile_h solid_block clear_rect

        ; 2. Draw the shape at its new position
        foreground IO 2 COLOR # Set color for drawing the new tile
        tile_x tile_y tile draw_tile_from_data

        ; 3. Flip the buffer to make changes visible
        IO 2 FLIP
        
        ; 4. Update old coordinates and reset the moved flag
        tile_x AS old_tile_x
        tile_y AS old_tile_y
        0 AS tile_is_moved
    END
}





# Main function
DEF main {
    IO 2 ONLINE
    IO 2 NEW
    3 IO 2 MODE     # doublebuffer sprite mode

    # 1 TIME.start
    #     background draw_screen ; take 15 seconds to draw the whole screen
    # 1 TIME.read TIME.as_string return PRTchar

    1 AS running
    WHILE running DO
        draw_tile
    DONE
}





main