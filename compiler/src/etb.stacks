##
# Escape The Box, the first game for the Stern-XT
# Using game_lib the gameengine library of the Stacks language
##

# 0) Include and helpers routines
INCLUDE game_lib


# 1) define the Tile data
LIST player_data 3              ; Define player
ASM {
    % $player_data 1 1 200      ; Pacman sprite
}
&player_data AS Player

LIST coin_data 3                ; Define coin
ASM {
    % $coin_data 1 1 42         ; Start (*) sprite
}
&coin_data AS Coin

LIST special_data  3            ; define Monster
ASM {
    % $special_data  1 1 200    ; 1x1 Monster (pacman sprite for now)
}
&special_data AS Special

LIST roof_data 29               ; Define roof (27 wide)
ASM {
    % $roof_data 27 1 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201
}
&roof_data AS Roof

LIST short_wall_data 12         ; Define short wall (10 high)
ASM {
    % $short_wall_data 1 10 201 201 201 201 201 201 201 201 201 201
}
&short_wall_data AS ShortWall

LIST long_wall_data 17          ; Define long wall (15 high)
ASM {
    % $long_wall_data 1 15 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201
}
&long_wall_data AS LongWall



CONST PLAYER      0
CONST COIN        1
CONST ROOF        2
CONST SHORT_LEFT  3
CONST LONG_LEFT   4
CONST SHORT_RIGHT 5
CONST LONG_RIGHT  6
CONST SPECIAL     7

CONST COST_ROOF   5
CONST COST_SHORT  2
CONST COST_LONG   3

VALUE interacted_id 0

# 2) Game setup & Patrol setup
# initialize game engine
init_game_lib


# --- Game Developer's variables for a patrol sequence ---
# 0    AS timer0           # The state variable for our patrol timer
# 750  AS timer0_time      # Wait N frames between moves
# 0    AS timer0_state     # 0 means 'even', 1 means means 'odd' (False/True)
350    AS t_coin            # The coin tile timer
800    AS t_coin_time       # Duration of the timer

100    AS t_special         # the Special tile timer
100    AS t_special_time    # Duration of the timer

0      AS t_monster_cooldown    # Cooldown timer/counter




# --- Create the initial Tiles ---
# [ tile_id, start_x, start_y, data_ptr, color, reaction ]
PLAYER      39 46 Player    green    REACT_BLOCK     GAME.init_tile
COIN        30 40 Coin      yellow   REACT_OVERWRITE GAME.init_tile
ROOF        26 34 Roof      orange   REACT_BLOCK     GAME.init_tile
SHORT_LEFT  26 35 ShortWall orange   REACT_BLOCK     GAME.init_tile
LONG_LEFT   26 45 LongWall  orange   REACT_BLOCK     GAME.init_tile
SHORT_RIGHT 52 50 ShortWall orange   REACT_BLOCK     GAME.init_tile
LONG_RIGHT  52 35 LongWall  orange   REACT_BLOCK     GAME.init_tile
SPECIAL     45 50 Special   darkGray REACT_BLOCK     GAME.init_tile

8 AS active_tile_count      # We have initialized 8 Tiles
PLAYER AS KEYBOARD_TILE     # Set the player tile
#GAME.refresh                # Update the screen

# more game setup here
DEF rnd_xy1 {                # Helper for generating random coordinates
    RND 25 % 27 +            # for an 1x1 tile
    RND 24 % 35 +
}

DEF rnd_xy2 {                # Helper for generating random coordinates
    RND 24 % 27 +            # for an 2x2 tile
    RND 23 % 35 +
}

VALUE _score_dirty 1
DEF print_score {
    #red IO 2 COLOR
    26 IO 2 X 
    32 IO 2 Y 

    AS _score
    
    background IO 2 COLOR
    solid_block IO 2 DRAW
    red IO 2 COLOR
    _score 0 < IF
        45 IO 2 DRAW
        _score _negate AS _score        # _negate is the game_lib negate function
    ELSE
        43 IO 2 DRAW
    END

    
    _score 100 //      48 + AS _hunreds
    _score 100 % 10 // 48 + AS _tens
    _score 10 %        48 + AS _ones

    27 IO 2 X 
        background IO 2 COLOR
        solid_block IO 2 DRAW
        red IO 2 COLOR
        _hunreds   IO 2 DRAW
    28 IO 2 X 
        background IO 2 COLOR
        solid_block IO 2 DRAW
        red IO 2 COLOR
        _tens      IO 2 DRAW
    29 IO 2 X 
        background IO 2 COLOR
        solid_block IO 2 DRAW
        red IO 2 COLOR
        _ones      IO 2 DRAW

    0 AS _score_dirty
}

# Helper function to update wall colors based on player score
DEF update_wall_visuals {
    # This function checks each wall and updates its color if the player can afford it.
    # It's optimized to only trigger a redraw if the color actually changes.

    # ( tile_id, cost, data_ptr -- )
    DEF check_and_update_color {
        AS _data_ptr
        AS _cost
        AS _tile_id

        # Get current color
        tile_info _tile_id TILE_OBJ_SIZE * + TILE_COLOR + AS temp_ptr
        *temp_ptr AS _current_color

        # Determine target color
        score _cost < IF orange ELSE lightGreen END
        AS _target_color

        # Only update if the color is different to prevent needless redraws
        _current_color _target_color != IF
            # Correct argument order: new_reaction, new_color, new_data_ptr, tile_id
            REACT_BLOCK _target_color _data_ptr _tile_id GAME.update_tile_props
        END
    }

    ROOF        COST_ROOF   Roof      check_and_update_color
    SHORT_LEFT  COST_SHORT  ShortWall check_and_update_color
    LONG_LEFT   COST_LONG   LongWall  check_and_update_color
    SHORT_RIGHT COST_SHORT  ShortWall check_and_update_color
    LONG_RIGHT  COST_LONG   LongWall  check_and_update_color
}


DEF check_the_walls {
    0 AS _costs                 # reset the costs
    interacted_id ROOF == IF
        _costs COST_ROOF + AS _costs    # Update _costs
        ROOF                            # Place ROOF on the stack
    ELSE interacted_id SHORT_LEFT == IF
        _costs COST_SHORT + AS _costs  # Update _costs
        SHORT_LEFT                     # Place SHORT_LEFT on the stack
    ELSE interacted_id LONG_LEFT == IF
        _costs COST_LONG + AS _costs   # Update _costs
        LONG_LEFT                      # Place LONG_LEFT on the stack
    ELSE interacted_id SHORT_RIGHT == IF
        _costs COST_SHORT + AS _costs  # Update _costs
        SHORT_RIGHT                    # Place SHORT_RIGHT on the stack
    ELSE interacted_id LONG_RIGHT == IF
        _costs COST_LONG + AS _costs   # Update _costs
        LONG_RIGHT                     # Place LONG_RIGHT on the stack
    END END END END END
    _costs IF
        score _costs < IF              # No credits
            score _costs - AS score
            1 AS _score_dirty
            DROP                       # Drop the tile ID
        ELSE
            score _costs + AS score
            1 AS _score_dirty
            delete_tile                # Delete the tile
        END
    END
}

# 3) Game loop
1 AS running
WHILE running DO
    # --- Update Visuals ---
    # Change wall colors to show if they are breakable
    update_wall_visuals

    # --- Coin Movement ---
    &t_coin t_coin_time is_timer_ready IF
        rnd_xy1 COIN tile_move
    END

    t_monster_cooldown IF
        t_monster_cooldown 1 - AS t_monster_cooldown
    ELSE
    # --- Hunter Monster AI ---
        &t_special t_special_time is_timer_ready IF
            # Get Player's coords
            tile_info PLAYER TILE_OBJ_SIZE * TILE_X + + AS temp_ptr
            *temp_ptr AS player_x
            tile_info PLAYER TILE_OBJ_SIZE * TILE_Y + + AS temp_ptr
            *temp_ptr AS player_y

            # Get Monster's coords
            tile_info SPECIAL TILE_OBJ_SIZE * TILE_X + + AS temp_ptr
            *temp_ptr AS monster_x
            tile_info SPECIAL TILE_OBJ_SIZE * TILE_Y + + AS temp_ptr
            *temp_ptr AS monster_y

            # Calculate one step closer to the player
            player_x monster_x > IF monster_x 1 + AS monster_x END
            player_x monster_x < IF monster_x 1 - AS monster_x END
            player_y monster_y > IF monster_y 1 + AS monster_y END
            player_y monster_y < IF monster_y 1 - AS monster_y END

            # Move the monster

            # Move the monster blindly.
            monster_x monster_y SPECIAL tile_move
            # Check for overlap other tiles
            SPECIAL GAME.check_overlap 
            PLAYER == IF
                REACT_BLOCK red Special SPECIAL GAME.update_tile_props
                score 0 > IF
                    score 2 // AS score 
                    score print_score
                END
                t_special_time 90 > IF
                    t_special_time 1 - AS t_special_time
                END
                100 AS t_monster_cooldown
            ELSE
                REACT_BLOCK lightGray Special SPECIAL GAME.update_tile_props
            END
        END
    END

    



    # Run the gameengine logic
    GAME.handle_input          # Senses: Get a raw physics report.
    GAME.process_events        # Mechanics: Execute mechanics and get a factual report.

    # Run the gamelogic: Apply game rules based on the factual report.
    AS interacted_id
    AS game_event
    game_event GAME_EVENT_OVERWRITE_ACTION == IF
        interacted_id COIN == IF
            score 1 + AS score
            1 AS _score_dirty
            0 AS t_coin # Reset coin timer to force respawn
            # Respawn the monster to a new random location
            rnd_xy1 SPECIAL tile_move
        END
    ELSE game_event GAME_EVENT_BLOCK_ACTION == IF
        # At this point, interacted_id is the PLAYER (keyboard) tile
        
        check_the_walls     # routine to check the walls and set color

        interacted_id SPECIAL == IF
            REACT_BLOCK lightRed Special SPECIAL GAME.update_tile_props
            200 AS t_monster_cooldown
        END
            
    END END

    _score_dirty IF
        score print_score
        GAME.refresh
    END
    GAME.redraw_all_moved_tiles # Update screen for moving tiles

DONE
