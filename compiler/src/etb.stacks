##
# Escape The Box, the first game for the Stern-XT
# Using game_lib the gameengine library of the Stacks language
##

# 0) Include and helpers routines
INCLUDE game_lib


# 1) define the Tile data
LIST player_data 3              ; Define player
ASM {
    % $player_data 1 1 200      ; Pacman sprite
}
&player_data AS Player

LIST coin_data 3                ; Define coin
ASM {
    % $coin_data 1 1 42         ; Star (*) sprite
}
&coin_data AS Coin

LIST special_data  3            ; define Monster
ASM {
    % $special_data  1 1 204    ; 1x1 Monster sprite
}
&special_data AS Special

LIST roof_data 29               ; Define roof (27 wide)
ASM {
    % $roof_data 27 1 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201
}
&roof_data AS Roof

LIST short_wall_data 12         ; Define short wall (10 high)
ASM {
    % $short_wall_data 1 10 201 201 201 201 201 201 201 201 201 201
}
&short_wall_data AS ShortWall

LIST long_wall_data 17          ; Define long wall (15 high)
ASM {
    % $long_wall_data 1 15 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201
}
&long_wall_data AS LongWall

LIST game_over_data 11 ; 8 chars + width/height
ASM {
    % $game_over_data 9 1 71 65 77 69 32 79 86 69 82 ; "GAME OVER"
}
&game_over_data AS GameOverSprite

LIST you_won_data 9 ; 7 chars + width/height
ASM {
    % $you_won_data 7 1 89 79 85 32 87 79 78 ; "YOU WON"
}
&you_won_data AS YouWonSprite

LIST you_lost_data 10 ; 8 chars + width/height
ASM {
    % $you_lost_data 8 1 89 79 85 32 76 79 83 84 ; "YOU LOST"
}
&you_lost_data AS YouLostSprite


CONST PLAYER      0
CONST COIN        1
CONST ROOF        2
CONST SHORT_LEFT  3
CONST LONG_LEFT   4
CONST SHORT_RIGHT 5
CONST LONG_RIGHT  6
CONST SPECIAL     7

CONST COST_SHORT_LEFT  2
CONST COST_LONG_LEFT   3
CONST COST_SHORT_RIGHT 5
CONST COST_LONG_RIGHT  8
CONST COST_ROOF        10

VALUE interacted_id 0
VALUE score 0
VALUE coins_remaining 20
VALUE player_won 0

# 2) Game setup & Patrol setup
# initialize game engine
GAME.init_game_lib


# --- Game Developer's variables for a patrol sequence ---
# 0    AS timer0           # The state variable for our patrol timer
# 750  AS timer0_time      # Wait N frames between moves
# 0    AS timer0_state     # 0 means 'even', 1 means means 'odd' (False/True)
350    AS t_coin            # The coin tile timer
700    AS t_coin_time       # Duration of the timer

100    AS t_special         # the Special tile timer
100    AS t_special_time    # Duration of the timer

0      AS t_monster_cooldown    # Cooldown timer/counter




# --- Create the initial Tiles ---
# [ tile_id, start_x, start_y, data_ptr, color, reaction ]
PLAYER      39 46 Player    green    REACT_BLOCK     GAME.init_tile
COIN        30 40 Coin      yellow   REACT_OVERWRITE GAME.init_tile
ROOF        26 34 Roof      orange   REACT_BLOCK     GAME.init_tile
SHORT_LEFT  26 35 ShortWall orange   REACT_BLOCK     GAME.init_tile
LONG_LEFT   26 45 LongWall  orange   REACT_BLOCK     GAME.init_tile
SHORT_RIGHT 52 50 ShortWall orange   REACT_BLOCK     GAME.init_tile
LONG_RIGHT  52 35 LongWall  orange   REACT_BLOCK     GAME.init_tile
SPECIAL     45 50 Special   darkGray REACT_BLOCK     GAME.init_tile

8 AS active_tile_count      # We have initialized 8 Tiles
PLAYER AS KEYBOARD_TILE     # Set the player tile
#GAME.refresh                # Update the screen

# more game setup here
DEF rnd_xy1 {                # Helper for generating random coordinates
    RND 25 % 27 +            # for an 1x1 tile
    RND 24 % 35 +
}

DEF rnd_xy2 {                # Helper for generating random coordinates
    RND 24 % 27 +            # for an 2x2 tile
    RND 23 % 35 +
}

VALUE _score_dirty 1
DEF print_score {
    #red IO 2 COLOR
    26 IO 2 X 
    32 IO 2 Y 

    AS _score
    
    background IO 2 COLOR
    solid_block IO 2 DRAW
    red IO 2 COLOR
    _score 0 < IF
        45 IO 2 DRAW
        _score _negate AS _score        # _negate is the game_lib negate function
    ELSE
        43 IO 2 DRAW
    END

    
    _score 100 //      48 + AS _hunreds
    _score 100 % 10 // 48 + AS _tens
    _score 10 %        48 + AS _ones

    27 IO 2 X 
        background  IO 2 COLOR
        solid_block IO 2 DRAW
        red IO 2 COLOR
        _hunreds   IO 2 DRAW
    28 IO 2 X 
        background  IO 2 COLOR
        solid_block IO 2 DRAW
        red IO 2 COLOR
        _tens      IO 2 DRAW
    29 IO 2 X 
        background  IO 2 COLOR
        solid_block IO 2 DRAW
        red IO 2 COLOR
        _ones      IO 2 DRAW

    0 AS _score_dirty
}

VALUE _coins_dirty 1
DEF print_coins {
    #red IO 2 COLOR
    49 IO 2 X 
    32 IO 2 Y 

    AS _coins
    
    background IO 2 COLOR
    solid_block IO 2 DRAW
    yellow IO 2 COLOR
    42 IO 2 DRAW # Draw a star for the coin symbol

    _coins 100 //      48 + AS _hunreds
    _coins 100 % 10 // 48 + AS _tens
    _coins 10 %        48 + AS _ones

    50 IO 2 X 
        background  IO 2 COLOR
        solid_block IO 2 DRAW
        yellow IO 2 COLOR
        _hunreds   IO 2 DRAW
    51 IO 2 X 
        background  IO 2 COLOR
        solid_block IO 2 DRAW
        yellow IO 2 COLOR
        _tens      IO 2 DRAW
    52 IO 2 X 
        background  IO 2 COLOR
        solid_block IO 2 DRAW
        yellow IO 2 COLOR
        _ones      IO 2 DRAW

    0 AS _coins_dirty
}

# Helper function to update wall colors based on player score
DEF update_wall_visuals {
    # This function checks each wall and updates its color if the player can afford it.
    # It's optimized to only trigger a redraw if the color actually changes.

    # ( tile_id, cost, data_ptr -- )
    DEF check_and_update_color {
        AS _data_ptr
        AS _cost
        AS _tile_id

        # Get current color
        _tile_id GAME.get_color AS _current_color

        # Determine target color
        score _cost < IF orange ELSE lightGreen END
        AS _target_color

        # Only update if the color is different to prevent needless redraws
        _current_color _target_color != IF
            # Correct argument order: new_reaction, new_color, new_data_ptr, tile_id
            REACT_BLOCK _target_color _data_ptr _tile_id GAME.update_tile_props
        END
    }

    ROOF        COST_ROOF        Roof      check_and_update_color
    SHORT_LEFT  COST_SHORT_LEFT  ShortWall check_and_update_color
    LONG_LEFT   COST_LONG_LEFT   LongWall  check_and_update_color
    SHORT_RIGHT COST_SHORT_RIGHT ShortWall check_and_update_color
    LONG_RIGHT  COST_LONG_RIGHT  LongWall  check_and_update_color
}

# Helper function to check if a specific wall tile is currently green.
# ( tile_id -- boolean )
DEF _is_wall_is_green {
    #AS _tile_id
    # Get current color of the tile using the new getter
    #_tile_id GAME.get_color lightGreen ==
    GAME.get_color lightGreen ==
}


# Checks if all wall segments are currently green.
# ( -- boolean )
DEF are_all_walls_green {
    # We will check each wall. If any wall is NOT green, we immediately
    # return 0 (false). If we get through all checks, we return 1 (true).

    ROOF        _is_wall_is_green 0 == IF 0 GOTO all_walls_are_not_green END
    SHORT_LEFT  _is_wall_is_green 0 == IF 0 GOTO all_walls_are_not_green END
    LONG_LEFT   _is_wall_is_green 0 == IF 0 GOTO all_walls_are_not_green END
    SHORT_RIGHT _is_wall_is_green 0 == IF 0 GOTO all_walls_are_not_green END
    LONG_RIGHT  _is_wall_is_green 0 == IF 0 GOTO all_walls_are_not_green END

    # If we made it here, all walls must be green.
    1 GOTO check_walls_done

    :all_walls_are_not_green
    0
    :check_walls_done
    # The return value (1 or 0) is now on the stack.
}

DEF check_the_walls {
    0 AS _wall_cost # Initialize to 0. This will hold the cost of the wall the player collided with.

    # Determine the cost of the specific wall that was interacted with.
    # The 'interacted_id' is the ID of the tile the player (KEYBOARD_TILE) collided with.
    interacted_id ROOF == IF
        COST_ROOF AS _wall_cost
    ELSE interacted_id SHORT_LEFT == IF
        COST_SHORT_LEFT AS _wall_cost
    ELSE interacted_id LONG_LEFT == IF
        COST_LONG_LEFT AS _wall_cost
    ELSE interacted_id SHORT_RIGHT == IF
        COST_SHORT_RIGHT AS _wall_cost
    ELSE interacted_id LONG_RIGHT == IF
        COST_LONG_RIGHT AS _wall_cost
    END END END END END

    _wall_cost 0 != IF # Check if the interacted_id was actually a wall (i.e., _wall_cost is non-zero)
        are_all_walls_green IF
            # --- SAFE BREAKOUT (WIN CONDITION) ---
            # All walls are green, and the player collided with one.
            1 AS player_won                 # Set the win flag
            interacted_id GAME.delete_tile  # Destroy the wall
            score _wall_cost + AS score     # The escape has a cost!
            1 AS _score_dirty
            0 AS GAME.running               # Set 'running' to 0 to end the game loop
            # The current 'score' is the final score, no modification needed here.
        ELSE
            # --- FAILED ATTEMPT (PENALTY) ---
            # Not all walls are green, so this is a penalty.
            score _wall_cost - AS score # Subtract the full cost of the wall
            1 AS _score_dirty
            # The wall is NOT deleted; it remains as a barrier.
        END
    END
}

# 3) Game loop
1 AS GAME.running
WHILE GAME.running DO
    # --- Update Visuals ---
    # Change wall colors to show if they are breakable
    update_wall_visuals

    # --- Game Over Check ---
    # If we are out of coins and haven't won, it's game over.
    coins_remaining 1 _negate == IF
        0 AS GAME.running
    END

    # --- Coin Respawn Logic ---
    # The coin timer is now used to respawn the coin after it's collected.
    &t_coin t_coin_time GAME.is_timer_ready IF
        rnd_xy1 COIN GAME.tile_move
        coins_remaining 1 - AS coins_remaining
        1 AS _coins_dirty

        # coins_remaining 0 == IF
        #     0 AS GAME.running
        # END
    END

    t_monster_cooldown IF
        t_monster_cooldown 1 - AS t_monster_cooldown
    ELSE
    # --- Hunter Monster AI ---
        # The monster now always hunts when not in cooldown.
        &t_special t_special_time GAME.is_timer_ready IF
            # Get Player's coords
            PLAYER GAME.get_xy AS player_y AS player_x

            # Get Monster's coords
            SPECIAL GAME.get_xy AS monster_y AS monster_x

            # Calculate one step closer to the player
            player_x monster_x > IF monster_x 1 + AS monster_x END
            player_x monster_x < IF monster_x 1 - AS monster_x END
            player_y monster_y > IF monster_y 1 + AS monster_y END
            player_y monster_y < IF monster_y 1 - AS monster_y END

            # Move the monster
            monster_x monster_y SPECIAL GAME.tile_move

            # --- GETTING CAUGHT (PENALTY) ---
            # Check if the monster has caught the player
            SPECIAL GAME.check_overlap 
            PLAYER == IF
                REACT_BLOCK red Special SPECIAL GAME.update_tile_props
                # The score is positive, so apply the penalty
                # score 2 // AS score 
                # 1 AS _score_dirty
                score 0 > IF
                    score 2 // AS score 
                    1 AS _score_dirty
                END
                
                # Speed up the monster to increase difficulty
                t_special_time 90 > IF
                    t_special_time 1 - AS t_special_time
                END
                100 AS t_monster_cooldown   # Monster becomes dormant
            ELSE
                # Monster is hunting, but hasn't caught the player yet
                REACT_BLOCK lightGray Special SPECIAL GAME.update_tile_props
            END
        END
    END

    

    # Run the gameengine logic
    GAME.handle_input          # Senses: Get a raw physics report.
    GAME.process_events        # Mechanics: Execute mechanics and get a factual report.

    # Run the gamelogic: Apply game rules based on the factual report.
    AS interacted_id
    AS game_event
    game_event GAME_EVENT_OVERWRITE_ACTION == IF
        interacted_id COIN == IF
            score 1 + AS score
            # coins_remaining 1 - AS coins_remaining
            1 AS _score_dirty
            # 1 AS _coins_dirty
            # Force the coin timer to 0 to trigger an immediate respawn on the next cycle
            0 AS t_coin
        END
    ELSE game_event GAME_EVENT_BLOCK_ACTION == IF
        # At this point, interacted_id is the PLAYER (keyboard) tile
        
        check_the_walls     # routine to check the walls and set color

        # --- FIGHTING BACK (REDEMPTION) ---
        # Player collides with the monster
        interacted_id SPECIAL == IF
            score 0 < IF            # Player is in "debt"
                0 AS score          # Reset score to 0
                1 AS _score_dirty
                REACT_BLOCK lightRed Special SPECIAL GAME.update_tile_props
                200 AS t_monster_cooldown   # Monster becomes dormant
            END
        END
            
    END END

    _score_dirty IF
        score print_score
        GAME.refresh
    END

    _coins_dirty IF
        coins_remaining print_coins
        GAME.refresh
    END
    GAME.redraw_all_moved_tiles     # Update screen for moving tiles

DONE        # End of the gameloop

# --- Game Over Sequence ---
# This code runs after the main loop (running == 0) has finished.
DEF game_over_sequence {
    # 1. Delete all tiles by moving them off-screen
    0 AS i
    WHILE i active_tile_count < DO
        i GAME.delete_tile
        i 1 + AS i
    DONE
    
    player_won IF
        # --- Player Won ---
        REACT_BLOCK lightGreen YouWonSprite SPECIAL GAME.update_tile_props
        36 47 SPECIAL GAME.tile_move
    ELSE
        # --- Player Lost ---
        REACT_BLOCK red YouLostSprite SPECIAL GAME.update_tile_props # This will update the sprite for SPECIAL
        36 47 SPECIAL GAME.tile_move
    END

    GAME.redraw_all_moved_tiles

    # 3. Optional: A final flip to ensure the screen is blank
    GAME.refresh
}

# Call the game over sequence
game_over_sequence
