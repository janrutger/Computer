##
# Escape The Box, the first game for the Stern-XT
# Using game_lib the gameengine library of the Stacks language
##

# 0) Include and helpers routines
INCLUDE game_lib


# 1) define the Tile data
LIST player_data 3              ; Define player
ASM {
    % $player_data 1 1 200      ; Pacman sprite
}
&player_data AS Player

LIST coin_data 3                ; Define coin
ASM {
    % $coin_data 1 1 42         ; Start (*) sprite
}
&coin_data AS Coin

LIST special_data  6            ; define Golden coin, or monster
ASM {
    % $special_data  2 2 203 203 203 203    ; 2x2 Solidblock for now
}
&special_data AS Special

LIST roof_data 29               ; Define roof (27 wide)
ASM {
    % $roof_data 27 1 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201
}
&roof_data AS Roof

LIST short_wall_data 12         ; Define short wall (10 high)
ASM {
    % $short_wall_data 1 10 201 201 201 201 201 201 201 201 201 201
}
&short_wall_data AS ShortWall

LIST long_wall_data 17          ; Define long wall (15 high)
ASM {
    % $long_wall_data 1 15 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201
}
&long_wall_data AS LongWall



CONST PLAYER      0
CONST COIN        1
CONST ROOF        2
CONST SHORT_LEFT  3
CONST LONG_LEFT   4
CONST SHORT_RIGHT 5
CONST LONG_RIGHT  6
CONST SPECIAL     7

CONST COST_ROOF   5
CONST COST_SHORT  2
CONST COST_LONG   3


# 2) Game setup & Patrol setup
# initialize game engine
init_game_lib


# --- Game Developer's variables for a patrol sequence ---
# 0    AS timer0           # The state variable for our patrol timer
# 750  AS timer0_time      # Wait N frames between moves
# 0    AS timer0_state     # 0 means 'even', 1 means means 'odd' (False/True)
350    AS t_coin            # The coin tile timer
750    AS t_coin_time       # Duration of the timer

100    AS t_special         # the Special tile timer
200    AS t_special_time    # Duration of the timer



# --- Game developer's replacement rules come here ---


###  END replacement rules  ###


# --- Create the initial Tiles ---
# [ tile_id, start_x, start_y, data_ptr, color, reaction, replace_ptr ]
PLAYER      39 46 Player    green    REACT_BLOCK     0 GAME.init_tile
COIN        30 40 Coin      yellow   REACT_OVERWRITE 0 GAME.init_tile
ROOF        26 34 Roof      orange   REACT_BLOCK     0 GAME.init_tile
SHORT_LEFT  26 35 ShortWall orange   REACT_BLOCK     0 GAME.init_tile
LONG_LEFT   26 45 LongWall  orange   REACT_BLOCK     0 GAME.init_tile
SHORT_RIGHT 52 50 ShortWall orange   REACT_BLOCK     0 GAME.init_tile
LONG_RIGHT  52 35 LongWall  orange   REACT_BLOCK     0 GAME.init_tile
SPECIAL     45 50 Special   darkGray REACT_BLOCK     0 GAME.init_tile

8 AS active_tile_count      # We have initialized 8 Tiles
PLAYER AS KEYBOARD_TILE     # Set the player tile
#GAME.refresh                # Update the screen

# more game setup here
DEF rnd_xy1 {                # Helper for generating random coordinates
    RND 25 % 27 +            # for an 1x1 tile
    RND 24 % 35 +
}

DEF rnd_xy2 {                # Helper for generating random coordinates
    RND 24 % 27 +            # for an 2x2 tile
    RND 23 % 35 +
}

VALUE _score_dirty 1
DEF print_score {
    #red IO 2 COLOR
    26 IO 2 X 
    32 IO 2 Y 

    AS _score
    
    background IO 2 COLOR
    solid_block IO 2 DRAW
    red IO 2 COLOR
    _score 0 < IF
        45 IO 2 DRAW
        _score _negate AS _score        # _negate is the game_lib negate function
    ELSE
        43 IO 2 DRAW
    END

    
    _score 100 //      48 + AS _hunreds
    _score 100 % 10 // 48 + AS _tens
    _score 10 %        48 + AS _ones

    27 IO 2 X 
        background IO 2 COLOR
        solid_block IO 2 DRAW
        red IO 2 COLOR
        _hunreds   IO 2 DRAW
    28 IO 2 X 
        background IO 2 COLOR
        solid_block IO 2 DRAW
        red IO 2 COLOR
        _tens      IO 2 DRAW
    29 IO 2 X 
        background IO 2 COLOR
        solid_block IO 2 DRAW
        red IO 2 COLOR
        _ones      IO 2 DRAW

    0 AS _score_dirty
}


# 3) Game loop
1 AS running
WHILE running DO
    # Ask the timer function if it's time to make a move.
    # We pass a pointer to our specific timer variable.
    # &timer0 timer0_time is_timer_ready IF
    #     # is_timer_ready returned 1, so we are "informed" it's time to act.
    #     timer0_state IF             # We are in state 1, move back to original position
    #         0 AS timer_0_state      # Switch to state 0 for next time
    #     ELSE                        # We are in state 0, move to a new position 
    #         1 AS timer_0_state      # Switch to state 1 for next time
    #     END
    # END
    &t_coin t_coin_time is_timer_ready IF
        rnd_xy1 COIN tile_move
    END

    &t_special t_special_time is_timer_ready IF
        rnd_xy2 SPECIAL tile_move
    END


    # Run the gameengine logic
    GAME.handle_input          # Senses: Get a raw physics report.
    GAME.process_events        # Mechanics: Execute mechanics and get a factual report.

    # Run the gamelogic: Apply game rules based on the factual report.
    AS interacted_id
    AS game_event

    #check the events ant act on it
    game_event GAME_EVENT_OVERWRITE_ACTION == IF
        interacted_id COIN == IF
            score 1 + AS score
            1 AS _score_dirty
            0 AS t_coin 
            # rnd_xy1 COIN tile_move
        END
    ELSE game_event GAME_EVENT_BLOCK_ACTION == IF
        0 AS _costs                 # reset the costs
        interacted_id ROOF == IF
            _costs COST_ROOF + AS _costs    # Update _costs
            ROOF                            # Place ROOF on the stack
        ELSE interacted_id SHORT_LEFT == IF
            _costs COST_SHORT + AS _costs  # Update _costs
            SHORT_LEFT                     # Place SHORT_LEFT on the stack
        ELSE interacted_id LONG_LEFT == IF
            _costs COST_LONG + AS _costs   # Update _costs
            LONG_LEFT                      # Place LONG_LEFT on the stack
        ELSE interacted_id SHORT_RIGHT == IF
            _costs COST_SHORT + AS _costs  # Update _costs
            SHORT_RIGHT                    # Place SHORT_RIGHT on the stack
        ELSE interacted_id LONG_RIGHT == IF
            _costs COST_LONG + AS _costs   # Update _costs
            LONG_RIGHT                     # Place LONG_RIGHT on the stack
        END END END END END
        _costs IF
            score _costs < IF              # No credits
                score _costs - AS score
                1 AS _score_dirty
                DROP                       # Drop the tile ID
            ELSE
                score _costs + AS score
                1 AS _score_dirty
                delete_tile                # Delete the tile
            END
        END
    ELSE game_event GAME_EVENT_REPLACE_ACTION == IF
        interacted_id 0 == IF
            score 1 + AS score
            1 AS _score_dirty
        END
    END END END

    _score_dirty IF
        score print_score
        GAME.refresh
    END
    GAME.redraw_all_moved_tiles # Update screen for moving tiles

DONE
