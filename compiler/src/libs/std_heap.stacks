; ##############################################################################
; #
; #   Heap-allocated Data Structures Library for the Stacks Language
; #
; ##############################################################################
; 
; Provides functions for creating and manipulating dynamic data structures on a 
; This version of the library will "panic" (print an error and halt) on any error.

USE std_stern_io

; --- Internal state for the heap allocator ---
VALUE HEAP_START 0
VALUE HEAP_SIZE 0
VALUE HEAP_FREE 0
VALUE _ARR_TEMP_PTR 0
# VALUE _ARR_VALUE_PTR 0 # not used

; --- Internal state for Matrix operations ---
VALUE _MAT_TEMP_PTR 0
VALUE _MAT_X_DIM 0
VALUE _MAT_Y_DIM 0
VALUE _MAT_VALUE 0
VALUE _MAT_PTR 0
VALUE _MAT_LOOP_COUNTER 0 
VALUE _MAT_OFFSET 0


STRING error_mesg0 "NEW.array: No space on heap\n"
STRING error_mesg1 "ARRAY.append: Array is full\n"
STRING error_mesg2 "ARRAY.put: Index out of bounds\n"
STRING error_mesg3 "ARRAY.get: Index out of bounds\n"

STRING error_mesg4 "NEW.list: No space on heap\n"
STRING error_mesg5 "NEW.matrix: No space on heap\n"
STRING error_mesg6 "NEW.matrix: Not enough data on stack\n"
STRING error_mesg7 "MATRIX: Index out of bounds\n"
STRING error_mesg8 "NEW.matrix: Invalid dimensions\n"

; --- HEAP.init ---
; Initializes the heap allocator. This must be called once before any
; other data structure functions are used.
; ( heap_start_ptr heap_size -- )
DEF HEAP.init {
    AS HEAP_SIZE
    AS HEAP_START
    HEAP_START AS HEAP_FREE
}

DEF HEAP.free {
    HEAP_START AS HEAP_FREE
}


; --- NEW.list ---
; Allocates a raw block of memory from the heap (like malloc).
; No header is created.
; ( size_in_words -- pointer_to_block )
VALUE _list_size 0
VALUE _list_ptr 0
DEF NEW.list {
    AS _list_size

    ; Check if there is enough space on the heap
    HEAP_FREE _list_size + HEAP_START HEAP_SIZE + > IF
        &error_mesg4 PRTstring
        HALT
    END

    HEAP_FREE AS _list_ptr

    ; Update next_free_space
    HEAP_FREE _list_size + AS HEAP_FREE

    _list_ptr     ; return pointer to allocated block
}

; --- LIST.put ---
; Writes a value to a raw list at an index.
; ( value index list_ptr -- )
VALUE _LST_PTR 0
VALUE _LST_IDX 0
VALUE _LST_VAL 0
DEF LIST.put {
    AS _LST_PTR
    AS _LST_IDX
    AS _LST_VAL
    
    ASM {
        ldm A $_LST_VAL
        ldm B $_LST_PTR
        ldm I $_LST_IDX
        add I B
        stx A $_start_memory_
    }
}

; --- LIST.get ---
; Reads a value from a raw list at an index.
; ( index list_ptr -- value )
DEF LIST.get {
    AS _LST_PTR
    AS _LST_IDX
    
    ASM {
        ldm B $_LST_PTR
        ldm I $_LST_IDX
        add I B
        ldx A $_start_memory_
        stack A $DATASTACK_PTR
    }
}


; --- NEW.array ---
; Creates a new array. Halts on failure.
; ( requested_capacity -- new_array_pointer )
VALUE requested_capacity 0
VALUE total_size 0
VALUE new_array_pointer 0
DEF NEW.array {
    AS requested_capacity
    
    ; total_size = requested_capacity + 2 (for header)
    requested_capacity 2 + AS total_size

    ; Check if there is enough space on the heap
    HEAP_FREE total_size + HEAP_START HEAP_SIZE + > IF
        &error_mesg0 PRTstring
        HALT
    END

    HEAP_FREE AS new_array_pointer

    ; Update next_free_space
    HEAP_FREE total_size + AS HEAP_FREE

    ; Write header
    new_array_pointer AS _ARR_TEMP_PTR
    requested_capacity AS *_ARR_TEMP_PTR   ; Capacity
    
    new_array_pointer 1 + AS _ARR_TEMP_PTR
    0 AS *_ARR_TEMP_PTR                    ; Count

    new_array_pointer     ; return new array pointer
}


; --- ARRAY.append ---
; Appends an element to the end of the array. Halts on failure.
; ( value array_ptr -- )
VALUE array_ptr 0
VALUE _value 0
VALUE _capacity 0
VALUE _count 0
VALUE dest_addr 0
DEF ARRAY.append {
    AS array_ptr
    AS _value

    ; Read header
    array_ptr AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR AS _capacity
    array_ptr 1 + AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR AS _count

    ; Check if array is full
    _count _capacity > IF
        &error_mesg1 PRTstring HALT
    END
    _count _capacity == IF
        &error_mesg1 PRTstring HALT
    END

    ; Calculate destination address
    array_ptr 2 + _count + AS dest_addr
    
    ; Write value
    dest_addr AS _ARR_TEMP_PTR
    _value AS *_ARR_TEMP_PTR

    ; Increment _count
    array_ptr 1 + AS _ARR_TEMP_PTR
    _count 1 + AS *_ARR_TEMP_PTR
}


; --- ARRAY.put ---
; Updates a value at a specific index. Halts on failure.
; ( value index array_ptr -- )
VALUE _index 0
DEF ARRAY.put {
    AS array_ptr
    AS _index
    AS _value

    ; Read count
    array_ptr 1 + AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR AS _count

    ; Check if index is out of bounds
    _index 0 < IF
        &error_mesg2 PRTstring HALT
    END
    _index _count > IF
        &error_mesg2 PRTstring HALT
    END
    _index _count == IF
        &error_mesg2 PRTstring HALT
    END

    ; Calculate destination address
    array_ptr 2 + _index + AS dest_addr

    ; Write value
    dest_addr AS _ARR_TEMP_PTR
    _value AS *_ARR_TEMP_PTR
}


; --- ARRAY.get ---
; Reads the value at any index. Halts on failure.
; ( index array_ptr -- value )
VALUE read_addr 0
DEF ARRAY.get {
    AS array_ptr
    AS _index

    ; Read count
    array_ptr 1 + AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR AS _count

    ; Check if index is out of bounds
    _index 0 < IF
        &error_mesg3 PRTstring HALT
    END
    _index _count > IF
        &error_mesg3 PRTstring HALT
    END
    _index _count == IF
        &error_mesg3 PRTstring HALT
    END

    ; Calculate read address
    array_ptr 2 + _index + AS read_addr

    ; Read value
    read_addr AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR
}


; --- ARRAY.size ---
; Returns the capacity of the array.
; ( array_ptr -- capacity )
# VALUE array_ptr 0   
DEF ARRAY.size {
    AS array_ptr
    array_ptr AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR
}


; --- ARRAY.len ---
; Returns the current number of elements.
; ( array_ptr -- count )
DEF ARRAY.len {
    AS array_ptr
    array_ptr 1 + AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR
}


# ----------------------------------------------------------------------------
# HELPER: ARRAY.clear
# Resets the count of an array to zero, effectively clearing it without
# deallocating its memory. This is essential for reusing temporary arrays
# during the training process.
#
# Stack: (array_ptr -- )
# ----------------------------------------------------------------------------
DEF ARRAY.clear {
    # ( array_ptr -- )
    # This function takes an array pointer, calculates the address
    # of its 'count' field (ptr + 1), and writes a 0 to that address.
    # It uses a temporary pointer to avoid side-effects on global variables.
    1 + AS _ARR_TEMP_PTR
    0 AS *_ARR_TEMP_PTR
}


; --- NEW.matrix ---
; Allocates a matrix on the heap.
; ( rows cols -- pointer )
VALUE _total_data_elements 0
VALUE _total_matrix_size 0
DEF NEW.matrix {
    AS _MAT_X_DIM ; cols
    AS _MAT_Y_DIM ; rows

    ; Check for valid dimensions (>= 1)
    _MAT_X_DIM 1 < IF &error_mesg8 PRTstring HALT END
    _MAT_Y_DIM 1 < IF &error_mesg8 PRTstring HALT END

    _MAT_X_DIM _MAT_Y_DIM * AS _total_data_elements
    _total_data_elements 2 + AS _total_matrix_size

    ; Check if there is enough space on the heap
    HEAP_FREE _total_matrix_size + HEAP_START HEAP_SIZE + > IF
        &error_mesg5 PRTstring
        HALT
    END

    HEAP_FREE AS _MAT_PTR

    ; Update next_free_space
    HEAP_FREE _total_matrix_size + AS HEAP_FREE

    ; Write header
    _MAT_PTR AS _MAT_TEMP_PTR
    _MAT_Y_DIM AS *_MAT_TEMP_PTR   ; Rows at offset 0

    _MAT_PTR 1 + AS _MAT_TEMP_PTR
    _MAT_X_DIM AS *_MAT_TEMP_PTR   ; Cols at offset 1

    _MAT_PTR
}

; --- MATRIX.put ---
; Writes a value to the matrix.
; ( value row col matrix_ptr -- )
DEF MATRIX.put {
    AS _MAT_PTR
    AS _MAT_X_DIM ; col
    AS _MAT_Y_DIM ; row
    AS _MAT_VALUE

    ; Check Row bounds (1 <= row <= ROWS)
    _MAT_Y_DIM 1 < IF &error_mesg7 PRTstring HALT END
    _MAT_PTR AS _MAT_TEMP_PTR
    *_MAT_TEMP_PTR AS _MAT_OFFSET ; Read ROWS
    _MAT_Y_DIM _MAT_OFFSET > IF &error_mesg7 PRTstring HALT END

    ; Check Col bounds (1 <= col <= COLS)
    _MAT_X_DIM 1 < IF &error_mesg7 PRTstring HALT END
    _MAT_PTR 1 + AS _MAT_TEMP_PTR
    *_MAT_TEMP_PTR AS _MAT_OFFSET ; Read COLS
    _MAT_X_DIM _MAT_OFFSET > IF &error_mesg7 PRTstring HALT END

    ; Adjust for 1-based indexing
    _MAT_X_DIM 1 - AS _MAT_X_DIM
    _MAT_Y_DIM 1 - AS _MAT_Y_DIM

    ; Note: _MAT_OFFSET currently holds COLS from the check above.

    ; Calculate offset: 2 + (row * cols) + col
    _MAT_Y_DIM _MAT_OFFSET * _MAT_X_DIM + 2 + AS _MAT_OFFSET

    ; Write value
    _MAT_PTR _MAT_OFFSET + AS _MAT_TEMP_PTR
    _MAT_VALUE AS *_MAT_TEMP_PTR
}

; --- MATRIX.get ---
; Reads a value from the matrix.
; ( row col matrix_ptr -- value )
DEF MATRIX.get {
    AS _MAT_PTR
    AS _MAT_X_DIM ; col
    AS _MAT_Y_DIM ; row

    ; Check Row bounds (1 <= row <= ROWS)
    _MAT_Y_DIM 1 < IF &error_mesg7 PRTstring HALT END
    _MAT_PTR AS _MAT_TEMP_PTR
    *_MAT_TEMP_PTR AS _MAT_OFFSET ; Read ROWS
    _MAT_Y_DIM _MAT_OFFSET > IF &error_mesg7 PRTstring HALT END

    ; Check Col bounds (1 <= col <= COLS)
    _MAT_X_DIM 1 < IF &error_mesg7 PRTstring HALT END
    _MAT_PTR 1 + AS _MAT_TEMP_PTR
    *_MAT_TEMP_PTR AS _MAT_OFFSET ; Read COLS
    _MAT_X_DIM _MAT_OFFSET > IF &error_mesg7 PRTstring HALT END

    ; Adjust for 1-based indexing
    _MAT_X_DIM 1 - AS _MAT_X_DIM
    _MAT_Y_DIM 1 - AS _MAT_Y_DIM

    ; Note: _MAT_OFFSET currently holds COLS from the check above.

    ; Calculate offset: 2 + (row * cols) + col
    _MAT_Y_DIM _MAT_OFFSET * _MAT_X_DIM + 2 + AS _MAT_OFFSET

    ; Read value
    _MAT_PTR _MAT_OFFSET + AS _MAT_TEMP_PTR
    *_MAT_TEMP_PTR
}

; --- NEW.matrix_populate ---
; Creates a new matrix and initializes it with data from the stack.
; Halts on failure.
; ( data_N ... data_0 y_dim x_dim -- new_matrix_pointer )

DEF NEW.matrix_populate {
    AS _MAT_X_DIM
    AS _MAT_Y_DIM

    ; Check for valid dimensions (>= 1)
    _MAT_X_DIM 1 < IF &error_mesg8 PRTstring HALT END
    _MAT_Y_DIM 1 < IF &error_mesg8 PRTstring HALT END

    _MAT_X_DIM _MAT_Y_DIM * AS _total_data_elements ; Calculate total data elements
    _total_data_elements 2 + AS _total_matrix_size  ; Add 2 for header (x_dim, y_dim)

    ; Check if there is enough space on the heap
    HEAP_FREE _total_matrix_size + HEAP_START HEAP_SIZE + > IF
        &error_mesg5 PRTstring
        HALT
    END

    HEAP_FREE AS _MAT_PTR ; This will be the pointer to the new matrix

    ; Update next_free_space
    HEAP_FREE _total_matrix_size + AS HEAP_FREE

    ; Write header
    _MAT_PTR AS _MAT_TEMP_PTR
    _MAT_Y_DIM AS *_MAT_TEMP_PTR   ; Rows at offset 0
    _MAT_PTR 1 + AS _MAT_TEMP_PTR
    _MAT_X_DIM AS *_MAT_TEMP_PTR   ; Cols at offset 1

    ; Populate data elements from stack
    _MAT_PTR 2 + AS _MAT_TEMP_PTR ; Start writing data after header
    0 AS _MAT_LOOP_COUNTER        ; Use as loop counter

    :matrix_populate_loop
        _MAT_LOOP_COUNTER _total_data_elements < IF
            TOS.check 0 == IF
                &error_mesg6 PRTstring
                HALT
            END

            AS _MAT_VALUE          ; Pop data element from stack
            _MAT_VALUE AS *_MAT_TEMP_PTR ; Write value to the address in _MAT_TEMP_PTR
            _MAT_TEMP_PTR 1 + AS _MAT_TEMP_PTR ; Move to next memory location
            _MAT_LOOP_COUNTER 1 + AS _MAT_LOOP_COUNTER
            GOTO matrix_populate_loop
        END

    _MAT_PTR     ; return new matrix pointer
}
