; ##############################################################################
; #
; #   Heap-allocated Data Structures Library for the Stacks Language
; #
; ##############################################################################
; 
; Provides functions for creating and manipulating dynamic data structures on a 
; pre-allocated heap.
; This version of the library will "panic" (print an error and halt) on any error.

USE std_stern_io

; --- Internal state for the heap allocator ---
VALUE HEAP_START 0
VALUE HEAP_SIZE 0
VALUE HEAP_FREE 0
VALUE _ARR_TEMP_PTR 0
VALUE _ARR_VALUE_PTR 0


STRING error_mesg0 "NEW.array: No space on heap\n"
STRING error_mesg1 "ARRAY.append: Array is full\n"
STRING error_mesg2 "ARRAY.put: Index out of bounds\n"
STRING error_mesg3 "ARRAY.get: Index out of bounds\n"


; --- HEAP.init ---
; Initializes the heap allocator. This must be called once before any
; other data structure functions are used.
; ( heap_start_ptr heap_size -- )
DEF HEAP.init {
    AS HEAP_SIZE
    AS HEAP_START
    HEAP_START AS HEAP_FREE
}


; --- NEW.array ---
; Creates a new array. Halts on failure.
; ( requested_capacity -- new_array_pointer )
VALUE requested_capacity 0
VALUE total_size 0
VALUE new_array_pointer 0
DEF NEW.array {
    AS requested_capacity
    
    ; total_size = requested_capacity + 2 (for header)
    requested_capacity 2 + AS total_size

    ; Check if there is enough space on the heap
    HEAP_FREE total_size + HEAP_START HEAP_SIZE + > IF
        &error_mesg0 PRTstring
        HALT
    END

    HEAP_FREE AS new_array_pointer

    ; Update next_free_space
    HEAP_FREE total_size + AS HEAP_FREE

    ; Write header
    new_array_pointer AS _ARR_TEMP_PTR
    requested_capacity AS *_ARR_TEMP_PTR   ; Capacity
    
    new_array_pointer 1 + AS _ARR_TEMP_PTR
    0 AS *_ARR_TEMP_PTR                    ; Count

    new_array_pointer     ; return new array pointer
}


; --- ARRAY.append ---
; Appends an element to the end of the array. Halts on failure.
; ( value array_ptr -- )
VALUE array_ptr 0
VALUE _value 0
VALUE _capacity 0
VALUE _count 0
VALUE dest_addr 0
DEF ARRAY.append {
    AS array_ptr
    AS _value

    ; Read header
    array_ptr AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR AS _capacity
    array_ptr 1 + AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR AS _count

    ; Check if array is full
    _count _capacity > IF
        &error_mesg1 PRTstring HALT
    END
    _count _capacity == IF
        &error_mesg1 PRTstring HALT
    END

    ; Calculate destination address
    array_ptr 2 + _count + AS dest_addr
    
    ; Write value
    dest_addr AS _ARR_TEMP_PTR
    _value AS *_ARR_TEMP_PTR

    ; Increment _count
    array_ptr 1 + AS _ARR_TEMP_PTR
    _count 1 + AS *_ARR_TEMP_PTR
}


; --- ARRAY.put ---
; Updates a value at a specific index. Halts on failure.
; ( value index array_ptr -- )
VALUE index 0
DEF ARRAY.put {
    AS array_ptr
    AS index
    AS _value

    ; Read count
    array_ptr 1 + AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR AS _count

    ; Check if index is out of bounds
    index 0 < IF
        &error_mesg2 PRTstring HALT
    END
    index _count > IF
        &error_mesg2 PRTstring HALT
    END
    index _count == IF
        &error_mesg2 PRTstring HALT
    END

    ; Calculate destination address
    array_ptr 2 + index + AS dest_addr

    ; Write value
    dest_addr AS _ARR_TEMP_PTR
    _value AS *_ARR_TEMP_PTR
}


; --- ARRAY.get ---
; Reads the value at any index. Halts on failure.
; ( index array_ptr -- value )
VALUE read_addr 0
DEF ARRAY.get {
    AS array_ptr
    AS index

    ; Read count
    array_ptr 1 + AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR AS _count

    ; Check if index is out of bounds
    index 0 < IF
        &error_mesg3 PRTstring HALT
    END
    index _count > IF
        &error_mesg3 PRTstring HALT
    END
    index _count == IF
        &error_mesg3 PRTstring HALT
    END

    ; Calculate read address
    array_ptr 2 + index + AS read_addr

    ; Read value
    read_addr AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR
}


; --- ARRAY.size ---
; Returns the capacity of the array.
; ( array_ptr -- capacity )
# VALUE array_ptr 0   
DEF ARRAY.size {
    AS array_ptr
    array_ptr AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR
}


; --- ARRAY.len ---
; Returns the current number of elements.
; ( array_ptr -- count )
DEF ARRAY.len {
    AS array_ptr
    array_ptr 1 + AS _ARR_TEMP_PTR
    *_ARR_TEMP_PTR
}
