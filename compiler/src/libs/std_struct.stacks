# std_struct.stacks
# Library for Dynamic Structs
# Requires: std_heap

USE std_heap

# --- STRUCT.new_type ---
# Creates a Struct Blueprint
# Stack: ( h1 ... hN N -- type_ptr )

VALUE _snt_n 0
VALUE _snt_ptr 0
VALUE _snt_i 0

STRING error_mesg9  "STRUCT.get: Field not found\n"
STRING error_mesg10 "STRUCT.put: Field not found\n"

DEF STRUCT.new_type {
    AS _snt_n
    
    # Allocate N + 1 words (Index 0 for N, 1..N for hashes)
    _snt_n 1 + NEW.list AS _snt_ptr
    
    # Store N at index 0
    ASM {
        ldm A $_snt_n
        ldm I $_snt_ptr
        stx A $_start_memory_
    }
    
    # Store hashes (Stack: h1 ... hN)
    # We pop hN first, which goes to index N
    _snt_n AS _snt_i
    WHILE _snt_i 0 > DO
        ASM {
            ustack A $DATASTACK_PTR
            ldm B $_snt_ptr
            ldm I $_snt_i
            add I B
            stx A $_start_memory_
        }
        _snt_i 1 - AS _snt_i
    DONE
    
    _snt_ptr
}

# --- STRUCT.new ---
# Creates a Struct Instance
# Stack: ( type_ptr -- instance_ptr )

VALUE _sn_type_ptr 0
VALUE _sn_n 0
VALUE _sn_inst_ptr 0
VALUE _sn_i 0

DEF STRUCT.new {
    AS _sn_type_ptr
    
    # Get N from type_ptr[0]
    ASM {
        ldm I $_sn_type_ptr
        ldx A $_start_memory_
        sto A $_sn_n
    }
    
    # Allocate N + 1 words (Index 0 for type_ptr, 1..N for values)
    _sn_n 1 + NEW.list AS _sn_inst_ptr
    
    # Store type_ptr at index 0
    ASM {
        ldm A $_sn_type_ptr
        ldm I $_sn_inst_ptr
        stx A $_start_memory_
    }
    
    # Zero-initialize fields (Index 1..N)
    1 AS _sn_i
    WHILE _sn_i _sn_n 1 + < DO
        ASM {
            ldi A 0
            ldm B $_sn_inst_ptr
            ldm I $_sn_i
            add I B
            stx A $_start_memory_
        }
        _sn_i 1 + AS _sn_i
    DONE
    
    _sn_inst_ptr
}

# --- STRUCT.put ---
# Writes to a field
# Stack: ( value field_hash instance_ptr -- )

VALUE _sp_inst_ptr 0
VALUE _sp_hash 0
VALUE _sp_val 0
VALUE _sp_type_ptr 0
VALUE _sp_n 0
VALUE _sp_i 0
VALUE _sp_found 0

DEF STRUCT.put {
    AS _sp_inst_ptr
    AS _sp_hash
    AS _sp_val
    
    # Get type_ptr from instance_ptr[0]
    ASM {
        ldm I $_sp_inst_ptr
        ldx A $_start_memory_
        sto A $_sp_type_ptr
    }
    
    # Get N from type_ptr[0]
    ASM {
        ldm I $_sp_type_ptr
        ldx A $_start_memory_
        sto A $_sp_n
    }
    
    0 AS _sp_found
    1 AS _sp_i
    WHILE _sp_i _sp_n 1 + < DO
        # Check hash at type_ptr[_sp_i]
        ASM {
            ldm B $_sp_type_ptr
            ldm I $_sp_i
            add I B
            ldx A $_start_memory_
            stack A $DATASTACK_PTR
        }
        
        _sp_hash == IF
            # Found match. Write value to instance_ptr[_sp_i]
            ASM {
                ldm A $_sp_val
                ldm B $_sp_inst_ptr
                ldm I $_sp_i
                add I B
                stx A $_start_memory_
            }
            # Exit loop
            _sp_n 1 + AS _sp_i
            1 AS _sp_found
        ELSE
            _sp_i 1 + AS _sp_i
        END
    DONE
    
    _sp_found 0 == IF
        &error_mesg10 PRTstring HALT
    END
}

# --- STRUCT.get ---
# Reads from a field
# Stack: ( field_hash instance_ptr -- value )

VALUE _sg_inst_ptr 0
VALUE _sg_hash 0
VALUE _sg_type_ptr 0
VALUE _sg_n 0
VALUE _sg_i 0
VALUE _sg_found 0

DEF STRUCT.get {
    AS _sg_inst_ptr
    AS _sg_hash
    
    # Get type_ptr from instance_ptr[0]
    ASM {
        ldm I $_sg_inst_ptr
        ldx A $_start_memory_
        sto A $_sg_type_ptr
    }
    
    # Get N from type_ptr[0]
    ASM {
        ldm I $_sg_type_ptr
        ldx A $_start_memory_
        sto A $_sg_n
    }
    
    0 AS _sg_found
    1 AS _sg_i
    WHILE _sg_i _sg_n 1 + < DO
        # Check hash at type_ptr[_sg_i]
        ASM {
            ldm B $_sg_type_ptr
            ldm I $_sg_i
            add I B
            ldx A $_start_memory_
            stack A $DATASTACK_PTR
        }
        
        _sg_hash == IF
            # Found match. Read value from instance_ptr[_sg_i]
            ASM {
                ldm B $_sg_inst_ptr
                ldm I $_sg_i
                add I B
                ldx A $_start_memory_
                stack A $DATASTACK_PTR
            }
            # Exit loop
            _sg_n 1 + AS _sg_i
            1 AS _sg_found
        ELSE
            _sg_i 1 + AS _sg_i
        END
    DONE
    
    _sg_found 0 == IF
        &error_mesg9 PRTstring HALT
    END
}