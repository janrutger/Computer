USE math_lib
USE std_stern_io
USE std_string


; A simple fixed-point math library for the Stern-XT
; A fixed-point number is an integer where the top (left) digits
; represent the whole number part and the bottom (right) digits  represent
; the fractional part.

;VALUE SCALE_FACTOR 10000000 
VALUE SCALE_FACTOR  1000 ;.default 3 fixed-point scale factor

CONST FP_DOT 46     ; the assci value for a single .
STRING FP_DOT_STR "."

STRING div_error "ERROR: Fixed point Division by zero!\n"

DEF FP.set_scale {
    AS SCALE_FACTOR
}


# print TOS and no newline
DEF TOS_nnl {
    ASM {
        ustack A $DATASTACK_PTR
        ld C A

        ldi I ~SYS_PRINT_NUMBER
        int $INT_VECTORS
        
    }
}


; --- Conversion Functions ---

; Converts an integer to a fixed-point number
; ( int -- fp )
DEF FP.from_int {
    SCALE_FACTOR *
}

; Converts a fixed-point number back to an integer (truncates)
; ( fp -- int )
DEF FP.to_int {
    SCALE_FACTOR //
}

; --- Arithmetic Functions ---

; Adds two fixed-point numbers
; ( fp_a fp_b -- result )
DEF FP.add {
    +
}

; Subtracts two fixed-point numbers
; ( fp_a fp_b -- result )
DEF FP.sub {
    -
}

; Multiplies two fixed-point numbers
; ( fp_a fp_b -- result )
DEF FP.mul {
    * DUP 0 < IF
        SCALE_FACTOR 2 // -
    ELSE
        SCALE_FACTOR 2 // +
    END
    SCALE_FACTOR //
}

; Divides two fixed-point numbers
; ( fp_a fp_b -- result )
DEF FP.div {
    # SWAP SCALE_FACTOR * SWAP //

    VALUE fp_b 0
    VALUE fp_a 0
    VALUE result_sign 1 ; 1 for positive, -1 for negative
    VALUE abs_numerator 0
    VALUE abs_denominator 0
    VALUE raw_result 0

    1 AS result_sign    ; default positive
 
    AS fp_b ; Stack: [fp_a]
    AS fp_a ; Stack: []

    ; Determine result sign
    fp_a 0 < IF result_sign 1 NEGATE * AS result_sign END
    fp_b 0 < IF result_sign 1 NEGATE * AS result_sign END

    ; Take absolute values
    fp_a ABS AS abs_numerator
    fp_b ABS AS abs_denominator

    # ; Perform division on absolute values
    # abs_numerator SCALE_FACTOR * AS abs_numerator ; This is the numerator for the division
    # abs_numerator abs_denominator // AS raw_result

    # ; Apply sign
    # raw_result result_sign *

    # Check for division by zero, and trow error return 0 if so
    abs_denominator 0 == IF
        div_error PRTstring
        0 ; Return 0 if denominator is 0
    ELSE
        abs_numerator SCALE_FACTOR * abs_denominator // result_sign *
    END

}


; Calculates fp_base ^ int_exponent for positive exponents
; ( fp_base int_exponent -- fp_result )
DEF FP.power {
    VALUE exponent 0
    VALUE base 0
    VALUE result 0

    AS exponent
    AS base

    ; Initialize result to 1.0_fp
    1 FP.from_int AS result

    ; Handle exponent = 0
    exponent 0 == IF
        result
        GOTO _fp_power_end
    END

    ; Positive exponent loop
    :loop_power
        exponent 0 > IF
            result base FP.mul AS result
            exponent 1- AS exponent
            GOTO loop_power
        END

    result

    :_fp_power_end
}


; --- Output Functions ---

; Prints a fixed-point number with a few decimal places (3 digits).
; ( fp -- )
DEF FP.print {
    VALUE frac 0 ; Local variable
    ; Print integer part
    DUP 0 < IF
        45 PRTchar
        NEGATE
    END

    DUP SCALE_FACTOR // TOS_nnl
    
    FP_DOT PRTchar

    ; Get fractional part
    SCALE_FACTOR % AS frac

    ; --- Extract and print decimal digits one by one ---

    ; 1st digit
    frac 10 * AS frac
    frac SCALE_FACTOR // TOS_nnl
    frac SCALE_FACTOR % AS frac

    ; 2nd digit
    frac 10 * AS frac
    frac SCALE_FACTOR // TOS_nnl
    frac SCALE_FACTOR % AS frac

    ; 3rd digit
    frac 10 * AS frac
    frac SCALE_FACTOR // TOS_nnl

}

; Prints a fixed-point number with a specified number of decimal places,
; capped by the maximum meaningful digits for the current SCALE_FACTOR.
; ( fp num_digits -- )
VALUE num_digits 0
VALUE MAX_VALID_DIGITS 0 ; variable for max possible digits
;VALUE frac 0 
VALUE temp_scale 1 
DEF FP.fprint {
    AS num_digits ; Get desired number of digits from stack

    DUP 0 < IF
        45 PRTchar
        NEGATE
    END

    ; Calculate MAX_VALID_DIGITS dynamically
    0 AS MAX_VALID_DIGITS
    1 AS temp_scale
    :loop_calc_valid_digits
        temp_scale SCALE_FACTOR < IF
            temp_scale 10 * AS temp_scale
            MAX_VALID_DIGITS 1+ AS MAX_VALID_DIGITS
            GOTO loop_calc_valid_digits
        END

    ; Cap num_digits to MAX_VALID_DIGITS
    num_digits MAX_VALID_DIGITS > IF
        MAX_VALID_DIGITS AS num_digits
    END

    ; Print integer part
    DUP SCALE_FACTOR // TOS_nnl
    
    FP_DOT PRTchar

    ; Get fractional part
    SCALE_FACTOR % AS frac

    ; --- Extract and print decimal digits one by one ---
    :loop_print_digits
        num_digits 0 > IF
            frac 10 * AS frac
            frac SCALE_FACTOR // TOS_nnl
            frac SCALE_FACTOR % AS frac

            num_digits 1- AS num_digits
            GOTO loop_print_digits
        END
}


; --- String to Fixed-Point Conversion Helpers ---

; Private helper to convert a string of a given length to an integer
; ( &str len -- num )
VALUE __natoi_p 0
VALUE __natoi_len 0
VALUE __natoi_res 0
DEF _STRNatoi {
    AS __natoi_len
    AS __natoi_p
    0 AS __natoi_res
    :loop_natoi
        __natoi_len 0 == IF
            __natoi_res
            GOTO _natoi_end
        END

        *__natoi_p 48 - ; get digit value
        __natoi_res 10 * + AS __natoi_res

        __natoi_p 1+ AS __natoi_p
        __natoi_len 1- AS __natoi_len
        GOTO loop_natoi
    :_natoi_end
}


; Converts a string like "12.34" to a fixed-point number.
; ( &str -- fp )
VALUE str_ptr 0
VALUE dot_index 0
VALUE dot_found 0
VALUE int_part_fp 0
VALUE frac_ptr 0
VALUE frac_len 0
VALUE total_len 0
VALUE frac_as_int 0
VALUE divisor 0
DEF FP.from_string {
    AS str_ptr

    VALUE sign 1
    1 AS sign

    ; Handle negative sign
    *str_ptr 45 == IF
        1 NEGATE AS sign
        str_ptr 1+ AS str_ptr
    END

    ; Find the decimal point
    str_ptr FP_DOT STRfind AS dot_found AS dot_index

    dot_found 0 == IF
        ; No decimal point, treat as integer
        str_ptr STRlen AS total_len
        str_ptr total_len _STRNatoi
        FP.from_int
        sign * ; Apply sign
        GOTO _fp_from_string_end
    END

    ; --- Integer part ---
    str_ptr dot_index _STRNatoi
    FP.from_int AS int_part_fp

    ; --- Fractional part ---
    str_ptr dot_index + 1+ AS frac_ptr
    
    str_ptr STRlen AS total_len
    total_len dot_index - 1- AS frac_len
    
    frac_ptr frac_len _STRNatoi AS frac_as_int

    10 frac_len power AS divisor

    ; frac_fp = (frac_as_int * SCALE_FACTOR) / divisor
    frac_as_int SCALE_FACTOR * divisor //

    ; result = int_part_fp + frac_part_fp
    int_part_fp +

    sign * ; Apply sign

    :_fp_from_string_end
}
