USE math_lib
USE std_stern_io
USE std_string


; A simple fixed-point math library for the Stern-XT
; A fixed-point number is an integer where the top (left) digits
; represent the whole number part and the bottom (right) digits  represent
; the fractional part.

;VALUE SCALE_FACTOR 10000000 
VALUE SCALE_FACTOR  1000 ;.default 3 fixed-point scale factor

CONST FP_DOT 46     ; the assci value for a single .
STRING FP_DOT_STR "."

DEF FP.set_scale {
    AS SCALE_FACTOR
}


# print TOS and no neweline
DEF TOS_nnl {
    ASM {
        ustack A $DATASTACK_PTR
        ld C A

        ldi I ~SYS_PRINT_NUMBER
        int $INT_VECTORS
        
    }
}


; --- Conversion Functions ---

; Converts an integer to a fixed-point number
; ( int -- fp )
DEF FP.from_int {
    SCALE_FACTOR *
}

; Converts a fixed-point number back to an integer (truncates)
; ( fp -- int )
DEF FP.to_int {
    SCALE_FACTOR //
}

; --- Arithmetic Functions ---

; Adds two fixed-point numbers
; ( fp_a fp_b -- result )
DEF FP.add {
    +
}

; Subtracts two fixed-point numbers
; ( fp_a fp_b -- result )
DEF FP.sub {
    -
}

; Multiplies two fixed-point numbers
; ( fp_a fp_b -- result )
DEF FP.mul {
    * SCALE_FACTOR //
}

; Divides two fixed-point numbers
; ( fp_a fp_b -- result )
DEF FP.div {
    SWAP SCALE_FACTOR * SWAP //
}

; --- Output Functions ---

; Prints a fixed-point number with a few decimal places (3 digits).
; ( fp -- )
DEF FP.print {
    VALUE frac 0 ; Local variable
    ; Print integer part
    DUP SCALE_FACTOR // TOS_nnl
    
    FP_DOT PRTchar

    ; Get fractional part
    SCALE_FACTOR % AS frac

    ; --- Extract and print decimal digits one by one ---

    ; 1st digit
    frac 10 * AS frac
    frac SCALE_FACTOR // TOS_nnl
    frac SCALE_FACTOR % AS frac

    ; 2nd digit
    frac 10 * AS frac
    frac SCALE_FACTOR // TOS_nnl
    frac SCALE_FACTOR % AS frac

    ; 3rd digit
    frac 10 * AS frac
    frac SCALE_FACTOR // TOS_nnl

}

; Prints a fixed-point number with a specified number of decimal places,
; capped by the maximum meaningful digits for the current SCALE_FACTOR.
; ( fp num_digits -- )
VALUE num_digits 0
VALUE MAX_VALID_DIGITS 0 ; variable for max possible digits
;VALUE frac 0 
VALUE temp_scale 1 
DEF FP.fprint {
    AS num_digits ; Get desired number of digits from stack

    ; Calculate MAX_VALID_DIGITS dynamically
    0 AS MAX_VALID_DIGITS
    1 AS temp_scale
    :loop_calc_valid_digits
        temp_scale SCALE_FACTOR < IF
            temp_scale 10 * AS temp_scale
            MAX_VALID_DIGITS 1+ AS MAX_VALID_DIGITS
            GOTO loop_calc_valid_digits
        END

    ; Cap num_digits to MAX_VALID_DIGITS
    num_digits MAX_VALID_DIGITS > IF
        MAX_VALID_DIGITS AS num_digits
    END

    ; Print integer part
    DUP SCALE_FACTOR // TOS_nnl
    
    FP_DOT PRTchar

    ; Get fractional part
    SCALE_FACTOR % AS frac

    ; --- Extract and print decimal digits one by one ---
    :loop_print_digits
        num_digits 0 > IF
            frac 10 * AS frac
            frac SCALE_FACTOR // TOS_nnl
            frac SCALE_FACTOR % AS frac

            num_digits 1- AS num_digits
            GOTO loop_print_digits
        END
}


; --- String to Fixed-Point Conversion Helpers ---

; Private helper to convert a string of a given length to an integer
; ( &str len -- num )
VALUE __natoi_p 0
VALUE __natoi_len 0
VALUE __natoi_res 0
DEF _STRNatoi {
    AS __natoi_len
    AS __natoi_p
    0 AS __natoi_res
    :loop_natoi
        __natoi_len 0 == IF
            __natoi_res
            GOTO _natoi_end
        END

        *__natoi_p 48 - ; get digit value
        __natoi_res 10 * + AS __natoi_res

        __natoi_p 1+ AS __natoi_p
        __natoi_len 1- AS __natoi_len
        GOTO loop_natoi
    :_natoi_end
}


; Converts a string like "12.34" to a fixed-point number.
; ( &str -- fp )
VALUE str_ptr 0
VALUE dot_index 0
VALUE dot_found 0
VALUE int_part_fp 0
VALUE frac_ptr 0
VALUE frac_len 0
VALUE total_len 0
VALUE frac_as_int 0
VALUE divisor 0
DEF FP.from_string {
    AS str_ptr

    ; Find the decimal point
    str_ptr FP_DOT STRfind AS dot_found AS dot_index

    dot_found 0 == IF
        ; No decimal point, treat as integer
        str_ptr STRlen AS total_len
        str_ptr total_len _STRNatoi
        FP.from_int
        GOTO _fp_from_string_end
    END

    ; --- Integer part ---
    str_ptr dot_index _STRNatoi
    FP.from_int AS int_part_fp

    ; --- Fractional part ---
    str_ptr dot_index + 1+ AS frac_ptr
    
    str_ptr STRlen AS total_len
    total_len dot_index - 1- AS frac_len
    
    frac_ptr frac_len _STRNatoi AS frac_as_int

    # 10 frac_len _MATHpow AS divisor
    10 frac_len power AS divisor

    ; frac_fp = (frac_as_int * SCALE_FACTOR) / divisor
    frac_as_int SCALE_FACTOR * divisor //

    ; result = int_part_fp + frac_part_fp
    int_part_fp +

    :_fp_from_string_end
}
