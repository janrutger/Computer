USE std_heap
USE std_stern_io

USE std_dict
USE std_deque

VALUE opcode_table 0
VALUE opcode_runtimes 0
VALUE label_addresses 0

VALUE syscall_table 0

# Internal variables for runtime handlers
VALUE _env_vvm_ptr 0
VALUE _env_sp_ptr_loc 0
VALUE _env_sp_addr 0
VALUE _env_val 0
VALUE _env_host_ptr_loc 0
VALUE _env_host_dq 0
VALUE _env_count 0
VALUE _env_ptr 0
VALUE _env_idx 0
VALUE _env_val_tmp 0
VALUE _math_a 0
VALUE _math_b 0

STRING error_stack_collision "VVM Stack Collision (PC>=RSP). \n"

# Peek a value from the VVM struct
# ( index &VVM-pointer -- value )
DEF VVMpeek {
    AS _env_ptr
    AS _env_idx
    *_env_ptr AS _env_ptr
    _env_ptr _env_idx + AS _env_ptr
    *_env_ptr
}

# Poke a value in the VVM struct
# ( value index &VVM-pointer -- )
DEF VVMpoke {
    AS _env_ptr
    AS _env_idx
    AS _env_val_tmp
    *_env_ptr AS _env_ptr
    _env_ptr _env_idx + AS _env_ptr
    _env_val_tmp AS *_env_ptr
}


# Setup VVM memory structure
CONST VVM_status    0
CONST VVM_size      1
CONST VVM_PC        2
CONST VVM_SP        3
CONST VVM_HOST_ptr  4
CONST VVM_RSP       5
CONST VVM_stack     6   ; reservation of 16 words
CONST VVM_regs      22  ; reservation for 26 registers
CONST VVM_code      50  ; Start of code block

# Setup VVM status codes
CONST VVM_Running   0
CONST VVM_Sys       1
CONST VVM_Idle      2
CONST VVM_Error     3
CONST VVM_Halted    4


# Setup opcodes
# 0 .. 49 zero argument opcodes
CONST _halt_        0
CONST _nop_         1
CONST _sys_         2
CONST _out_         3
CONST _fetch_       4
CONST _ret_         6


CONST _dup_         10
CONST _drop_        11
CONST _swap_        12
CONST _over_        13

CONST _add_         20
CONST _sub_         21
CONST _mul_         22
CONST _div_         23
CONST _mod_         24
CONST _neg_         25
CONST _eq_          26
CONST _ne_          27
CONST _lt_          28
CONST _gt_          29
CONST _abs_         30
CONST _rnd_         31
# 50 .. 99 one argument opcodes
CONST _push_        50
CONST _get_         51
CONST _set_         52

CONST _label_       60
CONST _bra_         61
CONST _brz_         62
CONST _bnz_         63
CONST _brp_         64
CONST _brn_         65
CONST _call_        66


### end of the opcodes

### Setup the Syscalls constants
# CONSOLE
CONST PRINT_NUM     10 
CONST PRINT_CHAR    11
# INPUT
CONST READ_NUM      20
CONST READ_CHAR     21
# SYSTEM
# DEVICES
CONST UDC_IO        50

### end of the syscalls



## Setup runtime handlers
DEF s_halt {
    AS _env_vvm_ptr
    # Set status to Halted
    VVM_Halted VVM_status _env_vvm_ptr VVMpoke
}

DEF s_call { 
    AS _env_vvm_ptr
    AS _math_a # target address (Label)
    
    # 1. Get current PC (Return Address)
    VVM_PC _env_vvm_ptr VVMpeek AS _env_val
    
    # 2. Get RSP and Decrement (Full Descending Stack)
    VVM_RSP _env_vvm_ptr VVMpeek 1 - AS _env_sp_addr
    
    # 3. Check Collision (PC >= RSP)
    # We check if (PC < RSP) is False (0). 
    # If so, PC >= RSP, which is a collision.
    _env_val _env_sp_addr < 0 == IF
        &error_stack_collision PRTstring HALT
    END
    
    # 4. Push Return Address and Update RSP
    _env_val AS *_env_sp_addr
    _env_sp_addr VVM_RSP _env_vvm_ptr VVMpoke
    
    # 5. Jump to target
    _math_a VVM_PC _env_vvm_ptr VVMpoke
}

DEF s_ret {
    AS _env_vvm_ptr
    # 1. Pop Return Address from RSP
    VVM_RSP _env_vvm_ptr VVMpeek AS _env_sp_addr
    *_env_sp_addr AS _env_val
    
    # 2. Increment RSP and Update
    _env_sp_addr 1 + VVM_RSP _env_vvm_ptr VVMpoke
    
    # 3. Set PC (Return)
    _env_val VVM_PC _env_vvm_ptr VVMpoke
}

DEF s_nop {
    DROP
}

DEF s_sys {
    # This handler is a no-op. The _sys_ opcode is a special signal
    # caught by the VVM.run loop to change the VVM's state. It does not
    # perform an action itself.
}

DEF s_out {
    AS _env_vvm_ptr

    # Pop value from VVM Stack
    VVM_SP _env_vvm_ptr VVMpeek 1 - AS _env_sp_addr
    *_env_sp_addr AS _env_val
    _env_sp_addr VVM_SP _env_vvm_ptr VVMpoke

    # Append to Host Deque
    VVM_HOST_ptr _env_vvm_ptr VVMpeek AS _env_host_dq
    _env_val _env_host_dq DEQUE.append
}

DEF s_fetch {
    AS _env_vvm_ptr

    # 1. Get the host deque pointer from the VVM struct
    VVM_HOST_ptr _env_vvm_ptr VVMpeek AS _env_host_dq

    # 2. Fetch the value from the host deque.
    #    This is a blocking operation if the deque is empty, waiting for the host.
    _env_host_dq DEQUE.pop_tail AS _env_val

    # 3. Get the VVM's current stack pointer (points to next free slot)
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # 4. Push the fetched value onto the VVM's data stack
    _env_val AS *_env_sp_addr

    # 5. Increment and update the VVM's stack pointer
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- (a b b))
DEF s_dup {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b 

    # Push B twice
    _env_sp_addr 1 + AS _env_sp_addr
    _math_b AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke

}

# ( A B -- (a))
DEF s_drop {
    AS _env_vvm_ptr
    # Get SP, decrement, and update
    VVM_SP _env_vvm_ptr VVMpeek 1 - VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- (b a))
DEF s_swap {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Read TOS (B)
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b

    # Read Next (A)
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Write B to A's slot
    _math_b AS *_env_sp_addr

    # Write A to B's slot
    _env_sp_addr 1 + AS _env_sp_addr
    _math_a AS *_env_sp_addr
}

# ( A B -- (a b a))
DEF s_over {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Read A (SP-2)
    _env_sp_addr 2 - AS _env_ptr
    *_env_ptr AS _math_a

    # Push A (at SP)
    _math_a AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- (a + b))
DEF s_add {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b


    # Pop A
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Push A + B
    _math_a _math_b + AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- ( a - b))
DEF s_sub {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b

    # Pop A
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Push A - B
    _math_a _math_b - AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- ( a * b))
DEF s_mul {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b

    # Pop A
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Push A * B
    _math_a _math_b * AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- ( a // b))
DEF s_div {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b

    _math_b 0 == IF
        &error_div_zero PRTstring HALT
    END

    # Pop A
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Push A // B
    _math_a _math_b // AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- ( a % b))
DEF s_mod {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b

    _math_b 0 == IF
        &error_div_zero PRTstring HALT
    END

    # Pop A
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Push A % B
    _math_a _math_b % AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A -- (0 - a))
DEF s_neg {
    AS _env_vvm_ptr
    
    # Get SP (points to next free), decrement to get TOS
    VVM_SP _env_vvm_ptr VVMpeek 1 - AS _env_sp_addr
    
    # In-place negation: read, negate, write back
    # *_env_sp_addr -1 * AS *_env_sp_addr
    0 *_env_sp_addr - AS *_env_sp_addr

}

# ( A B -- ( a == b))
DEF s_eq {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b

    # Pop A
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Push A == B
    _math_a _math_b == AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- ( a != b))
DEF s_ne {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b

    # Pop A
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Push A != B
    _math_a _math_b != AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- ( a < b))
DEF s_lt {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b

    # Pop A
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Push A < B
    _math_a _math_b < AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A B -- ( a > b))
DEF s_gt {
    AS _env_vvm_ptr

    # Get SP
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Pop B
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_b

    # Pop A
    _env_sp_addr 1 - AS _env_sp_addr
    *_env_sp_addr AS _math_a

    # Push A > B
    _math_a _math_b > AS *_env_sp_addr

    # Update SP
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

# ( A -- |A| )
DEF s_abs {
    AS _env_vvm_ptr
    
    # Get SP (points to next free), decrement to get TOS
    VVM_SP _env_vvm_ptr VVMpeek 1 - AS _env_sp_addr
    
    # Read value
    *_env_sp_addr AS _math_a
    
    # Calculate ABS
    _math_a 0 < IF
        0 _math_a - AS _math_a
    END
    
    # Write back
    _math_a AS *_env_sp_addr
}

DEF s_rnd {
    AS _env_vvm_ptr
    RND AS _env_val
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr
    _env_val AS *_env_sp_addr
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

DEF s_push {
    AS _env_vvm_ptr
    AS _env_val
    
    # Get SP (Absolute Address)
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr

    # Push value to VVM stack (Absolute write)
    _env_val AS *_env_sp_addr
    
    # Increment SP and update
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

DEF s_get {
    AS _env_vvm_ptr
    AS _math_a # Register index

    # Read Register
    *_env_vvm_ptr VVM_regs + _math_a + AS _env_ptr
    *_env_ptr AS _env_val

    # Push to VVM Stack
    VVM_SP _env_vvm_ptr VVMpeek AS _env_sp_addr
    _env_val AS *_env_sp_addr
    _env_sp_addr 1 + VVM_SP _env_vvm_ptr VVMpoke
}

DEF s_set {
    AS _env_vvm_ptr
    AS _math_a # Register index

    # Pop Value from VVM Stack
    VVM_SP _env_vvm_ptr VVMpeek 1 - AS _env_sp_addr
    *_env_sp_addr AS _env_val
    _env_sp_addr VVM_SP _env_vvm_ptr VVMpoke

    # Write to Register
    *_env_vvm_ptr VVM_regs + _math_a + AS _env_ptr
    _env_val AS *_env_ptr
}

# there is no s_label needed on runtime

DEF s_bra {
    AS _env_vvm_ptr
    AS _math_a # target address

    # Set PC to target address
    _math_a VVM_PC _env_vvm_ptr VVMpoke
}

DEF s_brz {
    AS _env_vvm_ptr
    AS _math_a # target address

    # Pop value from VVM Stack
    VVM_SP _env_vvm_ptr VVMpeek 1 - AS _env_sp_addr
    *_env_sp_addr AS _env_val
    _env_sp_addr VVM_SP _env_vvm_ptr VVMpoke

    # Check condition
    _env_val 0 == IF
        _math_a VVM_PC _env_vvm_ptr VVMpoke
    END
}

DEF s_bnz {
    AS _env_vvm_ptr
    AS _math_a # target address

    # Pop value from VVM Stack
    VVM_SP _env_vvm_ptr VVMpeek 1 - AS _env_sp_addr
    *_env_sp_addr AS _env_val
    _env_sp_addr VVM_SP _env_vvm_ptr VVMpoke

    # Check condition
    _env_val 0 != IF
        _math_a VVM_PC _env_vvm_ptr VVMpoke
    END
}

DEF s_brp {
    AS _env_vvm_ptr
    AS _math_a # target address

    # Pop value from VVM Stack
    VVM_SP _env_vvm_ptr VVMpeek 1 - AS _env_sp_addr
    *_env_sp_addr AS _env_val
    _env_sp_addr VVM_SP _env_vvm_ptr VVMpoke

    # Check condition (Positive or Zero)
    _env_val 0 < 0 == IF
        _math_a VVM_PC _env_vvm_ptr VVMpoke
    END
}

DEF s_brn {
    AS _env_vvm_ptr
    AS _math_a # target address

    # Pop value from VVM Stack
    VVM_SP _env_vvm_ptr VVMpeek 1 - AS _env_sp_addr
    *_env_sp_addr AS _env_val
    _env_sp_addr VVM_SP _env_vvm_ptr VVMpoke

    # Check condition (Negative)
    _env_val 0 < IF
        _math_a VVM_PC _env_vvm_ptr VVMpoke
    END
}
# End of instruction handlers



# Setup SYSCALL handlers
DEF s_print_num {
    AS _env_vvm_ptr
    
    # Get Host Deque
    VVM_HOST_ptr _env_vvm_ptr VVMpeek AS _env_host_dq
    
    # Pop argument (number to print)
    # Use pop_tail to get the most recently pushed argument (LIFO)
    _env_host_dq DEQUE.pop_tail AS _env_val
    
    # Print it
    _env_val PRINT
    
}

DEF s_UDC_IO {

    AS _env_vvm_ptr
    
    # Get Host Deque
    VVM_HOST_ptr _env_vvm_ptr VVMpeek AS _env_host_dq
    
    # 1. Pop Command (Tail)
    _env_host_dq DEQUE.pop_tail AS _math_a
    
    # 2. Pop Channel
    _env_host_dq DEQUE.pop_tail AS _math_b
    
    # 3. Pop Value
    _env_host_dq DEQUE.pop_tail AS _env_val
    
    # 4. Execute IO ( Stack: Value Channel Command -- Result )
    # We use backticks to call the runtime routine directly.
    _env_val _math_b _math_a `rt_udc_control
    
    # 5. Result is on stack.
    # Only append to deque if command is INIT (0) or GET (12)
    _math_a 0 == _math_a 12 == + IF
         AS _env_val
         _env_val _env_host_dq DEQUE.append
    END
}

DEF s_print_char {

}

DEF s_read_num {

}

DEF s_read_char {

}

# End of syscall handlers


DEF VVM.init {
    100 DICT.new AS opcode_table
    100 NEW.list AS opcode_runtimes

    100 DICT.new AS label_addresses

    50 DICT.new AS syscall_table



    # System Opcodes
    _halt_ \"HALT" opcode_table DICT.put
    &s_halt _halt_ opcode_runtimes LIST.put
    _nop_ \"NOP" opcode_table DICT.put
    &s_nop _nop_ opcode_runtimes LIST.put
    _sys_ \"SYS" opcode_table DICT.put
    &s_sys _sys_ opcode_runtimes LIST.put
    _out_ \"OUT" opcode_table DICT.put
    &s_out _out_ opcode_runtimes LIST.put
    _fetch_ \"FETCH" opcode_table DICT.put
    &s_fetch _fetch_ opcode_runtimes LIST.put
    _ret_ \"RET" opcode_table DICT.put
    &s_ret _ret_ opcode_runtimes LIST.put

    # Stack Logic Opcodes
    _dup_ \"DUP" opcode_table DICT.put
    &s_dup _dup_ opcode_runtimes LIST.put
    _drop_ \"DROP" opcode_table DICT.put
    &s_drop _drop_ opcode_runtimes LIST.put
    _swap_ \"SWAP" opcode_table DICT.put
    &s_swap _swap_ opcode_runtimes LIST.put
    _over_ \"OVER" opcode_table DICT.put
    &s_over _over_ opcode_runtimes LIST.put

    # Math & Logic Opcodes
    _add_ \"ADD" opcode_table DICT.put
    &s_add _add_ opcode_runtimes LIST.put
    _sub_ \"SUB" opcode_table DICT.put
    &s_sub _sub_ opcode_runtimes LIST.put
    _mul_ \"MUL" opcode_table DICT.put
    &s_mul _mul_ opcode_runtimes LIST.put
    _div_ \"DIV" opcode_table DICT.put
    &s_div _div_ opcode_runtimes LIST.put
    _mod_ \"MOD" opcode_table DICT.put
    &s_mod _mod_ opcode_runtimes LIST.put
    _neg_ \"NEG" opcode_table DICT.put
    &s_neg _neg_ opcode_runtimes LIST.put
    _eq_ \"EQ" opcode_table DICT.put
    &s_eq _eq_ opcode_runtimes LIST.put
    _ne_ \"NE" opcode_table DICT.put
    &s_ne _ne_ opcode_runtimes LIST.put
    _lt_ \"LT" opcode_table DICT.put
    &s_lt _lt_ opcode_runtimes LIST.put
    _gt_ \"GT" opcode_table DICT.put
    &s_gt _gt_ opcode_runtimes LIST.put
    _abs_ \"ABS" opcode_table DICT.put
    &s_abs _abs_ opcode_runtimes LIST.put
    _rnd_ \"RND" opcode_table DICT.put
    &s_rnd _rnd_ opcode_runtimes LIST.put

    # Data Transfer Opcodes
    _push_ \"PUSH" opcode_table DICT.put
    &s_push _push_ opcode_runtimes LIST.put
    _get_ \"GET" opcode_table DICT.put
    &s_get _get_ opcode_runtimes LIST.put
    _set_ \"SET" opcode_table DICT.put
    &s_set _set_ opcode_runtimes LIST.put

    # Flow Control Opcodes
    _label_ \"LABEL" opcode_table DICT.put  # For transpiler only, no runtime handler
    _bra_ \"BRA" opcode_table DICT.put
    &s_bra _bra_ opcode_runtimes LIST.put
    _brz_ \"BRZ" opcode_table DICT.put
    &s_brz _brz_ opcode_runtimes LIST.put
    _bnz_ \"BNZ" opcode_table DICT.put
    &s_bnz _bnz_ opcode_runtimes LIST.put
    _brp_ \"BRP" opcode_table DICT.put
    &s_brp _brp_ opcode_runtimes LIST.put
    _brn_ \"BRN" opcode_table DICT.put
    &s_brn _brn_ opcode_runtimes LIST.put
    _call_ \"CALL" opcode_table DICT.put
    &s_call _call_ opcode_runtimes LIST.put



    # Syscalls
    &s_print_num  PRINT_NUM  syscall_table DICT.put
    &s_UDC_IO     UDC_IO     syscall_table DICT.put
    &s_print_char PRINT_CHAR syscall_table DICT.put
    &s_read_num   READ_NUM   syscall_table DICT.put
    &s_read_char  READ_CHAR  syscall_table DICT.put


}
