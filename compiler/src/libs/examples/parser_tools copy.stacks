USE std_stern_io 
# Standard Parser and Tokenizer Library
# --- Private variables for TOKENIZE ---
# These act as private, static variables for the TOKENIZE function,
# ensuring its internal state does not interfere with the main Data Stack.
VALUE _strtok_s 0 # Holds the pointer to the start of the string
VALUE _strtok_d 0 # Holds the delimiter character
VALUE _strtok_p 0 # Holds the current pointer during the loop
VALUE _strtok_c 0 # Holds the current character for comparison

# --- TOKENIZE ---
# Splits a string by a delimiter. Modifies the string in-place.
# This is a simple and self-contained implementation.
#
# Usage:
#   &string delimiter TOKENIZE
#
# Stack before: &string, delimiter_char
# Stack after:  &token, &rest_of_string
#
# If delimiter is not found, &rest_of_string will be 0.
DEF TOKENIZE {
    # Pop inputs from the Data Stack and store them in our private variables
    AS _strtok_d
    AS _strtok_s
    _strtok_s AS _strtok_p # Initialize the loop pointer to the start of the string

    :strtok_loop
        # Get the current character into a private variable. No stack usage.
        *_strtok_p AS _strtok_c
        
        # Check for the end of the string (null terminator).
        # This expression uses the stack temporarily but is balanced.
        _strtok_c 0 == IF
            _strtok_s # Push the token pointer (the original string)
            0         # Push a null pointer for the rest_of_string
            GOTO strtok_end
        END

        # Check if the current character is the delimiter.
        _strtok_c _strtok_d == IF
            # Found the delimiter. Replace it with a null terminator in memory.
            0 AS *_strtok_p
            
            # Push the results to the Data Stack.
            _strtok_s       # 1. The pointer to the token (the original start)
            _strtok_p 1 +   # 2. The pointer to the rest of the string
            GOTO strtok_end
        END
        
        # Not the delimiter, so increment the loop pointer and continue.
        _strtok_p 1 + AS _strtok_p
        GOTO strtok_loop

    :strtok_end
        # The two result pointers (&token, &rest_of_string) are now on the Data Stack.
}


# =============================================================================
# Bytecode Resources
# =============================================================================

# --- Bytecode Buffer ---
VAR bytecode_buffer 4096    # create buffer at adres 4096
VALUE bytecode_ptr 4096     # Pointer points to the start adres
VALUE current_opcode 1
VALUE current_value 1

# --- Opcodes ---
CONST OPC_END 0
CONST OPC_PUSH  1
CONST OPC_ADD   2
CONST OPC_PRINT 3
CONST OPC_UNKOWN 4
CONST OPC_USR 5
# ... more opcodes will be added here


## Uses
# value opcode WRITE_TO_BYTECODE
# or
# opcode WRITE_TO_BYTECODE
#
# 

# --- WRITE_TO_BYTECODE ---
# Handles opcodes with and without arguments.
# Expects [opcode] on stack for simple opcodes.
# Expects [value, opcode] on stack for opcodes with arguments.
DEF WRITE_TO_BYTECODE {
    AS current_opcode # Pop opcode, leave value (if any)

    # Check if the opcode is one that takes an argument
    current_opcode OPC_PUSH == IF
        AS current_value # Pop the value from the stack
        current_opcode AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        current_value AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        GOTO write_to_bytecode_end
    END


    current_opcode OPC_UNKOWN == IF
        AS current_value # Pop the value from the stack
        current_opcode AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        current_value AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        GOTO write_to_bytecode_end
    END

    # If not PUSH or UNKOWN, it's a simple opcode with no argument.
    # The stack should be empty now.
    current_opcode AS *bytecode_ptr
    bytecode_ptr 1 + AS bytecode_ptr
    
    :write_to_bytecode_end
}

# =============================================================================
# Bytecode Executor
# =============================================================================

##
# Start : &buffer_pointer EXECUTE_BYTECODE
# Program stops at OPC_END (null) termination
# No return values

VALUE bytecode_execution_ptr 4096
STRING ErrorMessage "Fatal error: for now,an invalid token \n"

DEF EXECUTE_BYTECODE {
    AS bytecode_execution_ptr

    :execution_loop
        # check for OPC_END, read the current opcode first
        *bytecode_execution_ptr AS current_opcode
        bytecode_execution_ptr 1 + AS bytecode_execution_ptr
        current_opcode OPC_END == IF
            GOTO execution_end
        END


        current_opcode OPC_PUSH == IF
            *bytecode_execution_ptr AS current_value
            bytecode_execution_ptr 1 + AS bytecode_execution_ptr
            current_value
            GOTO execution_loop
        END

        current_opcode OPC_USR == IF
            ASM {
                call @pop_A
                ld I A
                callx $_start_memory_
            }
            GOTO execution_loop
        END


        current_opcode OPC_ADD == IF
            +
            GOTO execution_loop
        END

        current_opcode OPC_PRINT == IF
            PRINT
            return PRTchar      # print an newline
            GOTO execution_loop
        END

        current_opcode OPC_UNKOWN == IF
            # An OPC_UNKOWN has a value, so we need to skip it
            &ErrorMessage PRTstring
            bytecode_execution_ptr 1 + AS bytecode_execution_ptr
            GOTO execution_loop
        END

        &ErrorMessage PRTstring
        GOTO execution_end # Stop execution on error

    :execution_end
        # Reset bytecode pointer for the next line of input
        # 4096 AS bytecode_ptr
}



