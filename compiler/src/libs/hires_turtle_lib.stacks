## High-Resolution Pixel-Based Turtle Graphics Library

CONST channel 2     ; Screen device
CONST mode 0        # 0: Pixel, 1: Sprite, 2: Pixel (DB), 3: Sprite (DB)
CONST DBmode 2      # double buffer mode is pixel mode

# --- Color Palette ---
CONST black 0
CONST white 1
CONST red 2
CONST cyan 3
CONST purple 4
CONST green 5
CONST blue 6
CONST yellow 7
CONST orange 8
CONST brown 9
CONST lightRed 10
CONST darkGray 11
CONST gray 12
CONST lightGreen 13
CONST lightBlue 14
CONST lightGray 15

# --- Screen & Turtle State ---
VALUE WIDTH  640
VALUE HEIGHT 480
VALUE TURTLE_CURRENT_COLOR 5 # Default to green

VALUE Xax 0
VALUE Yax 0
VALUE TURTLE_HEADING_DEG 0
VALUE TURTLE_HEADING 0
VALUE degrees_to_turn 0

VALUE dx 0                    # Variable for x change
VALUE dy 0                    # Variable for y change
VALUE distance 0              # Variable for forward distance
VALUE temp_ptr 0              # A temporary pointer for reading from memory


# --- Turtle Functions ---

# Turns the turtle right by a given number of degrees.
DEF TURTLE_right {
    AS degrees_to_turn
    TURTLE_HEADING_DEG degrees_to_turn + 360 % AS TURTLE_HEADING_DEG
}

# Turns the turtle left by a given number of degrees.
DEF TURTLE_left {
    AS degrees_to_turn
    360 TURTLE_HEADING_DEG + degrees_to_turn - 360 % AS TURTLE_HEADING_DEG
}

# Sets the current color for the turtle.
# Usage: color_value TURTLE_color
DEF TURTLE_color {
    AS TURTLE_CURRENT_COLOR
}

# Moves the turtle to a specific pixel coordinate and draws a pixel.
# Usage: x y TURTLE_goto
DEF TURTLE_goto {
    HEIGHT % DUP AS Yax IO 2 Y           # Read Y (TOS) from stack
    WIDTH  % DUP AS Xax IO 2 X           # Read X (TOS-1) from stack
    TURTLE_CURRENT_COLOR IO 2 DRAW       # Draw a pixel with the current color
}  

# Moves the turtle forward by a given distance in pixels.
# Usage: distance TURTLE_forward
DEF TURTLE_forward {
    AS distance

    distance 0 < IF GOTO move_end END

    # 1. Convert the precise degree heading to an 8-way heading for this move
    TURTLE_HEADING_DEG 22 + 45 // AS TURTLE_HEADING

    # 2. Get dx/dy for the calculated 8-way heading
    &TURTLE_DX TURTLE_HEADING + AS temp_ptr
    *temp_ptr AS dx
    &TURTLE_DY TURTLE_HEADING + AS temp_ptr
    *temp_ptr AS dy

    # 3. Loop `distance` times, moving one pixel at a time
    :move_loop
        distance 0 == IF GOTO move_end END

        Xax dx + AS Xax
        Yax dy + AS Yax

        Xax Yax TURTLE_goto

        distance 1 - AS distance
        GOTO move_loop
    :move_end
}

# Initializes the turtle system and screen.
DEF TURTLE_start {
    ASM {
        . $TURTLE_DX 8
        % $TURTLE_DX  1  1  0 -1 -1 -1  0  1
        . $TURTLE_DY 8
        % $TURTLE_DY  0  1  1  1  0 -1 -1 -1
    }
    IO 2 ONLINE           # Set screen online
    mode IO 2 MODE        # Set Device in Pixel Mode (Double Buffered)
}



# --- Advanced Drawing Functions (Line, Circle) ---
# These functions should work out-of-the-box with the new pixel mode
# as they rely on TURTLE_goto.

VALUE x1 0
VALUE y1 0
VALUE x2 0
VALUE y2 0
VALUE sx 0
VALUE sy 0
VALUE err 0
VALUE e2 0

# Draw a straight line from (x1,y1) to (x2,y2).
DEF TURTLE_line {
    AS y2
    AS x2
    AS y1
    AS x1

    x2 x1 - AS dx
    dx 0 < IF 0 1 - dx * AS dx END

    y2 y1 - AS dy
    dy 0 < IF 0 1 - dy * AS dy END

    0 1 - AS sx
    x1 x2 < IF 1 AS sx END

    0 1 - AS sy
    y1 y2 < IF 1 AS sy END

    0 1 - dy * AS dy
    dx dy + AS err

    :line_loop
        x1 y1 TURTLE_goto
        x1 x2 == IF y1 y2 == IF GOTO line_end END END
        err 2 * AS e2
        e2 dy < IF GOTO skip_x_move END
            err dy + AS err
            x1 sx + AS x1
        :skip_x_move
        e2 dx > IF GOTO skip_y_move END
            err dx + AS err
            y1 sy + AS y1
        :skip_y_move
        GOTO line_loop
    :line_end

    x2 AS Xax
    y2 AS Yax
}

VALUE circ_xc 0
VALUE circ_yc 0
VALUE circ_x 0
VALUE circ_y 0
VALUE circ_p 0

# Helper function to plot a point in all 8 octants of a circle
DEF _plot_circle_points {
    AS circ_y
    AS circ_x

    circ_xc circ_x + circ_yc circ_y + TURTLE_goto
    circ_xc circ_x - circ_yc circ_y + TURTLE_goto
    circ_xc circ_x + circ_yc circ_y - TURTLE_goto
    circ_xc circ_x - circ_yc circ_y - TURTLE_goto
    circ_xc circ_y + circ_yc circ_x + TURTLE_goto
    circ_xc circ_y - circ_yc circ_x + TURTLE_goto
    circ_xc circ_y + circ_yc circ_x - TURTLE_goto
    circ_xc circ_y - circ_yc circ_x - TURTLE_goto
}

# Draws a circle using the Midpoint Algorithm.
DEF TURTLE_circle {
    AS circ_p # Re-using circ_p for radius temporarily
    AS circ_yc
    AS circ_xc

    circ_p AS circ_x
    0 AS circ_y
    1 circ_p - AS circ_p

    :circle_loop
        circ_x circ_y _plot_circle_points
        circ_y 1 + AS circ_y
        0 circ_p > IF
            circ_p circ_y 2 * + 1 + AS circ_p
        ELSE
            circ_x 1 - AS circ_x
            circ_p circ_y 2 * + circ_x 2 * - 1 + AS circ_p
        END
        circ_x circ_y > IF GOTO circle_loop END

    circ_x circ_y _plot_circle_points
}
