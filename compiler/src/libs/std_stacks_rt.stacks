# The standard library to make the compiler work
# All default runtime routines, called from the Stack Compiler are here
# must be included at the Start of the bootloader file
## ##


DEF push_A {
    ASM {
        inc I $DATASTACK_INDEX  ; Load current stack pointer into I 
        stx A $DATASTACK_PTR    ; Store value from A at index I
    }
}

DEF pop_A {
    ASM {
        dec I $DATASTACK_INDEX  ; Load current stack pointer into I
        ldx A $DATASTACK_PTR    ; Load value from index I into A
    }
}

DEF push_B {
    ASM {
        inc I $DATASTACK_INDEX  ; Load current stack pointer into I 
        stx B $DATASTACK_PTR    ; Store value from B at index I
    }
}

DEF pop_B {
    ASM {
        dec I $DATASTACK_INDEX  ; Load current stack pointer into I
        ldx B $DATASTACK_PTR    ; Load value from index I into B
    }
}

DEF rt_add {
    ASM {
        call @pop_A
        call @pop_B
        add A B
        call @push_A
    }
}

DEF rt_sub {
    ASM {
        call @pop_A
        call @pop_B
        sub B A
        call @push_B
    }
}

DEF rt_mul {
    ASM {
        call @pop_A
        call @pop_B
        mul A B
        call @push_A
    }
}

DEF rt_div {
    ASM {
        call @pop_A
        call @pop_B
        dmod B A
        call @push_B
    }
}

DEF rt_mod {
    ASM {
        call @pop_A
        call @pop_B
        dmod B A
        call @push_A
    }
}

DEF rt_eq {
    ASM {
        call @pop_A
        call @pop_B
        tste A B
        jmpt :eq_true
        ldi A 0
        jmp :eq_end
    :eq_true
        ldi A 1
    :eq_end
        call @push_A
    }
}

DEF rt_neq {
    ASM {
        call @pop_A
        call @pop_B
        tste A B
        jmpf :neq_true
        ldi A 0
        jmp :neq_end
    :neq_true
        ldi A 1
    :neq_end
        call @push_A
    }
}

DEF rt_gt {
    ASM {
        call @pop_A
        call @pop_B
        tstg B A
        jmpt :gt_true
        ldi A 0
        jmp :gt_end
    :gt_true
        ldi A 1
    :gt_end
        call @push_A
    }
}

DEF rt_lt {
    ASM {
        call @pop_A
        call @pop_B
        tstg A B
        jmpt :lt_true
        ldi A 0
        jmp :lt_end
    :lt_true
        ldi A 1
    :lt_end
        call @push_A
    }
}

DEF rt_dup {
    ASM {
        call @pop_A
        call @push_A
        call @push_A
    }
}

DEF rt_swap {
    ASM {
        call @pop_A
        call @pop_B
        call @push_A
        call @push_B
    }
}

DEF rt_drop {
    ASM {
        call @pop_A
    }
}

DEF rt_over {
    ASM {
        call @pop_A
        call @pop_B
        call @push_B
        call @push_A
        call @push_B
    }
}

DEF rt_print_tos {
    ASM {
        call @pop_A
        ld C A

        ldi I ~SYS_PRINT_NUMBER
        int $INT_VECTORS

        ldi C \Return
        ldi I ~SYS_PRINT_CHAR
        int $INT_VECTORS
    }
}



DEF rt_udc_control {
    ASM {
        call @pop_B     ; Pop command code into B
        call @pop_A     
        ld M A          ; Save the Channel number
        call @pop_A
        ld C A          ; load data/arugumnet in C
        ld A M          ; load channel number in A

        ldi I ~SYS_UDC_CONTROL      ; Load the syscall number
        int $INT_VECTORS            ; call the kernel

        ; Check status and push return value for GET commands
        ldm A $SYSCALL_RETURN_STATUS
        tste A Z
        jmpf :rt_udc_ok
        ; Error handeling here, for now, just continue

    :rt_udc_ok  
        ; if command was GET, push the return value
        tst B ~UDC_DEVICE_GET
        jmpf :rt_udc_end        ; goto end if no return value

        ldm A $SYSCALL_RETURN_VALUE
        call @push_A            ; Push the return value on the datastack

    :rt_udc_end 
    }
}


# --- Pseudo-Random Number Generator (LCG) ---
# Inspired by simple generators like ZX81's.
# Formula: seed = (a * seed + c) % m

DEF rt_rnd {

    CONST rand_a 134775813
    CONST rand_c 1
    CONST rand_m 65536

    VALUE random_seed 54321
    
    random_seed rand_a * rand_c + rand_m % AS random_seed
    random_seed 1000 % 
}


