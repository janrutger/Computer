# The standard library to make the compiler work
# All default runtime routines, called from the Stack Compiler are here
# must be included at the Start of the bootloader file
## ##


# DEF push_A {
#     ASM {
#         # inc I $DATASTACK_INDEX  ; Load current stack pointer into I 
#         # stx A $DATASTACK_PTR    ; Store value from A at index I
#         stack A $DATASTACK_PTR
#     }
# }

# DEF pop_A {
#     ASM {
#         # dec I $DATASTACK_INDEX  ; Load current stack pointer into I
#         # ldx A $DATASTACK_PTR    ; Load value from index I into A
#         ustack A $DATASTACK_PTR
#     }
# }

# DEF push_B {
#     ASM {
#         # inc I $DATASTACK_INDEX  ; Load current stack pointer into I 
#         # stx B $DATASTACK_PTR    ; Store value from B at index I
#         stack B $DATASTACK_PTR
#     }
# }

# DEF pop_B {
#     ASM {
#         # dec I $DATASTACK_INDEX  ; Load current stack pointer into I
#         # ldx B $DATASTACK_PTR    ; Load value from index I into B
#         ustack B $DATASTACK_PTR
#     }
# }

# DEF rt_add {
#     ASM {
#         ustack A $DATASTACK_PTR
#         ustack B $DATASTACK_PTR
#         add A B
#         stack A $DATASTACK_PTR
#     }
# }

# DEF rt_sub {
#     ASM {
#         ustack A $DATASTACK_PTR
#         ustack B $DATASTACK_PTR
#         sub B A
#         stack B $DATASTACK_PTR
#     }
# }

# DEF rt_mul {
#     ASM {
#         ustack A $DATASTACK_PTR
#         ustack B $DATASTACK_PTR
#         mul A B
#         stack A $DATASTACK_PTR
#     }
# }

# DEF rt_div {
#     ASM {
#         ustack A $DATASTACK_PTR
#         ustack B $DATASTACK_PTR
#         dmod B A
#         stack B $DATASTACK_PTR
#     }
# }

# DEF rt_mod {
#     ASM {
#         ustack A $DATASTACK_PTR
#         ustack B $DATASTACK_PTR
#         dmod B A
#         stack A $DATASTACK_PTR
#     }
# }

DEF rt_eq {
    ASM {
        ustack A $DATASTACK_PTR
        ustack B $DATASTACK_PTR
        tste A B
        jmpt :eq_true
        ldi A 0
        jmp :eq_end
    :eq_true
        ldi A 1
    :eq_end
        stack A $DATASTACK_PTR
    }
}

DEF rt_neq {
    ASM {
        ustack A $DATASTACK_PTR
        ustack B $DATASTACK_PTR
        tste A B
        jmpf :neq_true
        ldi A 0
        jmp :neq_end
    :neq_true
        ldi A 1
    :neq_end
        stack A $DATASTACK_PTR
    }
}

DEF rt_gt {
    ASM {
        ustack A $DATASTACK_PTR
        ustack B $DATASTACK_PTR
        tstg B A
        jmpt :gt_true
        ldi A 0
        jmp :gt_end
    :gt_true
        ldi A 1
    :gt_end
        stack A $DATASTACK_PTR
    }
}

DEF rt_lt {
    ASM {
        ustack A $DATASTACK_PTR
        ustack B $DATASTACK_PTR
        tstg A B
        jmpt :lt_true
        ldi A 0
        jmp :lt_end
    :lt_true
        ldi A 1
    :lt_end
        stack A $DATASTACK_PTR
    }
}

DEF rt_dup {
    ASM {
        ustack A $DATASTACK_PTR
        stack A $DATASTACK_PTR
        stack A $DATASTACK_PTR
    }
}

DEF rt_swap {
    ASM {
        ustack A $DATASTACK_PTR
        ustack B $DATASTACK_PTR
        stack A $DATASTACK_PTR
        stack B $DATASTACK_PTR
    }
}

DEF rt_drop {
    ASM {
        ustack A $DATASTACK_PTR
    }
}

DEF rt_over {
    ASM {
        ustack A $DATASTACK_PTR
        ustack B $DATASTACK_PTR
        stack B $DATASTACK_PTR
        stack A $DATASTACK_PTR
        stack B $DATASTACK_PTR
    }
}

DEF rt_print_tos {
    ASM {
        ustack A $DATASTACK_PTR
        ld C A

        ldi I ~SYS_PRINT_NUMBER
        int $INT_VECTORS

        ldi C \Return
        ldi I ~SYS_PRINT_CHAR
        int $INT_VECTORS
    }
}



DEF rt_udc_control {
    ASM {
        ustack B $DATASTACK_PTR     ; Pop command code into B
        ustack A $DATASTACK_PTR     
        ld M A          ; Save the Channel number
        ustack A $DATASTACK_PTR
        ld C A          ; load data/arugumnet in C
        ld A M          ; load channel number in A

        ldi I ~SYS_UDC_CONTROL      ; Load the syscall number
        int $INT_VECTORS            ; call the kernel

        ; Check status and push return value for GET commands
        ldm A $SYSCALL_RETURN_STATUS
        tste A Z
        jmpf :rt_udc_ok
        ; Error handeling here, for now, just continue

    :rt_udc_ok  
        ; if command was GET, push the return value
        tst B ~UDC_DEVICE_GET
        jmpf :rt_udc_end        ; goto end if no return value

        ldm A $SYSCALL_RETURN_VALUE
        stack A $DATASTACK_PTR            ; Push the return value on the datastack

    :rt_udc_end 
    }
}


# --- Pseudo-Random Number Generator (LCG) ---
# Inspired by simple generators like ZX81's.
# Formula: seed = (a * seed + c) % m

DEF rt_rnd {

    CONST rand_a 134775813
    CONST rand_c 1
    CONST rand_m 65536

    VALUE random_seed 54321
    
    random_seed rand_a * rand_c + rand_m % AS random_seed
    random_seed 1000 % 
}