CONST channel 2     ; Screen device
# CONST mode 1        # 0: Pixel, 1: Sprite, 2: Pixel (DB), 3: Sprite (DB)
# CONST DBmode 3      # double buffer mode

CONST pixel 0
CONST sprite 1
CONST db_pixel 2
CONST db_sprite 3

CONST sprite_width  80
CONST sprite_height 60

CONST pixel_width  640
CONST pixel_height 480



# --- Color Palette ---



CONST black 0
CONST white 1
CONST red 2
CONST cyan 3
CONST purple 4
CONST green 5
CONST blue 6
CONST yellow 7
CONST orange 8
CONST brown 9
CONST lightRed 10
CONST darkGray 11
CONST gray 12
CONST lightGreen 13
CONST lightBlue 14
CONST lightGray 15


VALUE current_char 203      # inverse blank
VALUE current_mode 3
VALUE current_color 5
VALUE current_width 80
VALUE current_height 60
VALUE current_flip 1



## ALL UDC device instructions
# # Generic Commands
# 'INIT':    0, 
# 'ONLINE':  1, 
# 'OFFLINE': 2, 
# 'RESET':   3,
# # Device-Specific Commands
# 'NEW':    10, 
# 'SEND':   11, 
# 'GET':    12, 
# 'COLOR':  13, 
# 'MODE':   14,
# 'X':      15, 
# 'Y':      16, 
# 'DRAW':   17, 
# 'FLIP':   18,


VALUE Xax 0
VALUE Yax 0
VALUE degrees 0
VALUE TURTLE_HEADING_DEG 0
VALUE TURTLE_HEADING 0
VALUE degrees_to_turn 0

VALUE dx 0                    # Variable for x change
VALUE dy 0                    # Variable for y change
VALUE distance 0              # Variable for forward distance
VALUE temp_ptr 0              # A temporary pointer for reading from memory




#Draws on X-Axis, Y-Axis
DEF _drawTurtle {
    current_mode pixel == IF 
        current_color IO 2 DRAW
    ELSE
        current_char IO 2 DRAW
    END
}


DEF TURTLE.mode {
    DUP AS current_mode IO 2 MODE
    current_mode pixel  == IF 0 AS current_flip END
    current_mode sprite == IF 0 AS current_flip END

    current_mode db_pixel  == IF 
        pixel AS  current_mode 
        1  AS current_flip
    END

    current_mode db_sprite == IF 
        sprite AS current_mode 
        1  AS current_flip
    END

    current_mode pixel  == IF 
        pixel_height AS current_height   
        pixel_width  AS current_width 
    ELSE
        sprite_height AS current_height   
        sprite_width  AS current_width 
    END
}

DEF TURTLE.flip {
    current_flip IF IO 2 flip END
}


# Turns the turtle right by a given number of degrees.
# Note: This will snap to the nearest 45-degree direction.
DEF TURTLE.right {
    AS degrees_to_turn
    
    # Add to the precise degree heading, and wrap around 360
    TURTLE_HEADING_DEG degrees_to_turn + 360 % AS TURTLE_HEADING_DEG
}

# Turns the turtle left by a given number of degrees.
DEF TURTLE.left {
    AS degrees_to_turn

    # Subtract from the precise degree heading, with safe wrapping
    360 TURTLE_HEADING_DEG + degrees_to_turn - 360 % AS TURTLE_HEADING_DEG
}

# Expects color code on the stack
DEF TURTLE.color {
    DUP AS current_color IO 2 COLOR
}

# expects X,Y on the stack
DEF TURTLE.goto {
    current_height % DUP AS Yax IO 2 Y           # Read Y (TOS) from stack
    current_width  % DUP AS Xax IO 2 X           # Read X (TOS-1) from stack
    _drawTurtle
}  

# Moves the turtle forward by a given distance
# Usage: distance TURTLE_forward
DEF TURTLE.forward {
    AS distance

    # Prevent infinite loop on negative distance
    distance 0 < IF GOTO move_end END

    # 1. Convert the precise degree heading to an 8-way heading for this move
    TURTLE_HEADING_DEG 22 + 45 // AS TURTLE_HEADING

    # 2. Get dx/dy for the calculated 8-way heading
    &TURTLE_DX TURTLE_HEADING + AS temp_ptr
    *temp_ptr AS dx
    &TURTLE_DY TURTLE_HEADING + AS temp_ptr
    *temp_ptr AS dy

    # 3. Loop `distance` times, moving one step at a time
    :move_loop
        distance 0 == IF GOTO move_end END

        # Update turtle's position
        Xax dx + AS Xax
        Yax dy + AS Yax

        # Draw a character at the new position
        Xax Yax TURTLE.goto

        distance 1 - AS distance
        GOTO move_loop
    :move_end
}




DEF _welcome_at_turtle {
    STRING msg "* Welcome at TURTLE *"
    VALUE i_turtle 0
    VALUE char 0
    VALUE p_char 0 # Pointer for character lookup

    # Set starting position
    30 IO 2 X
    1 IO 2 Y
    

    :welcome_loop
        # Calculate character address and store it in p_char
        &msg i_turtle + AS p_char
        # Dereference the pointer to get the character
        *p_char AS char
        
        # Exit if end of string (null terminator)
        char 0 == IF GOTO welcome_end END

        # Draw the character
        char IO 2 DRAW
        
        # Move to next X position and increment character index
        30 i_turtle + 1 + IO 2 X
        i_turtle 1 + AS i_turtle
        GOTO welcome_loop

    :welcome_end
    IO 2 FLIP
}


DEF TURTLE.start {
    ASM {
    . $TURTLE_DX 8
    % $TURTLE_DX  1  1  0 -1 -1 -1  0  1
    . $TURTLE_DY 8
    % $TURTLE_DY  0  1  1  1  0 -1 -1 -1
}
    IO 2 ONLINE                 # Set screen online
    current_mode  IO 2 MODE     # Set Device in Sprite mode
    current_color IO 2 COLOR    # set an default color     

    _welcome_at_turtle
}



VALUE x1 0
VALUE y1 0
VALUE x2 0
VALUE y2 0
VALUE sx 0
VALUE sy 0
VALUE err 0
VALUE e2 0


# Draw a straight (as possible) line from (x1,y1) to (x2,y2).
# This version avoids using <= or >=; it uses only <, >, == and !=.
# Usage: x1 y1 x2 y2 TURTLE_line
DEF TURTLE.line {
    # pop all four coordinates from the stack.
    # Stack order: ... x1 y1 x2 y2
    AS y2
    AS x2
    AS y1
    AS x1

    # dx = abs(x2 - x1)
    x2 x1 - AS dx
    dx 0 < IF 0 1 - dx * AS dx END

    # dy = abs(y2 - y1)
    y2 y1 - AS dy
    dy 0 < IF 0 1 - dy * AS dy END

    # compute step directions: default -1, set to 1 if start < end
    0 1 - AS sx
    x1 x2 < IF 1 AS sx END

    0 1 - AS sy
    y1 y2 < IF 1 AS sy END

    # convert dy to negative for the algorithm (err = dx + dy where dy is negative)
    0 1 - dy * AS dy

    # err = dx + dy
    dx dy + AS err

    :line_loop
        # draw current point
        x1 y1 TURTLE.goto

        # if we've reached the end, break out
        x1 x2 == IF
            y1 y2 == IF GOTO line_end END
        END

        # e2 = 2*err
        err 2 * AS e2

        # if e2 >= dy then move in x
        # translate "e2 >= dy" into "NOT (e2 < dy)" using a conditional skip
        e2 dy < IF GOTO skip_x_move END
            err dy + AS err
            x1 sx + AS x1
        :skip_x_move

        # if e2 <= dx then move in y
        # translate "e2 <= dx" into "NOT (e2 > dx)" using a conditional skip
        e2 dx > IF GOTO skip_y_move END
            err dx + AS err
            y1 sy + AS y1
        :skip_y_move

        GOTO line_loop
    :line_end

    # set global turtle position to endpoint
    x2 AS Xax
    y2 AS Yax
}



VALUE circ_xc 0
VALUE circ_yc 0
VALUE circ_x 0
VALUE circ_y 0
VALUE circ_p 0

# Helper function to plot a point in all 8 octants of a circle
DEF _plot_circle_points {
    # Expects x, y on the stack (relative to center)
    AS circ_y
    AS circ_x

    circ_xc circ_x + circ_yc circ_y + TURTLE.goto
    circ_xc circ_x - circ_yc circ_y + TURTLE.goto
    circ_xc circ_x + circ_yc circ_y - TURTLE.goto
    circ_xc circ_x - circ_yc circ_y - TURTLE.goto
    circ_xc circ_y + circ_yc circ_x + TURTLE.goto
    circ_xc circ_y - circ_yc circ_x + TURTLE.goto
    circ_xc circ_y + circ_yc circ_x - TURTLE.goto
    circ_xc circ_y - circ_yc circ_x - TURTLE.goto
}

# Draws a circle using the Midpoint Algorithm.
# Usage: xc yc radius TURTLE_circle
DEF TURTLE.circle {
    # Pop arguments from stack
    AS circ_p # Re-using circ_p for radius temporarily
    AS circ_yc
    AS circ_xc

    # Initialize variables
    circ_p AS circ_x  # x = radius
    0 AS circ_y
    1 circ_p - AS circ_p # P = 1 - radius

    :circle_loop
        # Plot current points for all 8 octants
        circ_x circ_y _plot_circle_points

        circ_y 1 + AS circ_y

        # Update decision parameter P
        #circ_p 0 <= IF
        0 circ_p > IF
            # P = P + 2*y + 1
            circ_p circ_y 2 * + 1 + AS circ_p
        ELSE
            # x is decremented
            circ_x 1 - AS circ_x
            # P = P + 2*y - 2*x + 1
            circ_p circ_y 2 * + circ_x 2 * - 1 + AS circ_p
        END

        # Loop while x > y
        circ_x circ_y > IF GOTO circle_loop END

    # The final point where x == y
    circ_x circ_y _plot_circle_points
}

    



