USE std_stern_io 
USE disk_utils

# Standard Parser and Tokenizer Library
# --- Private variables for TOKENIZE ---
# These act as private, static variables for the TOKENIZE function,
# ensuring its internal state does not interfere with the main Data Stack.
VALUE _strtok_s 0 # Holds the pointer to the start of the string
VALUE _strtok_d 0 # Holds the delimiter character
VALUE _strtok_p 0 # Holds the current pointer during the loop
VALUE _strtok_c 0 # Holds the current character for comparison

# --- TOKENIZE ---
# Splits a string by a delimiter. Modifies the string in-place.
# This is a simple and self-contained implementation.
#
# Usage:
#   &string delimiter TOKENIZE
#
# Stack before: &string, delimiter_char
# Stack after:  &token, &rest_of_string
#
# If delimiter is not found, &rest_of_string will be 0.
DEF TOKENIZE {
    # Pop inputs from the Data Stack and store them in our private variables
    AS _strtok_d
    AS _strtok_s

    # Advance _strtok_s past any leading delimiters
    :skip_delimiters_loop
        *_strtok_s AS _strtok_c
        _strtok_c 0 == IF
            # End of string, so no token
            0 # Push a null pointer for the token
            0 # Push a null pointer for the rest_of_string
            GOTO strtok_end
        END
        _strtok_c _strtok_d != IF
            # Found start of token
            GOTO find_end_of_token
        END
        _strtok_s 1 + AS _strtok_s
        GOTO skip_delimiters_loop

    :find_end_of_token
        # _strtok_s now points to the start of the token
        _strtok_s AS _strtok_p # Use _strtok_p to scan for the end

    :scan_loop
        *_strtok_p AS _strtok_c
        _strtok_c 0 == IF
            # End of string is end of token
            _strtok_s # Push the token pointer
            0         # Push a null pointer for the rest_of_string
            GOTO strtok_end
        END
        _strtok_c _strtok_d == IF
            # Found end of token
            0 AS *_strtok_p
            _strtok_s       # 1. The pointer to the token
            _strtok_p 1 +   # 2. The pointer to the rest of the string
            GOTO strtok_end
        END
        _strtok_p 1 + AS _strtok_p
        GOTO scan_loop

    :strtok_end
        # The two result pointers (&token, &rest_of_string) are now on the Data Stack.
}


# =============================================================================
# Bytecode Resources
# =============================================================================

# --- Bytecode Buffer ---
VAR bytecode_buffer 3584    # create buffer at adres 4096 - 512
VALUE bytecode_ptr 3584     # Pointer points to the start adres
VALUE current_opcode 1
VALUE current_value 1

# --- Opcodes ---
CONST OPC_END 0
CONST OPC_PUSH  1
CONST OPC_ADD   2
CONST OPC_PRINT 3
CONST OPC_UNKOWN 4
CONST OPC_USR 5
CONST OPC_STRING 6
CONST OPC_LOAD_FROM_DISK 7
CONST OPC_STACKINFO 8
# ... more opcodes will be added here


## Uses
# value opcode WRITE_TO_BYTECODE
# or
# opcode WRITE_TO_BYTECODE
#
# 

# --- WRITE_TO_BYTECODE ---
# Handles opcodes with and without arguments.
# Expects [opcode] on stack for simple opcodes.
# Expects [value, opcode] on stack for opcodes with arguments.
DEF WRITE_TO_BYTECODE {
    AS current_opcode # Pop opcode, leave value (if any)

    # Check if the opcode is one that takes an argument
    current_opcode OPC_PUSH == IF
        AS current_value # Pop the value from the stack
        current_opcode AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        current_value AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        GOTO write_to_bytecode_end
    END


    current_opcode OPC_UNKOWN == IF
        AS current_value # Pop the value from the stack
        current_opcode AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        current_value AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        GOTO write_to_bytecode_end
    END

    current_opcode OPC_STRING == IF
        AS current_value # Pop the value from the stack
        current_opcode AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        current_value AS *bytecode_ptr
        bytecode_ptr 1 + AS bytecode_ptr
        GOTO write_to_bytecode_end
    END

    # If not PUSH or UNKOWN/STRING, it's a simple opcode with no argument.
    # The stack should be empty now.
    current_opcode AS *bytecode_ptr
    bytecode_ptr 1 + AS bytecode_ptr
    
    :write_to_bytecode_end
}

# =============================================================================
# Bytecode Executor
# =============================================================================

##
# Start : &buffer_pointer EXECUTE_BYTECODE
# Program stops at OPC_END (null) termination
# No return values

VALUE bytecode_execution_ptr 3584
STRING ErrorMessage "Fatal error: an invalid token \n"
STRING InfoMessage0 "Total items on the stack: "
STRING InfoMessage1 "First value on the stack: "

DEF EXECUTE_BYTECODE {
    AS bytecode_execution_ptr

    :execution_loop
        # check for OPC_END, read the current opcode first
        *bytecode_execution_ptr AS current_opcode
        bytecode_execution_ptr 1 + AS bytecode_execution_ptr
        current_opcode OPC_END == IF
            GOTO execution_end
        END


        current_opcode OPC_PUSH == IF
            *bytecode_execution_ptr AS current_value
            bytecode_execution_ptr 1 + AS bytecode_execution_ptr
            current_value
            GOTO execution_loop
        END

        current_opcode OPC_STRING == IF
            *bytecode_execution_ptr AS current_value
            bytecode_execution_ptr 1 + AS bytecode_execution_ptr
            current_value
            GOTO execution_loop
        END

        current_opcode OPC_USR == IF
            ASM {
                ustack A $DATASTACK_PTR
                ld I A
                callx $_start_memory_
            }
            GOTO execution_loop
        END

        current_opcode OPC_LOAD_FROM_DISK == IF
            # "Load from disk routine " 
            # Expects an filename string pointer on the datastack

            DUP PRTstring 13 PRTchar
     
            load_bin_file

            GOTO execution_loop
        END


        current_opcode OPC_ADD == IF
            +
            GOTO execution_loop
        END

        current_opcode OPC_PRINT == IF
            PRINT
            # return PRTchar      # print an newline
            GOTO execution_loop
        END

        current_opcode OPC_STACKINFO == IF
            TOS.check IF
                TOS.check &InfoMessage0 PRTstring PRINT     ; Print stack depth
                DUP &InfoMessage1 PRTstring PRINT           ; Print first value (TOS)
            ELSE
                0 &InfoMessage0 PRTstring PRINT
            END
            GOTO execution_loop
        END


        current_opcode OPC_UNKOWN == IF
            # An OPC_UNKOWN has a value, so we need to skip it
            &ErrorMessage PRTstring
            bytecode_execution_ptr 1 + AS bytecode_execution_ptr
            GOTO execution_loop
        END

        &ErrorMessage PRTstring
        GOTO execution_end # Stop execution on error

    :execution_end
        
}



