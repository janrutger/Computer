# Stacks Game engine

USE std_stern_io
#USE std_time
USE std_string

# All colors
CONST black 0
CONST white 1
CONST red 2
CONST cyan 3
CONST purple 4
CONST green 5
CONST blue 6
CONST yellow 7
CONST orange 8
CONST brown 9
CONST lightRed 10
CONST darkGray 11
CONST gray 12
CONST lightGreen 13
CONST lightBlue 14
CONST lightGray 15

CONST WIDTH  80
CONST HEIGHT 60
VALUE current_x 0
VALUE current_y 0
VALUE current_color 1
CONST solid_block 203
CONST star 42
CONST pacman 200
CONST wall 201


CONST up    56 ; key '8'
CONST down  50 ; key '2'
CONST left  52 ; key '4'
CONST right 54 ; key '6'
CONST exit  27 ; <esc> key



VALUE background 0  ; black
VALUE foreground 5  ; green
VALUE score 0

# to keep track of mulitple tiles we need some bookkeeping
# We need to keep track of 7 items of tile information
CONST TILE_X 0
CONST TILE_Y 1
CONST TILE_OLD_X 2
CONST TILE_OLD_Y 3
CONST TILE_IS_MOVED 4
CONST TILE_COLOR 5
CONST TILE_DATA 6
CONST TILE_REACTION 7   # How this tile reacts to being hit
CONST TILE_REPLACE_DATA_PTR 8 # Pointer to replacement data
CONST TILE_OLD_W 9 # Old width for erasing
CONST TILE_OLD_H 10 # Old height for erasing

CONST NO_X 0
CONST NO_Y 200
CONST TILE_OBJ_SIZE 11     # The total size of one tile object structure

# Reaction Codes
CONST REACT_BLOCK 0
CONST REACT_OVERWRITE 1
CONST REACT_REPLACE 2

# Gameplay Event Codes (the factual report from process_events)
CONST GAME_EVENT_NONE 0
CONST GAME_EVENT_BLOCK_ACTION 1
CONST GAME_EVENT_OVERWRITE_ACTION 2
CONST GAME_EVENT_REPLACE_ACTION 3

; --- NEGATE ---
; negate TOS
; ( val -- res )
DEF _negate {
    0 SWAP -
}


# Create the TILE_INFO structure
CONST MAX_TILES 8
VALUE active_tile_count 0
# Each Tile needs TILE_OBJ_SIZE items, and we have MAX_TILES tiles
VALUE tile_info 0

VALUE KEYBOARD_TILE 0       

VALUE replace_ptr_new 0
VALUE reaction_new 0
VALUE color_new 0
VALUE data_ptr_new 0
VALUE start_y_new 0
VALUE start_x_new 0
VALUE tile_id 0

VALUE temp_ptr 0
VALUE temp_ptr2 0
VALUE initial_w 0
VALUE initial_h 0
VALUE item_pointer 0
VALUE tile_base_prt 0
VALUE sprite_id 0
VALUE shape_h 0
VALUE shape_w 0
VALUE start_y 0
VALUE start_x 0
VALUE rect_y 0
VALUE rect_x 0
VALUE tile_ptr 0
VALUE tile_w 0
VALUE tile_h 0
VALUE loop_y 0
VALUE loop_x 0
VALUE moving_tile_id 0
VALUE pot_y 0
VALUE pot_x 0
VALUE pot_w 0
VALUE pot_h 0
VALUE collision_found 0
VALUE moving_data_ptr 0
VALUE i 0
VALUE other_tile_ptr 0
VALUE other_data_ptr 0
VALUE other_x 0
VALUE other_y 0
VALUE other_w 0
VALUE other_h 0
VALUE KEYvalue 0
VALUE active_tile_ptr 0
VALUE collided_id 0
VALUE any_tile_moved 0
VALUE tile_obj_ptr 0
VALUE is_moved 0
VALUE old_x 0
VALUE old_y 0
VALUE old_w 0
VALUE old_h 0
VALUE data_ptr 0
VALUE new_x 0
VALUE new_y 0
VALUE current_h 0
VALUE current_w 0
VALUE replace_data_ptr 0
VALUE new_data_ptr 0
VALUE new_color 0
VALUE new_reaction 0
VALUE actor_ptr 0
VALUE cooldown 0
VALUE timer_ptr 0
VALUE new_sprite_data_ptr 0
VALUE replacement_data_ptr 0

LIST TILE_INFO 88 # 8 * 11

VALUE EVENT_TYPE 0
VALUE EVENT_TARGET 0
VALUE EVENT_ACTOR 0
VALUE EVENT_POTENTIAL_X 0
VALUE EVENT_POTENTIAL_Y 0

VALUE running 0

DEF init_game_lib {
    IO 2 ONLINE                 # HW screen configuration
    IO 2 NEW
    3 IO 2 MODE    

    &TILE_INFO AS tile_info     # Pointer to Tile Information structure
    
    1 _negate AS EVENT_TYPE
    1 _negate AS EVENT_TARGET
    1 _negate AS EVENT_ACTOR
    1 _negate AS EVENT_POTENTIAL_X
    1 _negate AS EVENT_POTENTIAL_Y
}

# Initializes a single tile object in the TILE_INFO list.
# Expects on stack: tile_id, start_x, start_y, data_ptr, color, reaction, replace_ptr
DEF GAME.init_tile {
    AS replace_ptr_new
    AS reaction_new
    AS color_new
    AS data_ptr_new
    AS start_y_new
    AS start_x_new
    AS tile_id

    # Get initial width and height from data pointer
    0 AS temp_ptr
    *data_ptr_new AS initial_w
    data_ptr_new 1 + AS temp_ptr
    *temp_ptr AS initial_h

    0 AS item_pointer

    # Calculate the base address for this tile object
    tile_info tile_id TILE_OBJ_SIZE * + AS tile_base_prt

    # Set values using the base pointer and field offsets
    tile_base_prt TILE_X + AS item_pointer           # Current X.Y
    start_x_new AS *item_pointer
    tile_base_prt TILE_Y + AS item_pointer
    start_y_new AS *item_pointer

    tile_base_prt TILE_OLD_X + AS item_pointer       # Old X.Y
    start_x_new AS *item_pointer
    tile_base_prt TILE_OLD_Y + AS item_pointer
    start_y_new AS *item_pointer

    tile_base_prt TILE_OLD_W + AS item_pointer       # Old W/H
    initial_w AS *item_pointer
    tile_base_prt TILE_OLD_H + AS item_pointer
    initial_h AS *item_pointer

    tile_base_prt TILE_IS_MOVED + AS item_pointer    # Moving flag
    1 AS *item_pointer                              # Set to 1 to always flag for redraw

    tile_base_prt TILE_COLOR + AS item_pointer       # Color flag
    color_new AS *item_pointer

    tile_base_prt TILE_DATA + AS item_pointer        # Data pointer to draw
    data_ptr_new AS *item_pointer

    tile_base_prt TILE_REACTION + AS item_pointer    # Reaction type
    reaction_new AS *item_pointer

    tile_base_prt TILE_REPLACE_DATA_PTR + AS item_pointer # Replacement data pointer
    replace_ptr_new AS *item_pointer
}

# Draws a rectangular shape of sprites.
# Expects on stack: start_x, start_y, width, height, sprite_id
DEF clear_rect {
    AS sprite_id
    AS shape_h
    AS shape_w
    AS start_y
    AS start_x

    0 AS rect_y
    start_y AS rect_y
    WHILE rect_y start_y shape_h + < DO
        rect_y IO 2 Y
        0 AS rect_x
        start_x AS rect_x
        WHILE rect_x start_x shape_w + < DO
            rect_x IO 2 X
            sprite_id IO 2 DRAW
            rect_x 1 + AS rect_x
        DONE
        rect_y 1 + AS rect_y
    DONE
}

# Draws a tile defined in a LIST.
# Expects on stack: start_x, start_y, tile_ptr
DEF draw_tile_from_data {
    AS tile_ptr
    AS start_y
    AS start_x

    0 AS temp_ptr # Temporary pointer for calculations

    # Read width and height from the tile data
    *tile_ptr AS tile_w
    tile_ptr 1 + AS temp_ptr
    *temp_ptr AS tile_h

    0 AS loop_y
    WHILE loop_y tile_h < DO
        0 AS loop_x
        WHILE loop_x tile_w < DO
            # Calculate index: data_offset = 2 + (y * width) + x
            tile_ptr loop_y tile_w * loop_x + 2 + + AS temp_ptr
            *temp_ptr AS sprite_id

            sprite_id IF # Draw only if sprite_id is not 0 (transparent)
                start_x loop_x + IO 2 X
                start_y loop_y + IO 2 Y
                sprite_id IO 2 DRAW
            END
            loop_x 1 + AS loop_x
        DONE
        loop_y 1 + AS loop_y
    DONE
}

# Checks if a tile at a potential new position collides with any other tile.
# Expects on stack: potential_x, potential_y, moving_tile_id
# Returns: 1 if collision detected, 0 otherwise.
# Returns: collided_tile_id if collision detected, -1 otherwise.
DEF check_collision {
    AS moving_tile_id
    AS pot_y  # potential y
    AS pot_x  # potential x

    0 AS collision_found # Return value flag, default to 0 (no collision)
    0 AS temp_ptr
    # Get dimensions of the moving tile
    tile_info moving_tile_id TILE_OBJ_SIZE * + TILE_DATA + AS temp_ptr
    *temp_ptr AS moving_data_ptr
    *moving_data_ptr AS pot_w # potential width
    moving_data_ptr 1 + AS temp_ptr
    *temp_ptr AS pot_h # potential height

    0 AS i
    WHILE i active_tile_count < DO # Loop through all active tiles
        i moving_tile_id != IF # Don't check a tile against itself
            # Get properties of the other tile
            tile_info i TILE_OBJ_SIZE * + AS other_tile_ptr
            other_tile_ptr TILE_X + AS temp_ptr
            *temp_ptr AS other_x
            other_tile_ptr TILE_Y + AS temp_ptr
            *temp_ptr AS other_y
            other_tile_ptr TILE_DATA + AS temp_ptr
            *temp_ptr AS other_data_ptr
            *other_data_ptr AS other_w
            other_data_ptr 1 + AS temp_ptr
            *temp_ptr AS other_h

            # AABB Collision Check Logic:
            # A collision does NOT exist if any of these are true:
            # 1. Moving box is entirely to the left of the other box.
            pot_x pot_w + 1 - other_x < IF GOTO no_collision_found END
            # 2. Moving box is entirely to the right of the other box.
            other_x other_w + 1 - pot_x < IF GOTO no_collision_found END
            # 3. Moving box is entirely above the other box.
            pot_y pot_h + 1 - other_y < IF GOTO no_collision_found END
            # 4. Moving box is entirely below the other box.
            other_y other_h + 1 - pot_y < IF GOTO no_collision_found END

            # If none of the above are true, the boxes are overlapping.
            # Return the ID of the tile we collided with.
            i GOTO collision_check_end # Exit loop and function

            :no_collision_found
        END
        i 1 + AS i
    DONE

    # No collision found after checking all tiles. Return -1.
    1 _negate

    :collision_check_end
    # The return value (collided_id or -1) is now on the stack.
}

# VALUE EVENT_TYPE 0
# VALUE EVENT_TARGET 0
# VALUE EVENT_ACTOR 0
# VALUE EVENT_POTENTIAL_X 0
# VALUE EVENT_POTENTIAL_Y 0

# Handles keyboard input to move the active tile
DEF GAME.handle_input {
    KEYpressed IF
        AS KEYvalue

        tile_info KEYBOARD_TILE TILE_OBJ_SIZE * + AS active_tile_ptr
        0 AS temp_ptr
        active_tile_ptr TILE_X + AS temp_ptr
        *temp_ptr AS current_x
        active_tile_ptr TILE_Y + AS temp_ptr
        *temp_ptr AS current_y

        # Reset event from previous frame
        1 _negate AS EVENT_TYPE

        KEYvalue up    == IF current_y 1 - AS current_y END
        KEYvalue down  == IF current_y 1 + AS current_y END
        KEYvalue left  == IF current_x 1 - AS current_x END
        KEYvalue right == IF current_x 1 + AS current_x END
        KEYvalue exit  == IF 0 AS running END

        # Check for collision at the potential new position
        current_x current_y KEYBOARD_TILE check_collision
        AS collided_id
        collided_id 1 _negate == IF # If no collision...
            # Commit the move
            active_tile_ptr TILE_X + AS temp_ptr
            current_x AS *temp_ptr
            active_tile_ptr TILE_Y + AS temp_ptr
            current_y AS *temp_ptr
            active_tile_ptr TILE_IS_MOVED + AS temp_ptr
            1 AS *temp_ptr
        END
        collided_id 1 _negate != IF # If a collision occurred...
            # Post an event for the main loop to process.
            # Do NOT move the tile.
            KEYBOARD_TILE AS EVENT_ACTOR
            collided_id AS EVENT_TARGET

            # Get the reaction type from the tile that was hit
            tile_info collided_id TILE_OBJ_SIZE * + TILE_REACTION + AS temp_ptr
            *temp_ptr AS EVENT_TYPE
            current_x AS EVENT_POTENTIAL_X
            current_y AS EVENT_POTENTIAL_Y
        END
    END
}

# Redraws all tiles that have moved since the last frame
DEF GAME.redraw_all_moved_tiles {
    0 AS i
    0 AS any_tile_moved
    0 AS temp_ptr

    # --- Erase all moved tiles first ---
    WHILE i active_tile_count < DO # Loop through all active tiles
        tile_info i TILE_OBJ_SIZE * + AS tile_obj_ptr
        tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
        *temp_ptr AS is_moved

        is_moved IF
            1 AS any_tile_moved
            background IO 2 COLOR
            
            0 AS temp_ptr2 # Use a separate temp variable to avoid corruption
            tile_obj_ptr TILE_OLD_X + AS temp_ptr2
            *temp_ptr2 AS old_x
            tile_obj_ptr TILE_OLD_Y + AS temp_ptr2
            *temp_ptr2 AS old_y
            tile_obj_ptr TILE_OLD_W + AS temp_ptr2
            *temp_ptr2 AS old_w
            tile_obj_ptr TILE_OLD_H + AS temp_ptr2
            *temp_ptr2 AS old_h
            # Clear the old tile's rectangular area using its old dimensions
            old_x old_y old_w old_h solid_block clear_rect
        END
        i 1 + AS i
    DONE

    # --- Draw all moved tiles in their new positions ---
    0 AS i
    WHILE i active_tile_count < DO # Loop through all active tiles
        tile_info i TILE_OBJ_SIZE * + AS tile_obj_ptr
        tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
        *temp_ptr AS is_moved

        is_moved IF
            tile_obj_ptr TILE_COLOR + AS temp_ptr
            *temp_ptr IO 2 COLOR
            
            tile_obj_ptr TILE_DATA + AS temp_ptr
            *temp_ptr AS data_ptr
            
            tile_obj_ptr TILE_X + AS temp_ptr
            *temp_ptr AS new_x
            tile_obj_ptr TILE_Y + AS temp_ptr
            *temp_ptr AS new_y
            new_x new_y data_ptr draw_tile_from_data

            # Update old coords and reset flag
            tile_obj_ptr TILE_OLD_X + AS temp_ptr
            new_x AS *temp_ptr
            tile_obj_ptr TILE_OLD_Y + AS temp_ptr
            new_y AS *temp_ptr
            tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
            0 AS *temp_ptr

            # Get current width/height and store them as OLD for the next frame
            0 AS temp_ptr2
            *data_ptr AS current_w
            data_ptr 1 + AS temp_ptr2
            *temp_ptr2 AS current_h
            tile_obj_ptr TILE_OLD_W + AS temp_ptr2
            current_w AS *temp_ptr2
            tile_obj_ptr TILE_OLD_H + AS temp_ptr2
            current_h AS *temp_ptr2
        END
        i 1 + AS i
    DONE

    # --- Flip the buffer once if anything was redrawn ---
    any_tile_moved IF
        IO 2 FLIP
    END
}

# Draws a single tile specified by its ID. Does NOT flip the buffer.
# Expects on stack: tile_id
DEF draw_tile_by_id {
    AS tile_id
    0 AS temp_ptr

    # Get the base pointer for the specified tile object
    tile_info tile_id TILE_OBJ_SIZE * + AS tile_obj_ptr

    # Get color, data pointer, and coordinates, then draw.
    tile_obj_ptr TILE_COLOR + AS temp_ptr
    *temp_ptr IO 2 COLOR
    tile_obj_ptr TILE_DATA + AS temp_ptr
    *temp_ptr AS data_ptr
    tile_obj_ptr TILE_X + AS temp_ptr
    *temp_ptr AS current_x
    tile_obj_ptr TILE_Y + AS temp_ptr
    *temp_ptr AS current_y
    
    current_x current_y data_ptr draw_tile_from_data
}


# "Deletes" a tile by moving it off-screen.
# This function marks the tile as moved and sets its coordinates
# to a position outside the visible area.
# Expects on stack: tile_id
DEF delete_tile {
    AS tile_id
    0 AS temp_ptr

    # Get the base pointer for the specified tile object
    tile_info tile_id TILE_OBJ_SIZE * + AS tile_obj_ptr

    # Set the new coordinates to be off-screen
    tile_obj_ptr TILE_X + AS temp_ptr
    NO_X AS *temp_ptr
    tile_obj_ptr TILE_Y + AS temp_ptr
    NO_Y AS *temp_ptr # Move far below the screen (HEIGHT is 60)

    # Mark the tile as moved so it gets erased from its old position
    tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
    1 AS *temp_ptr
}

# Replaces a tile's properties based on its replacement data pointer.
# Expects on stack: tile_id
DEF replace_tile {
    AS tile_id
    0 AS temp_ptr

    # Get the base pointer for the tile to be replaced
    tile_info tile_id TILE_OBJ_SIZE * + AS tile_obj_ptr

    # Get the pointer to the replacement data structure
    tile_obj_ptr TILE_REPLACE_DATA_PTR + AS temp_ptr
    *temp_ptr AS replace_data_ptr

    # Read new properties from the replacement data structure
    *replace_data_ptr AS new_data_ptr
    replace_data_ptr 1 + AS temp_ptr
    *temp_ptr AS new_color
    replace_data_ptr 2 + AS temp_ptr
    *temp_ptr AS new_reaction

    # Write the new properties into the tile object
    tile_obj_ptr TILE_DATA + AS temp_ptr
    new_data_ptr AS *temp_ptr
    tile_obj_ptr TILE_COLOR + AS temp_ptr
    new_color AS *temp_ptr
    tile_obj_ptr TILE_REACTION + AS temp_ptr
    new_reaction AS *temp_ptr

    # Mark the tile as moved so it gets redrawn with its new look
    tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
    1 AS *temp_ptr
}

# Draws all tiles at their current position, regardless of moved status.
# Useful for the initial screen draw.
DEF draw_all_tiles {
    0 AS i
    WHILE i active_tile_count < DO # Loop through all active tiles
        i draw_tile_by_id
        i 1 + AS i
    DONE

    IO 2 FLIP # Flip the buffer to make the initial drawing visible
}

DEF GAME.process_events {
    EVENT_TYPE 1 _negate != IF # Check if an event occurred
        # --- BLOCK REACTION ---
        EVENT_TYPE REACT_BLOCK == IF
            # Mechanic: Do nothing.
            # Report: A BLOCK action occurred.
            GAME_EVENT_BLOCK_ACTION EVENT_TARGET
            GOTO process_events_end
        END

        # --- OVERWRITE REACTION ---
        EVENT_TYPE REACT_OVERWRITE == IF
            # Mechanic 1: Delete the target tile.
            EVENT_TARGET delete_tile

            # Mechanic 2: Move the actor tile into the new space.
            0 AS temp_ptr
            tile_info EVENT_ACTOR TILE_OBJ_SIZE * + AS actor_ptr
            actor_ptr TILE_X + AS temp_ptr
            EVENT_POTENTIAL_X AS *temp_ptr
            actor_ptr TILE_Y + AS temp_ptr
            EVENT_POTENTIAL_Y AS *temp_ptr
            actor_ptr TILE_IS_MOVED + AS temp_ptr
            1 AS *temp_ptr

            # Report: An OVERWRITE action occurred.
            GAME_EVENT_OVERWRITE_ACTION EVENT_TARGET
            GOTO process_events_end
        END

        # --- REPLACE REACTION ---
        EVENT_TYPE REACT_REPLACE == IF
            # Mechanic: Replace the target tile.
            EVENT_TARGET replace_tile
            # For now, report a REPLACE action.
            GAME_EVENT_REPLACE_ACTION EVENT_TARGET
            GOTO process_events_end
        END
    END

    # If we get here, no event was processed. Report NONE.
    # Return NONE event and -1 for the tile ID.
    GAME_EVENT_NONE 1 _negate

    :process_events_end
    # The two return values are now on the stack.

    # CRITICAL FIX: Consume the event so it is not processed again.
    GAME_EVENT_NONE AS EVENT_TYPE
}

DEF GAME.refresh {
    IO 2 FLIP
}

# Checks a global timer. Returns 1 (true) when the timer reaches zero,
# and automatically resets it. Returns 0 otherwise.
# Expects on stack: cooldown_duration, timer_variable_pointer
DEF is_timer_ready {
    AS cooldown
    AS timer_ptr

    *timer_ptr 0 > IF
        # Timer is running, count it down.
        *timer_ptr 1 - AS *timer_ptr
        0 # Return 0 (not ready)
    ELSE
        # Timer is zero. It's time to act.
        cooldown AS *timer_ptr # Reset the timer for the next cycle
        1 # Return 1 (ready)
    END
}

# Instantly moves a tile to a new position and marks it for redraw.
# Expects on stack: new_x, new_y, tile_id
DEF tile_move {
    AS tile_id
    AS new_y
    AS new_x

    # Get the base pointer for the specified tile object
    tile_info tile_id TILE_OBJ_SIZE * + AS tile_obj_ptr
    0 AS temp_ptr

    # Update the tile's actual position
    tile_obj_ptr TILE_X + AS temp_ptr
    new_x AS *temp_ptr
    tile_obj_ptr TILE_Y + AS temp_ptr
    new_y AS *temp_ptr

    # Mark it as moved so it gets redrawn in the next frame
    tile_obj_ptr TILE_IS_MOVED + AS temp_ptr
    1 AS *temp_ptr
}

# Initializes a replacement data structure.
# Expects on stack: new_reaction, new_color, new_sprite_data_ptr, replacement_data_ptr
DEF define_replacement {
    AS new_reaction
    AS new_color
    AS new_sprite_data_ptr
    AS replacement_data_ptr

    0 AS temp_ptr

    # Set the new sprite data pointer
    replacement_data_ptr AS temp_ptr
    new_sprite_data_ptr AS *temp_ptr

    # Set the new color
    replacement_data_ptr 1 + AS temp_ptr
    new_color AS *temp_ptr

    # Set the new reaction
    replacement_data_ptr 2 + AS temp_ptr
    new_reaction AS *temp_ptr
}
