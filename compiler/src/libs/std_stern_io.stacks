# this will be the standard IO library for the Stern-XT hardware
# USE std_stern_io activate
# i Need the following methods in this lib
# PRT.char    to print TOS as char
# PRT.string  to print a string, pointer on TOS, \null terminated
# PRT.cls     to clear the console screen
#
# KEY.char      to reads keyboard waiting, input char to TOS
#
# Just PRINT, to print TOS as numer is part of the STACKS runtime libary
#
# expect the SYSCALL are defined
#

# Pointers to kernel variables. These must be initialized by the main program.
VALUE p_syscall_status 0
VALUE p_syscall_value 0

# Initialization function for this library.
# Call this once at startup to link the library to kernel variables.
# Usage: &SYSCALL_RETURN_STATUS &SYSCALL_RETURN_VALUE io_lib_init
DEF io_lib_init {
    AS p_syscall_value      # Pop address for value and set pointer
    AS p_syscall_status     # Pop address for status and set pointer
}

# Are set globaly in the syscall.stacks file here for referance
# Syscall vectors used by this library
#     EQU ~SYS_PRINT_CHAR 21
#     EQU ~SYS_CLEAR_SCREEN 22
#     EQU ~SYS_GET_CHAR 23
#     EQU ~SYS_PRINT_STRING 24
#     EQU ~SYS_PRINT_CURSOR 25
#     EQU ~SYS_DEL_CURSOR 26


# Prints the character on the Top of Stack
DEF PRTchar {
    ASM {
        call @pop_A            ; Pop character from stack into C register for the syscall
        ld C A
        ldi I ~SYS_PRINT_CHAR
        int $INT_VECTORS       ; Interrupt to trigger the syscall
    }
}

# Prints a null-terminated string. Pointer should be on Top of Stack.
DEF PRTstring {
    ASM {
        call @pop_A              ; Pop pointer from stack into A register for the syscall
        ldi I ~SYS_PRINT_STRING
        int $INT_VECTORS         ; Interrupt to trigger the syscall
    }
}

# Clears the console screen
DEF PRTcls {
    ASM {
        ldi I ~SYS_CLEAR_SCREEN
        int $INT_VECTORS
    }
}

# Shows the cursor
DEF CURSORon {
    ASM {
        ldi I ~SYS_PRINT_CURSOR
        int $INT_VECTORS
    }
}

# Hides the cursor
DEF CURSORoff {
    ASM {
        ldi I ~SYS_DEL_CURSOR
        int $INT_VECTORS
    }
}

# Waits for a key to be pressed and pushes it to the Top of Stack.
# This is a blocking call.
DEF KEYchar {
    :key_loop
        ASM {
            ldi I ~SYS_GET_CHAR
            int $INT_VECTORS
        }
        # Check the status by dereferencing our pointer
        *p_syscall_status
        IF
            # Success, push the character value by dereferencing its pointer
            *p_syscall_value
            GOTO key_end_loop
        END
        # Failure (status was 0), loop again.
        GOTO key_loop
    :key_end_loop
}

#### READline method
LIST input_buffer 80
VALUE p_input_buffer 0
VALUE input_buffer_index 0
CONST space 32
CONST backspace 8
CONST return 13
CONST newline 10
CONST null 0


DEF READline {
    :readline_loop
        CURSORon
        KEYchar          ; keyvalue on stack
        CURSORon
        # check for end of line \Return
        DUP return == IF
            CURSORoff
            PRTchar
            GOTO finish_readline
        END
        # ckeck for backspace \Backspace
        DUP backspace == IF
            input_buffer_index 0 != IF
                CURSORoff
                PRTchar
                input_buffer_index 1 - AS input_buffer_index
                GOTO readline_loop
            ELSE
                DROP
                GOTO readline_loop
            END
        END
        # handle regular char
        DUP PRTchar         ; Print the char on screen
        &input_buffer input_buffer_index + AS p_input_buffer
        AS *p_input_buffer  ; store the char in buffer

        input_buffer_index 1 + AS input_buffer_index

    GOTO readline_loop


    :finish_readline
        &input_buffer input_buffer_index + AS p_input_buffer
        null AS *p_input_buffer     ; Terminate the input

        0 AS input_buffer_index     ; Reset the index
        &input_buffer               ; Result (index) to the stack 
}   