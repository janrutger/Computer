USE std_stern_io
USE std_heap
USE std_time
INCLUDE math_lib
INCLUDE fixed_point_lib
INCLUDE turtle_lib
INCLUDE std_struct

# --- Constants ---
VALUE SCREEN_W 640
VALUE SCREEN_H 480
CONST MAX_CAPACITY 200

# Configuration (Scaled by 1000 for Fixed Point)
CONST VEIN_RADIUS 5000      # 5.0
CONST AUXINS_RATE 20
CONST AUXIMITY 30000        # 30.0
CONST KEY_SPACE 32

# Colors
#CONST COLOR_BG 0
CONST COLOR_VEIN  1    # White
CONST COLOR_AUXIN 2    # Red
CONST COLOR_NEW   4   # Purple/Pink

# --- Struct Offsets ---
# Vector2 { x, y }
CONST V2_X 0
CONST V2_Y 1

# Vein { position_ptr, direction_ptr }
CONST VEIN_POS 0
CONST VEIN_DIR 1

# --- Globals ---
VALUE auxins_ptr 0
VALUE auxins_count 0
VALUE veins_ptr 0
VALUE veins_count 0
VALUE to_remove_ptr 0
VALUE to_remove_count 0
VALUE new_veins_ptr 0
VALUE new_veins_count 0

VALUE _v 0
VALUE _i 0
VALUE _nx 0
VALUE _ny 0

VALUE _v1 0
VALUE _v2 0
VALUE _va 0
VALUE _vt 0
VALUE _len 0
VALUE _auxin 0
VALUE _vein 0
VALUE _vpos 0
VALUE _rem_idx 0
VALUE _nearest_vein 0
VALUE _min_dist 0
VALUE _curr_vein 0
VALUE _d 0
VALUE _ndir 0
VALUE _npos 0
VALUE _pos 0
VALUE _dir 0
VALUE _new_pos 0
VALUE _new_vein 0
VALUE _root 0
VALUE _r 0
VALUE _c 0

# VALUE _v1 0
# VALUE _v2 0
# VALUE _va 0
# VALUE _vt 0
# VALUE _len 0
# VALUE _auxin 0
# VALUE _vein 0
# VALUE _vpos 0
# VALUE _rem_idx 0
# VALUE _nearest_vein 0
# VALUE _min_dist 0
# VALUE _curr_vein 0
# VALUE _d 0
# VALUE _ndir 0
# VALUE _npos 0
# VALUE _pos 0
# VALUE _dir 0
# VALUE _new_pos 0
# VALUE _new_vein 0
# VALUE _root 0
# VALUE _r 0
# VALUE _c 0

VALUE type_vector2 0
VALUE type_vein 0

# --- Vector2 Methods ---

# ( -- v_ptr )
DEF Vector2.new { type_vector2 STRUCT.new }

# ( x_fp y_fp -- v_ptr )
DEF Vector2.create {
    Vector2.new AS _v
    V2_Y _v STRUCT.put
    V2_X _v STRUCT.put
    _v
}

# ( v1 v2 -- dist_fp )
DEF Vector2.dist {
    AS _v2 AS _v1
    V2_X _v1 STRUCT.get V2_X _v2 STRUCT.get FP.sub DUP FP.mul
    V2_Y _v1 STRUCT.get V2_Y _v2 STRUCT.get FP.sub DUP FP.mul
    FP.add FP.sqrt
}

# ( v_target v_add -- ) Adds v_add to v_target
DEF Vector2.add_to {
    AS _va AS _vt
    V2_X _vt STRUCT.get V2_X _va STRUCT.get FP.add V2_X _vt STRUCT.put
    V2_Y _vt STRUCT.get V2_Y _va STRUCT.get FP.add V2_Y _vt STRUCT.put
}

# ( v_ptr -- ) Sets x and y to 0
DEF Vector2.zero {
    AS _v
    0 FP.from_int V2_X _v STRUCT.put
    0 FP.from_int V2_Y _v STRUCT.put
}

# ( v_ptr -- ) Normalizes vector in place
DEF Vector2.normalize {
    AS _v
    V2_X _v STRUCT.get DUP FP.mul
    V2_Y _v STRUCT.get DUP FP.mul
    FP.add FP.sqrt AS _len
    _len 0 != IF
        V2_X _v STRUCT.get _len FP.div V2_X _v STRUCT.put
        V2_Y _v STRUCT.get _len FP.div V2_Y _v STRUCT.put
    END
}

# --- Simulation Logic ---

DEF spray_auxins {
    
    0 AS _i
    WHILE _i AUXINS_RATE < DO
        auxins_count MAX_CAPACITY < IF
            # Random X: (RND * W) / 999
            RND SCREEN_W * 999 // FP.from_int
            # Random Y: (RND * H) / 999
            RND SCREEN_H * 999 // FP.from_int
            
            Vector2.create
            auxins_count auxins_ptr LIST.put
            auxins_count 1 + AS auxins_count
        END
        _i 1 + AS _i
    DONE
}

DEF kill_auxins_by_auximity {
    0 AS to_remove_count
    
    # 1. Identify auxins to remove
    VALUE _idx 0
    0 AS _idx
    WHILE _idx auxins_count < DO
        _idx auxins_ptr LIST.get AS _auxin
        
        VALUE _v_idx 0
        0 AS _v_idx
        WHILE _v_idx veins_count < DO
            _v_idx veins_ptr LIST.get AS _vein
            VEIN_POS _vein STRUCT.get AS _vpos
            
            _auxin _vpos Vector2.dist AUXIMITY > 0 == IF
                _idx to_remove_count to_remove_ptr LIST.put
                to_remove_count 1 + AS to_remove_count
                # Break inner loop (set v_idx to count)
                veins_count AS _v_idx
            END
            _v_idx 1 + AS _v_idx
        DONE
        _idx 1 + AS _idx
    DONE
    
    # 2. Remove them (unordered remove)
    WHILE to_remove_count 0 > DO
        to_remove_count 1 - AS to_remove_count
        to_remove_count to_remove_ptr LIST.get AS _rem_idx
        
        # auxins[rem_idx] = auxins[last]
        auxins_count 1 - AS auxins_count
        auxins_count auxins_ptr LIST.get
        _rem_idx auxins_ptr LIST.put
    DONE
}

DEF calculate_growth_directions {
    veins_count 0 > IF
        # Reset directions
        
        0 AS _i
        WHILE _i veins_count < DO
            _i veins_ptr LIST.get VEIN_DIR SWAP STRUCT.get Vector2.zero
            _i 1 + AS _i
        DONE
        
        # Accumulate directions from auxins
        VALUE _a 0
        0 AS _a
        WHILE _a auxins_count < DO
            _a auxins_ptr LIST.get AS _auxin
            
            # Find nearest vein
            0 veins_ptr LIST.get AS _nearest_vein
            _auxin VEIN_POS _nearest_vein STRUCT.get Vector2.dist AS _min_dist
            
            VALUE _vi 1
            1 AS _vi
            WHILE _vi veins_count < DO
                _vi veins_ptr LIST.get AS _curr_vein
                _auxin VEIN_POS _curr_vein STRUCT.get Vector2.dist AS _d
                _d _min_dist < IF
                    _d AS _min_dist
                    _curr_vein AS _nearest_vein
                END
                _vi 1 + AS _vi
            DONE
            
            # vein.dir += (auxin - vein.pos)
            # Note: We don't normalize the diff vector here to save cycles, 
            # just add the raw difference.
            VEIN_DIR _nearest_vein STRUCT.get AS _ndir
            VEIN_POS _nearest_vein STRUCT.get AS _npos
            
            V2_X _auxin STRUCT.get V2_X _npos STRUCT.get FP.sub V2_X _ndir STRUCT.get FP.add V2_X _ndir STRUCT.put
            V2_Y _auxin STRUCT.get V2_Y _npos STRUCT.get FP.sub V2_Y _ndir STRUCT.get FP.add V2_Y _ndir STRUCT.put
            
            _a 1 + AS _a
        DONE
        
        # Normalize all vein directions
        0 AS _i
        WHILE _i veins_count < DO
            _i veins_ptr LIST.get VEIN_DIR SWAP STRUCT.get Vector2.normalize
            _i 1 + AS _i
        DONE
    END
}

DEF grow_new_veins {
    0 AS new_veins_count
    
    #VALUE _i 0
    0 AS _i
    WHILE _i veins_count < DO
        _i veins_ptr LIST.get AS _vein
        VEIN_DIR _vein STRUCT.get AS _dir
        
        # Check if direction is not zero (using raw values for speed)
        V2_X _dir STRUCT.get 0 != V2_Y _dir STRUCT.get 0 != + IF
            # New Pos = Pos + Dir * Radius * 2
            # Radius * 2 = 10.0 (10000)
            VEIN_POS _vein STRUCT.get AS _pos
            
            V2_X _pos STRUCT.get V2_X _dir STRUCT.get 10000 FP.mul FP.add AS _nx
            V2_Y _pos STRUCT.get V2_Y _dir STRUCT.get 10000 FP.mul FP.add AS _ny
            
            # Check boundaries: 0 <= nx <= W AND 0 <= ny <= H
            _nx 0 FP.from_int < 0 ==          # nx >= 0
            _nx SCREEN_W FP.from_int > 0 ==   # nx <= W
            *
            _ny 0 FP.from_int < 0 ==          # ny >= 0
            *
            _ny SCREEN_H FP.from_int > 0 ==   # ny <= H
            *
            0 != IF
                new_veins_count MAX_CAPACITY < IF
                    _nx _ny Vector2.create AS _new_pos
                    _new_pos new_veins_count new_veins_ptr LIST.put
                    new_veins_count 1 + AS new_veins_count
                END
            END
        END
        _i 1 + AS _i
    DONE
    
    # Add new veins to main list
    0 AS _i
    WHILE _i new_veins_count < DO
        veins_count MAX_CAPACITY < IF
            _i new_veins_ptr LIST.get AS _pos
            
            # Create Vein Struct
            type_vein STRUCT.new AS _new_vein
            _pos VEIN_POS _new_vein STRUCT.put
            Vector2.new VEIN_DIR _new_vein STRUCT.put # Empty dir
            
            _new_vein veins_count veins_ptr LIST.put
            veins_count 1 + AS veins_count
        END
        _i 1 + AS _i
    DONE
}

DEF DrawEntity {
    # ( v_ptr color radius_int -- )
    AS _r AS _c AS _v
    _c TURTLE.color
    V2_X _v STRUCT.get FP.to_int
    V2_Y _v STRUCT.get FP.to_int
    _r TURTLE.circle
}

DEF DrawVein {
    # ( vein_ptr -- )
    AS _v
    VEIN_POS _v STRUCT.get AS _pos
    VEIN_DIR _v STRUCT.get AS _dir
    
    # Draw Line (Pos to Pos + Dir * 20)
    COLOR_NEW TURTLE.color
    V2_X _pos STRUCT.get FP.to_int
    V2_Y _pos STRUCT.get FP.to_int
    V2_X _pos STRUCT.get V2_X _dir STRUCT.get 20000 FP.mul FP.add FP.to_int
    V2_Y _pos STRUCT.get V2_Y _dir STRUCT.get 20000 FP.mul FP.add FP.to_int
    TURTLE.line
    
    # Draw Circle
    _pos COLOR_VEIN VEIN_RADIUS FP.to_int DrawEntity
}

# --- Main ---

# Init Heap 
HEAP.free

TURTLE.start
db_pixel TURTLE.mode

# Init Types
V2_X V2_Y 2 STRUCT.new_type AS type_vector2
VEIN_POS VEIN_DIR 2 STRUCT.new_type AS type_vein

# Init Lists
MAX_CAPACITY NEW.list AS auxins_ptr
MAX_CAPACITY NEW.list AS veins_ptr
MAX_CAPACITY NEW.list AS to_remove_ptr
MAX_CAPACITY NEW.list AS new_veins_ptr

# Init Root Vein
type_vein STRUCT.new AS _root
SCREEN_W 2 // FP.from_int SCREEN_H 3 * 4 // FP.from_int Vector2.create VEIN_POS _root STRUCT.put
Vector2.new VEIN_DIR _root STRUCT.put
_root veins_count veins_ptr LIST.put
veins_count 1 + AS veins_count

spray_auxins
kill_auxins_by_auximity

WHILE 1 DO
    KEYpressed DUP 0 != IF
        KEY_SPACE == IF
            calculate_growth_directions
            grow_new_veins
            kill_auxins_by_auximity
            spray_auxins
            kill_auxins_by_auximity
        END
        
    ELSE
        DROP
    END
    
    # Draw Veins
    0 AS _i
    WHILE _i veins_count < DO
        _i veins_ptr LIST.get DrawVein
        _i 1 + AS _i
    DONE
    
    # Draw Auxins
    0 AS _i
    WHILE _i auxins_count < DO
        _i auxins_ptr LIST.get COLOR_AUXIN VEIN_RADIUS FP.to_int DrawEntity
        _i 1 + AS _i
    DONE

    # Draw
    TURTLE.flip
    IO 2 NEW
DONE