# --- RPN  Kernel Command Line ---
#
INCLUDE parser_tools
USE std_stern_io 
USE std_string


# Variable to keep track of the part of the string we are parsing
VALUE rpn_input_ptr 0

DEF start_kernel {
    "New Kernel Command Line: Enter expression or 'q' to quit.\n" PRTstring

    # ASM {
    #     ldi I 6144
    #     callx $_start_memory_
    # }

    :main_loop
        ">> " PRTstring
        READline
        DUP "q" STRcmp IF
            DROP GOTO end_kernel
        END
        DUP AS char_pointer
        *char_pointer 0 == IF
            DROP GOTO main_loop
        END
        

        &bytecode_buffer AS bytecode_ptr
        AS rpn_input_ptr # Store the pointer to the input string

    :parser_loop
        # If the pointer is 0, we are done with this line
        rpn_input_ptr 0 == IF
            OPC_END WRITE_TO_BYTECODE       # write end of program token
            &bytecode_buffer EXECUTE_BYTECODE
            GOTO main_loop
        END

        # Call TOKENIZE to get the next token
        rpn_input_ptr space TOKENIZE

        # Stack now has [&token, &rest]. Update our state for the next loop.
        AS rpn_input_ptr  # Save the &rest pointer
        
        # The &token pointer is now on top of the stack. Decide what to do with it.

        # Check for '+' operator
        DUP "+" STRcmp IF
            "Found ADD operator\n" PRTstring
            DROP OPC_ADD WRITE_TO_BYTECODE  # Drop the original token pointer
            GOTO parser_loop # Finished with this token, continue loop
        END

        # Check for 'PRINT' command
        DUP "PRINT" STRcmp IF
            "Found PRINT command\n" PRTstring
            DROP OPC_PRINT WRITE_TO_BYTECODE # Drop the original token pointer
            GOTO parser_loop # Finished with this token, continue loop
        END

        # Check fot 'USR' command
        DUP "USR" STRcmp IF
            "Found USR command\n" PRTstring
            DROP OPC_USR WRITE_TO_BYTECODE
            GOTO parser_loop
        END


        # If not a known command, try to convert it to a number.
        STRatoi
        
        # ATOI returns [result, flag]. Check the flag.
        IF
            # Success! The result is a number.
            # For now, we'll just print it. Later, we'll push it to the RPN stack.
            "Number: " PRTstring
            DUP PRINT # PRINT consumes the number from the stack
            "\n" PRTstring
            OPC_PUSH WRITE_TO_BYTECODE
        ELSE
            # Failure! It was not a valid number.
            # ATOI returned [&token, 0]. We need to drop the pointer.
             
            "Syntax Error: Invalid token\n" PRTstring
            OPC_UNKOWN WRITE_TO_BYTECODE
        END
        
        GOTO parser_loop

        

    :end_kernel
        "Exiting.\n" PRTstring
}

