# --- RPN  Kernel Command Line ---
#
INCLUDE disk_utils
INCLUDE parser_tools
USE std_stern_io 
USE std_string


# Variable to keep track of the part of the string we are parsing
VALUE rpn_input_ptr 0

DEF start_kernel {
    "WELCOME at Stern-XT!\n" PRTstring
    "\nEnter instructions or 'q' to quit.\n\n" PRTstring

    # ASM {
    #     ldi I 6144
    #     callx $_start_memory_
    # }

    :main_loop
        "[" PRTstring
        TOS.check PRTnum     ; Print the number of items on the stack
        #"]" PRTstring
        "] >> " PRTstring        ; Print the prompt
        READline
        DUP "q" STRcmp IF
            DROP GOTO end_kernel
        END
        DUP AS char_pointer
        *char_pointer 0 == IF
            DROP GOTO main_loop
        END
        

        &bytecode_buffer AS bytecode_ptr
        AS rpn_input_ptr # Store the pointer to the input string

    :parser_loop
        # If the pointer is 0, we are done with this line
        rpn_input_ptr 0 == IF
            OPC_END WRITE_TO_BYTECODE       # write end of program token
            &bytecode_buffer EXECUTE_BYTECODE
            GOTO main_loop
        END

        # Call TOKENIZE to get the next token
        rpn_input_ptr space TOKENIZE

        # Stack now has [&token, &rest]. Update our state for the next loop.
        AS rpn_input_ptr  # Save the &rest pointer
        
        # The &token pointer is now on top of the stack. Decide what to do with it.

        # If the token pointer is null, it means we've parsed an empty part of the
        # string (e.g., multiple spaces). We should ignore it and continue parsing.
        DUP 0 == IF
            DROP
            GOTO parser_loop
        END

        # Check for '+' operator
        DUP "+" STRcmp IF
            "Found ADD operator\n" PRTstring
            DROP OPC_ADD WRITE_TO_BYTECODE  # Drop the original token pointer
            GOTO parser_loop # Finished with this token, continue loop
        END

        # Check for 'PRINT' command
        DUP "PRINT" STRcmp IF
            "Found PRINT command\n" PRTstring
            DROP OPC_PRINT WRITE_TO_BYTECODE # Drop the original token pointer
            GOTO parser_loop # Finished with this token, continue loop
        END

        DUP "INFO" STRcmp IF
            "Found INFO command\n" PRTstring
            DROP OPC_STACKINFO WRITE_TO_BYTECODE
            GOTO parser_loop
        END

        # Check fot 'USR' command
        DUP "USR" STRcmp IF
            "Found USR command\n" PRTstring
            DROP OPC_USR WRITE_TO_BYTECODE
            GOTO parser_loop
        END

        # Check for 'LOAD' command
        DUP "LOAD" STRcmp IF
            "Found LOAD command\n" PRTstring
            DROP OPC_LOAD_FROM_DISK WRITE_TO_BYTECODE
            GOTO parser_loop
        END



        # If not a known command, try to convert it to a number.
        # when it also not a valid number, convert it to a (temp) String
        # since the (tmp)string is reused, a string must be consumed directly
        STRatoi
        
        # ATOI returns [result, flag]. Check the flag.
        IF
            # Success! The result is a number.
            # For now, we'll just print it. Later, we'll push it to the RPN stack.
            "Number: " PRTstring
            DUP PRINT # PRINT consumes the number from the stack
            # "\n" PRTstring
            OPC_PUSH WRITE_TO_BYTECODE
        ELSE    ;ATOI returned [&token, 0] status 0 is already eaten
            # It was not a valid number.
            # create the token_string var
            LIST token_string 17        ; max lenght 16 + terminator 
            # stack: [ &token ]
            &token_string STRcopy      ; Copy input buffer to token_string

            &token_string

            "Found an string token\n" PRTstring
            OPC_STRING WRITE_TO_BYTECODE
        END
        
        GOTO parser_loop

        

    :end_kernel
        "Exiting.\n" PRTstring
}



