# .HEADER
. $_ARR_HEAP_START 1
. $_ARR_HEAP_SIZE 1
. $_ARR_NEXT_FREE 1
. $_ARR_TEMP_PTR 1
. $requested_capacity 1
. $total_size 1
. $new_array_pointer 1
# .FUNCTIONS
@lib_array.init
    ustack A $DATASTACK_PTR
    sto A $_ARR_HEAP_SIZE
    ustack A $DATASTACK_PTR
    sto A $_ARR_HEAP_START
    sto A $_ARR_NEXT_FREE
    ret
@EXIT

        pop A       ; Drop the return adress from the stack
        ret
        ret
@ARRAY.new
    ustack A $DATASTACK_PTR
    sto A $requested_capacity
    stack A $DATASTACK_PTR
    ldi A 2
    ustack B $DATASTACK_PTR
    add B A
    ld A B
    sto A $total_size
    ldm A $_ARR_NEXT_FREE
    stack A $DATASTACK_PTR
    ldm A $total_size
    ustack B $DATASTACK_PTR
    add B A
    stack B $DATASTACK_PTR
    ldm A $_ARR_HEAP_START
    stack A $DATASTACK_PTR
    ldm A $_ARR_HEAP_SIZE
    ustack B $DATASTACK_PTR
    add B A
    stack B $DATASTACK_PTR
    call @rt_gt
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :ARRAY.new_if_end_0
    ldi A 0
    stack A $DATASTACK_PTR
    call @EXIT
:ARRAY.new_if_end_0
    ldm A $_ARR_NEXT_FREE
    sto A $new_array_pointer
    ldm A $_ARR_NEXT_FREE
    stack A $DATASTACK_PTR
    ldm A $total_size
    ustack B $DATASTACK_PTR
    add B A
    ld A B
    sto A $_ARR_NEXT_FREE
    ldm A $new_array_pointer
    sto A $_ARR_TEMP_PTR
    ldm A $requested_capacity
    ld B A
    ldm I $_ARR_TEMP_PTR
    stx B $_start_memory_
    ldm A $new_array_pointer
    stack A $DATASTACK_PTR
    ldi A 1
    ustack B $DATASTACK_PTR
    add B A
    ld A B
    sto A $_ARR_TEMP_PTR
    ldi A 0
    ld B A
    ldm I $_ARR_TEMP_PTR
    stx B $_start_memory_
    ldm A $new_array_pointer
    stack A $DATASTACK_PTR
    ldi A 1
    stack A $DATASTACK_PTR
:end_array_new
    ret

# .DATA
% $_ARR_HEAP_START 0
% $_ARR_HEAP_SIZE 0
% $_ARR_NEXT_FREE 0
% $_ARR_TEMP_PTR 0
% $requested_capacity 0
% $total_size 0
% $new_array_pointer 0
