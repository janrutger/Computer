# .HEADER
. $_temp_ptr 1
. $_temp_idx 1
. $_temp_val 1
. $_scan_ptr 1
. $_vvm_pc_offset 1
. $_opcode 1
. $_is_opcode 1
. $error_no_code 26
. $error_no_opcode 28
. $error_no_syscall 33
. $error_label_unknown 23
. $error_invalid_reg 30
. $error_div_zero 30
. $error_vvm_overflow 23
. $msg_labels_found 15
. $msg_loading 24
. $_run_pc 1
. $_run_opcode 1
. $_run_handler 1
. $_start_argc 1
. $_start_idx 1
. $_syscall_id 1
. $_syscall_handler 1
. $_VVMpointer 1
. $_VVMHOSTpointer 1
. $_VVMsize 1
. $_SIMPLcode 1
. $_vvm_max_size 1
. $_vvm_needed_size 1
. $_vvm_code_start 1
. $_vvm_write_ptr 1
. $_filename 1
. $_code_queue 1
# .FUNCTIONS
@VVM.create
    ustack A $DATASTACK_PTR
    sto A $_VVMpointer
    ustack A $DATASTACK_PTR
    sto A $_VVMHOSTpointer
    ustack A $DATASTACK_PTR
    sto A $_VVMsize
    ustack A $DATASTACK_PTR
    sto A $_SIMPLcode
    ldi A 4
    stack A $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ldm A $_VVMsize
    stack A $DATASTACK_PTR
    ldi A 1
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ldm I $_VVMpointer
    ldx A $_start_memory_
    ld B A
    ldi A 50
    add B A
    stack B $DATASTACK_PTR
    ldi A 2
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ldm I $_VVMpointer
    ldx A $_start_memory_
    ld B A
    ldi A 6
    add B A
    stack B $DATASTACK_PTR
    ldi A 3
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ldm I $_VVMHOSTpointer
    ldx A $_start_memory_
    stack A $DATASTACK_PTR
    ldi A 4
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ldm I $_VVMpointer
    ldx A $_start_memory_
    ld B A
    ldm A $_VVMsize
    add B A
    stack B $DATASTACK_PTR
    ldi A 5
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ldm A $label_addresses
    stack A $DATASTACK_PTR
    call @DICT.clear
    ld A Z
    sto A $_vvm_pc_offset
    ldm I $_SIMPLcode
    ldx A $_start_memory_
    stack A $DATASTACK_PTR
    call @DEQUE.is_empty
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_else_0
    ldi A $error_no_code
    stack A $DATASTACK_PTR

        ustack A $DATASTACK_PTR  ; Pop pointer from stack into A register for the syscall
        ldi I ~SYS_PRINT_STRING
        int $INT_VECTORS         ; Interrupt to trigger the syscall
        call @HALT
    jmp :VVM.create_if_end_0
:VVM.create_if_else_0
    ldm I $_SIMPLcode
    ldx A $_start_memory_
    stack A $DATASTACK_PTR
    call @DEQUE.head
    ustack A $DATASTACK_PTR
    sto A $_scan_ptr
:VVM.create_while_start_0
    ldm A $_scan_ptr
    stack A $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    call @rt_neq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_while_end_0
    ldm A $_scan_ptr
    stack A $DATASTACK_PTR
    call @DEQUE.value
    ustack A $DATASTACK_PTR
    sto A $_temp_val
    stack A $DATASTACK_PTR
    ldm A $opcode_table
    stack A $DATASTACK_PTR
    call @DICT.has_key
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_else_1
    ldm A $_temp_val
    stack A $DATASTACK_PTR
    ldm A $opcode_table
    stack A $DATASTACK_PTR
    call @DICT.get
    ustack A $DATASTACK_PTR
    sto A $_opcode
    stack A $DATASTACK_PTR
    ldi A 60
    stack A $DATASTACK_PTR
    call @rt_eq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_else_2
    ldm A $_scan_ptr
    stack A $DATASTACK_PTR
    call @DEQUE.next
    ustack A $DATASTACK_PTR
    sto A $_scan_ptr
    stack A $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    call @rt_neq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_end_3
    ldm A $_scan_ptr
    stack A $DATASTACK_PTR
    call @DEQUE.value
    ustack A $DATASTACK_PTR
    sto A $_temp_val
    ldm A $_vvm_pc_offset
    stack A $DATASTACK_PTR
    ldm A $_temp_val
    stack A $DATASTACK_PTR
    ldm A $label_addresses
    stack A $DATASTACK_PTR
    call @DICT.put
:VVM.create_if_end_3
    jmp :VVM.create_if_end_2
:VVM.create_if_else_2
    ldm A $_opcode
    stack A $DATASTACK_PTR
    ldi A 50
    stack A $DATASTACK_PTR
    call @rt_lt
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_else_4
    ldm B $_vvm_pc_offset
    ldi A 1
    add A B
    sto A $_vvm_pc_offset
    jmp :VVM.create_if_end_4
:VVM.create_if_else_4
    ldm B $_vvm_pc_offset
    ldi A 2
    add A B
    sto A $_vvm_pc_offset
    ldm A $_scan_ptr
    stack A $DATASTACK_PTR
    call @DEQUE.next
    ustack A $DATASTACK_PTR
    sto A $_scan_ptr
:VVM.create_if_end_4
:VVM.create_if_end_2
    jmp :VVM.create_if_end_1
:VVM.create_if_else_1
    ldi A $error_no_opcode
    stack A $DATASTACK_PTR

        ustack A $DATASTACK_PTR  ; Pop pointer from stack into A register for the syscall
        ldi I ~SYS_PRINT_STRING
        int $INT_VECTORS         ; Interrupt to trigger the syscall
        call @HALT
:VVM.create_if_end_1
    ldm A $_scan_ptr
    stack A $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    call @rt_neq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_end_5
    ldm A $_scan_ptr
    stack A $DATASTACK_PTR
    call @DEQUE.next
    ustack A $DATASTACK_PTR
    sto A $_scan_ptr
:VVM.create_if_end_5
    jmp :VVM.create_while_start_0
:VVM.create_while_end_0
    ldm A $label_addresses
    stack A $DATASTACK_PTR
    call @DICT.count
    call @PRTnum
    ldi A $msg_labels_found
    stack A $DATASTACK_PTR

        ustack A $DATASTACK_PTR  ; Pop pointer from stack into A register for the syscall
        ldi I ~SYS_PRINT_STRING
        int $INT_VECTORS         ; Interrupt to trigger the syscall
    :VVM.create_if_end_0
    ldm A $_VVMsize
    sto A $_vvm_max_size
    ldi A 50
    ld B A
    ldm A $_vvm_pc_offset
    add A B
    sto A $_vvm_needed_size
    stack A $DATASTACK_PTR
    ldm A $_vvm_max_size
    stack A $DATASTACK_PTR
    call @rt_gt
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_end_6
    ldi A $error_vvm_overflow
    stack A $DATASTACK_PTR

        ustack A $DATASTACK_PTR  ; Pop pointer from stack into A register for the syscall
        ldi I ~SYS_PRINT_STRING
        int $INT_VECTORS         ; Interrupt to trigger the syscall
        call @HALT
:VVM.create_if_end_6
    ldm I $_VVMpointer
    ldx A $_start_memory_
    sto A $_temp_ptr
    ld B A
    ldi A 50
    add A B
    sto A $_vvm_code_start
    sto A $_vvm_write_ptr
:VVM.create_while_start_1
    ldm I $_SIMPLcode
    ldx A $_start_memory_
    stack A $DATASTACK_PTR
    call @DEQUE.is_empty
    stack Z $DATASTACK_PTR
    call @rt_eq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_while_end_1
    ldm I $_SIMPLcode
    ldx A $_start_memory_
    stack A $DATASTACK_PTR
    call @DEQUE.pop
    ustack A $DATASTACK_PTR
    sto A $_temp_val
    stack A $DATASTACK_PTR
    ldm A $opcode_table
    stack A $DATASTACK_PTR
    call @DICT.get
    ustack A $DATASTACK_PTR
    sto A $_opcode
    stack A $DATASTACK_PTR
    ldi A 60
    stack A $DATASTACK_PTR
    call @rt_eq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_else_7
    ldm I $_SIMPLcode
    ldx A $_start_memory_
    stack A $DATASTACK_PTR
    call @DEQUE.pop
    call @rt_drop
    jmp :VVM.create_if_end_7
:VVM.create_if_else_7
    ldm A $_opcode
    ld B A
    ldm I $_vvm_write_ptr
    stx B $_start_memory_
    ldm B $_vvm_write_ptr
    ldi A 1
    add A B
    sto A $_vvm_write_ptr
    ldm A $_opcode
    stack A $DATASTACK_PTR
    ldi A 49
    stack A $DATASTACK_PTR
    call @rt_gt
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_end_8
    ldm I $_SIMPLcode
    ldx A $_start_memory_
    stack A $DATASTACK_PTR
    call @DEQUE.pop
    ustack A $DATASTACK_PTR
    sto A $_temp_val
    ldm A $_opcode
    stack A $DATASTACK_PTR
    ldi A 60
    stack A $DATASTACK_PTR
    call @rt_gt
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_else_9
    ldm A $_temp_val
    stack A $DATASTACK_PTR
    ldm A $label_addresses
    stack A $DATASTACK_PTR
    call @DICT.has_key
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.create_if_else_10
    ldm A $_temp_val
    stack A $DATASTACK_PTR
    ldm A $label_addresses
    stack A $DATASTACK_PTR
    call @DICT.get
    ldm A $_vvm_code_start
    ustack B $DATASTACK_PTR
    add A B
    sto A $_temp_val
    jmp :VVM.create_if_end_10
:VVM.create_if_else_10
    ldi A $error_label_unknown
    stack A $DATASTACK_PTR

        ustack A $DATASTACK_PTR  ; Pop pointer from stack into A register for the syscall
        ldi I ~SYS_PRINT_STRING
        int $INT_VECTORS         ; Interrupt to trigger the syscall
        call @HALT
:VVM.create_if_end_10
    jmp :VVM.create_if_end_9
:VVM.create_if_else_9
    ldm A $_opcode
    stack A $DATASTACK_PTR
    ldi A 51
    stack A $DATASTACK_PTR
    call @rt_eq
    ldm A $_opcode
    stack A $DATASTACK_PTR
    ldi A 52
    stack A $DATASTACK_PTR
    call @rt_eq
    ustack A $DATASTACK_PTR
    ustack B $DATASTACK_PTR
    add A B
    tst A 0
    jmpt :VVM.create_if_end_11
    ldm A $_temp_val
    stack A $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    call @rt_lt
    ldm A $_temp_val
    stack A $DATASTACK_PTR
    ldi A 25
    stack A $DATASTACK_PTR
    call @rt_gt
    ustack A $DATASTACK_PTR
    ustack B $DATASTACK_PTR
    add A B
    tst A 0
    jmpt :VVM.create_if_end_12
    ldi A $error_invalid_reg
    stack A $DATASTACK_PTR

        ustack A $DATASTACK_PTR  ; Pop pointer from stack into A register for the syscall
        ldi I ~SYS_PRINT_STRING
        int $INT_VECTORS         ; Interrupt to trigger the syscall
        call @HALT
:VVM.create_if_end_12
:VVM.create_if_end_11
:VVM.create_if_end_9
    ldm A $_temp_val
    ld B A
    ldm I $_vvm_write_ptr
    stx B $_start_memory_
    ldm B $_vvm_write_ptr
    ldi A 1
    add A B
    sto A $_vvm_write_ptr
:VVM.create_if_end_8
:VVM.create_if_end_7
    jmp :VVM.create_while_start_1
:VVM.create_while_end_1
    ret
@VVM.start
    ustack A $DATASTACK_PTR
    sto A $_VVMpointer
    ustack A $DATASTACK_PTR
    sto A $_start_argc
    stack A $DATASTACK_PTR
    ldi A 22
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ldm A $_start_argc
    sto A $_start_idx
:VVM.start_while_start_2
    ldm A $_start_idx
    stack A $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    call @rt_gt
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.start_while_end_2
    ustack A $DATASTACK_PTR
    sto A $_temp_val
    stack A $DATASTACK_PTR
    ldi A 22
    ld B A
    ldm A $_start_idx
    add B A
    stack B $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ldm B $_start_idx
    ldi A 1
    sub B A
    ld A B
    sto A $_start_idx
    jmp :VVM.start_while_start_2
:VVM.start_while_end_2
    ldm I $_VVMpointer
    ldx A $_start_memory_
    ld B A
    ldi A 50
    add B A
    stack B $DATASTACK_PTR
    ldi A 2
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    stack Z $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ret
@VVM.run
    ustack A $DATASTACK_PTR
    sto A $_VVMpointer
    stack Z $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpeek
    ustack A $DATASTACK_PTR
    sto A $_temp_val
    stack A $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    call @rt_eq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.run_if_else_13
    ldi A 2
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpeek
    ustack A $DATASTACK_PTR
    sto A $_run_pc
    ldm I $_run_pc
    ldx A $_start_memory_
    sto A $_run_opcode
    stack A $DATASTACK_PTR
    ldi A 2
    stack A $DATASTACK_PTR
    call @rt_eq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.run_if_else_14
    ldi A 1
    stack A $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    jmp :VVM.run_if_end_14
:VVM.run_if_else_14
    ldm B $_run_pc
    ldi A 1
    add A B
    sto A $_run_pc
    ldm A $_run_opcode
    stack A $DATASTACK_PTR
    ldi A 49
    stack A $DATASTACK_PTR
    call @rt_gt
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.run_if_end_15
    ldm I $_run_pc
    ldx A $_start_memory_
    stack A $DATASTACK_PTR
    ldm B $_run_pc
    ldi A 1
    add A B
    sto A $_run_pc
:VVM.run_if_end_15
    ldm A $_run_pc
    stack A $DATASTACK_PTR
    ldi A 2
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    ldm A $_run_opcode
    stack A $DATASTACK_PTR
    ldm A $opcode_runtimes
    stack A $DATASTACK_PTR
    call @LIST.get
    ustack A $DATASTACK_PTR
    sto A $_run_handler
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    ldm A $_run_handler
    stack A $DATASTACK_PTR
    calls $DATASTACK_PTR
:VVM.run_if_end_14
    jmp :VVM.run_if_end_13
:VVM.run_if_else_13
    ldm A $_temp_val
    stack A $DATASTACK_PTR
    ldi A 2
    stack A $DATASTACK_PTR
    call @rt_eq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.run_if_end_16
    ldi A 2
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpeek
    ldi A 1
    ustack B $DATASTACK_PTR
    add B A
    stack B $DATASTACK_PTR
    ldi A 2
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
    stack Z $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
:VVM.run_if_end_16
:VVM.run_if_end_13
    ret
@VVM.check_syscalls
    ustack A $DATASTACK_PTR
    sto A $_VVMpointer
    stack Z $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpeek
    ldi A 1
    stack A $DATASTACK_PTR
    call @rt_eq
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.check_syscalls_if_end_17
    ldi A 4
    stack A $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpeek
    ustack A $DATASTACK_PTR
    sto A $_temp_val
    stack A $DATASTACK_PTR
    call @DEQUE.pop_tail
    ustack A $DATASTACK_PTR
    sto A $_syscall_id
    stack A $DATASTACK_PTR
    ldm A $syscall_table
    stack A $DATASTACK_PTR
    call @DICT.has_key
    ustack A $DATASTACK_PTR
    tst A 0
    jmpt :VVM.check_syscalls_if_else_18
    ldm A $_syscall_id
    stack A $DATASTACK_PTR
    ldm A $syscall_table
    stack A $DATASTACK_PTR
    call @DICT.get
    ustack A $DATASTACK_PTR
    sto A $_syscall_handler
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    ldm A $_syscall_handler
    stack A $DATASTACK_PTR
    calls $DATASTACK_PTR
    jmp :VVM.check_syscalls_if_end_18
:VVM.check_syscalls_if_else_18
    ldi A $error_no_syscall
    stack A $DATASTACK_PTR

        ustack A $DATASTACK_PTR  ; Pop pointer from stack into A register for the syscall
        ldi I ~SYS_PRINT_STRING
        int $INT_VECTORS         ; Interrupt to trigger the syscall
        call @HALT
:VVM.check_syscalls_if_end_18
    ldi A 2
    stack A $DATASTACK_PTR
    stack Z $DATASTACK_PTR
    ldm A $_VVMpointer
    stack A $DATASTACK_PTR
    call @VVMpoke
:VVM.check_syscalls_if_end_17
    ret
@VVM.loadcode
    ustack A $DATASTACK_PTR
    sto A $_filename
    ustack A $DATASTACK_PTR
    sto A $_code_queue
    ldi A $msg_loading
    stack A $DATASTACK_PTR

        ustack A $DATASTACK_PTR  ; Pop pointer from stack into A register for the syscall
        ldi I ~SYS_PRINT_STRING
        int $INT_VECTORS         ; Interrupt to trigger the syscall
    
        # Open file
        ldm A $_filename
        ldi I ~SYS_F_OPEN_READ
        int $INT_VECTORS
        
        ldm A $SYSCALL_RETURN_STATUS
        tste A Z
        jmpt :vvm_load_end_error

        # Variables
        . $vvm_val 1
        . $vvm_neg 1
        . $vvm_digit_seen 1

        # Read first block
        call @_read_disk_block
        jmpt :vvm_close_and_end

        :vvm_read_loop
            sto Z $vvm_val
            sto Z $vvm_neg
            sto Z $vvm_digit_seen

        :vvm_parse_loop
            inc I $disk_io_buffer_ptr
            ldx C $disk_io_buffer_base
            tst C \null
            jmpf :vvm_process_char
                # End of block, read next
                call @_check_last_block
                jmpt :vvm_close_and_end
                call @_read_disk_block
                jmpt :vvm_close_and_end

                # Reset ptr and reload C
                # The _read_disk_block resets the internal pointer variable to 0.
                # The top of the loop increments before reading, which would skip the
                # first character of the new block.
                # We must manually load the first character here and jump past the loop's load.
                inc I $disk_io_buffer_ptr
                ldx C $disk_io_buffer_base
                jmp :vvm_process_char

            :vvm_process_char
            tst C \Return
            jmpt :vvm_check_push
            tst C \Newline
            jmpt :vvm_check_push
            tst C \space
            jmpt :vvm_check_push
            
            tst C \-
            jmpf :vvm_check_digit
                ldi A 1
                sto A $vvm_neg
                jmp :vvm_parse_loop

            :vvm_check_digit
            ldi A 1
            sto A $vvm_digit_seen
            ldm A $vvm_val
            muli A 10
            subi C 48
            add A C
            sto A $vvm_val
            jmp :vvm_parse_loop

            :vvm_check_push
            ldm A $vvm_digit_seen
            tste A Z
            jmpt :vvm_parse_loop
            
            ldm A $vvm_neg
            tste A Z
            jmpf :vvm_negate
            jmp :vvm_push
            :vvm_negate
            ldm B $vvm_val
            ldi A 0
            sub A B
            sto A $vvm_val
            
            :vvm_push
            ldm A $vvm_val
            stack A $DATASTACK_PTR
            ldm A $_code_queue
            stack A $DATASTACK_PTR
            call @DEQUE.append
            jmp :vvm_read_loop

        :vvm_close_and_end
            ldi I ~SYS_F_CLOSE
            int $INT_VECTORS
            
        :vvm_load_end_error
        ret

# .DATA
% $_temp_ptr 0
% $_temp_idx 0
% $_temp_val 0
% $_scan_ptr 0
% $_vvm_pc_offset 0
% $_opcode 0
% $_is_opcode 0
% $error_no_code \N \o \space \S \I \M \P \L \space \c \o \d \e \space \p \r \o \v \i \d \e \d \. \space \Return \null
% $error_no_opcode \V \V \M \space \i \n \v \a \l \i \d \space \O \P \C \O \D \E \space \f \o \u \n \d \. \space \Return \null
% $error_no_syscall \V \V \M \space \i \n \v \a \l \i \d \space \S \Y \S \C \A \L \L \space \i \s \space \c \a \l \l \e \d \. \space \Return \null
% $error_label_unknown \V \V \M \space \l \a \b \e \l \space \n \o \t \space \f \o \u \n \d \. \space \Return \null
% $error_invalid_reg \V \V \M \space \i \n \v \a \l \i \d \space \r \e \g \i \s \t \e \r \space \i \n \d \e \x \. \space \Return \null
% $error_div_zero \V \V \M \space \d \i \v \i \s \i \o \n \space \b \y \space \z \e \r \o \space \e \r \r \o \r \. \space \Return \null
% $error_vvm_overflow \V \V \M \space \m \e \m \o \r \y \space \o \v \e \r \f \l \o \w \. \space \Return \null
% $msg_labels_found \space \l \a \b \e \l \s \space \f \o \u \n \d \Return \null
% $msg_loading \L \o \a \d \i \n \g \space \V \V \M \space \f \r \o \m \space \d \i \s \k \space \Return \null
% $_run_pc 0
% $_run_opcode 0
% $_run_handler 0
% $_start_argc 0
% $_start_idx 0
% $_syscall_id 0
% $_syscall_handler 0
% $_VVMpointer 0
% $_VVMHOSTpointer 0
% $_VVMsize 0
% $_SIMPLcode 0
% $_vvm_max_size 0
% $_vvm_needed_size 0
% $_vvm_code_start 0
% $_vvm_write_ptr 0
% $_filename 0
% $_code_queue 0
