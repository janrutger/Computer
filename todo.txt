### Start 1 feb 2026
### Next project description and todo list to build this

GEMINI: DO NOT START CODING, JUST ADVISE ON THIS PLAN!!

## ##
In this project i like to develop an Stacks library to run code in Sandboxes or sort of VM
Since the Stern-ATX is already an Virtual machine, those sandboxes also called VVM, (Virtual on Virtual Machine)
The ultimate goal is to end up with an new SIMPL target for my Stacks compilers, so ican use an subset of Stacks language to run on this VVM

An VVM is an memory construction with an 
    VVM-status,             Running, Error, Idle, SYS, Halt
    VVM-size,               default 1024 (or 1024xN)
    VVM-PC,                 program counter, an absolute memory address
    VVM-SP,                 stack pointer, an absolute memory address
    VVM-stack,              (size 16)
    VVM-registers           26 registers [A ..Z], 
    VVM-HOST-pointer,       a deque pointer to communcate with the host computer (the stern-ATX)
    VVM-code                The code section of the VVM (size - HEADER)

The size of the VVM is set at initialisation, the smallest is 1024 word (like an ZX81 on VVM), but can be exteded with blocks of 1024 words as long it fits in memory
The VVM's can live high in program memory, or in an reserved block in extended memory of the Stern-ATX

The VVM are programmed in an language called Stacks Intermediate Machine Programming Language what actually is an Intermediate Language (IL) for the VVM
The SIMPL code is transpiled to byte code, for efficient store in the VVM-code section

The SIMPL instructions can have zero or one operand, like 
    PUSH <value>
    GET <register>
    SET <register>
    ADD
    SUB
    MUL
    BRA <label adres>           Jump always
    BRZ <label adres>           jump when zero
    BRP <label adres>           jump when positive
    BNZ <label adres>           jump when not zero
    BRN <label adres>           jump when negative

    OUT                         saves TOS to VVM-HOST-pointer
    SYS                         calls the syscall system of the host, the arguments are on the VVM-HOST-pointer
                                When SYS is called, and the previous status was running it does not update the PC
                                after returning from the SYSCALL and the status is IDLE, update the PC to the next instruction and set the status to running
    FETCH                       reads the VVM-HOST-pointer and put the value TOS

    LABEL <label>               Label directive

    etc. etc....

where byte code instructions are integers [0..100], registers are integers [0 .. 25] and integer values.
to create an VVM i expect an Stacks instruction like
    &SIMPL-code VVM-size &VVM-HOST-pointer &VVM-pointer VVM.create

    Where 
    &SIMPL-code, is the pointer to an deque holding the raw SIMPL code tokens,
    VVM-size, the size of the VVM, minimal 1024 words, or 1024xN words for larger machines
    &VVM-HOST-pointer, pointer to an already defined deque for VVM -  Host communication
    &VVM-pointer, Named pointer where the VVM lives in memory.

    During creation the Memory structure is setup and the SIMPL code is transpiled to byte code and loaded at VVM-code

to start an VVM i expect an Stacks instruction like
    arg1 ... argn argc &VVM-pointer VVM.start

    where
    &VVM-pointer, named pointer where the VVM lives in memory.
    argc, the number of arguments
    arg1 .. argn, the arguments 

    After creation the VVM status is halt, this method places the argument in registers (A..Z), and set the status to running
    The arguments will be stored in the register table where A holds argc, the arguments in B .. Z





To crank the VVM i expect an Stacks instruction like
    &VVM-pointer VVM.run

    where
    &VVM-pointer, named pointer where the VVM lives in memory.

    it read an instruction and execute/finish them in one tick,
    it calls SYS routines using the VVM-HOST-pointer deque

    The VVM Status is used as follows
    When the status is:
        Running:        The VVM will execute the next instruction 'normally', The status will remain running
        Error:          No execution, the host knows this VVM is in trouble, the status will remain Error
        Idle:           Is set by the host after running an SYSCALL, and return values is set on the deque, 
        SYS:            Is set by the VVM after issueing an SYSCALL, when the VVM sees an SYS status, it return, status remains SYS
        Halt:           No execution, the host knows the VVM is halted normaly, the status will remain Halt

To run Syscalls on the host by VVM-request
    &VVM-pointer VVM.check_syscalls

    where
    &VVM-pointer, named pointer where the VVM lives in memory.

    It checks the status and if required it starts the syscall, by
    reading the syscall-ID from the VVM-HOST-pointer,
    The syscalls knows the number of arguments.
    reading the arguments from the VVM-host-pointer,
    executes the SYSCALL
    puts the optional results to VVM-HOST-pointer,
    update the status to Idle,
     *) its programmers responsibility to get the Results when returning in SIMPL




The Stacks main programming running on the Stern-ATX should, first create the VVM, then run/crank them in a loop.
Where the main can run an other function/program, whille running this crank-loop.

to supports this all we need:
    &SIMPL-code,        type deque, hold the raw tokens of the SIMPL code. Used for both transpiler passes.
    # &SIMPL-code2 is no longer needed. The std_deque library supports non-destructive
    # traversal, allowing two passes (Scout and Baker) over the same deque.

    &VVM-HOST-pointer,  type deque, holds syscall arguments

    opcodes-table,      type dict,  Size 100, To translate the SIMPL instruction to the opcode \"PUSH" -> 0, \"ADD" -> 1
    # Obsolete due to new opcode schema
    # opcodes-length    type list,  size 100, (i expect max 100 SIMPL instructions), where the index is opcode, and the value 0 or 1 the length of the instruction
    opcodes-runtimes    type list,  size 100, where the index is the opcode, and the value an pointer to the opcode handler to run the instruction
    label-addresses     type dict,  size 50,  to store the label addresses (max 50 labels)

    &VVM-pointer        type VAR,   An named pointer to the VVM, where the VVM lives in memory VAR VVM1 <address> (eg 14336), its programmers responsibility to make sure this is an free 1kxN memory block
    
## ##   



Steps todo list:

- [ ] **Main program to test this all**
    - [x] Include the **new** VVM_library
    - [x] Specify memory location of the VVM
    - [x] Declare VVM-HOST-pointer
    - [x] Declare &SIMPL-code, and push a simple test script on it

- [ ] **Develop the VVM_library**
    - [ ] **Optimization Tip:**
        - [ ] Ensure your opcode handlers are written in the fastest native Stacks words available 
        - [ ] Or even ASM blocks if the Stern-ATX supports them.
        - [x] Beaware of the new opcode table, 0 .. 49 no arguments, 50 .. 99 one argument
        - [ ] Implement "Store-and-Load-to-Different-Register" peephole optimization.
                # Found in VVMpeek
                Example:
                sto A $var
                ldm I $var
                ->
                sto A $var
                ld I A
    - [ ] **Setup runtime env**
        - [x] Write runtime handlers (Stubs created)
        - [/] Write Syscall handlers
        - [x] Create/populate opcodes-table
        - [-] Create/populate opcodes-length [Due a new opcode schema, this is not needed]
        - [x] Create/populate opcodes-runtimes
        - [-] Create &SIMPL-code2 [Obsolete due to single-deque transpiler strategy]
        - [x] Define VVM-HEADER (Constants defined in vvm_env_lib)
    - [ ] **VVM.create**
        - [x] Create memory structure
        - [x] Pass 1: Label Scanning (The Scout)
        - [x] Pass 2: Bytecode Baking (The Baker)
        - [x] Transpile code
        - [x] Load code to VM
    - [ ] **VVM.start**
        - [x] Place the arguments in the registers
        - [x] Set the PC to 0
        - [x] Set the status to running
    - [ ] **VVM.run**
        - [x] Check status
        - [x] Fetch instruction
        - [x] Look-up Handler, and execute handler
    - [ ] **VVM.check_syscalls**
        - [x] Check if any action (running a syscall) is expected, and execute


### some developer information

## VVM memory structure
| Offset | Name | Description |
| :--- | :--- | :--- |
| 0 | VVM.STATUS | 0=Idle, 1=Running, 2=Error, 3=SYS, 4=Halt |
| 1 | VVM.SIZE | Size in 1024-word blocks |
| 2 | VVM.PC | Program Counter (Absolute Memory Address) |
| 3 | VVM.SP | Stack Pointer (Absolute Memory Address) |
| 4 | VVM.HOST_PTR | Pointer to the communication Deque |
| 6-21 | VVM.STACK | The 16-word internal data stack |
| 22-47 | VVM.REGS | Registers A-Z (26 words) |
| 50+ | VVM.CODE | The Start of Bytecode |


## OPCODE table
| Range | Group | Example Opcodes | Operand |
| :--- | :--- | :--- | :--- |
| 00 - 09 | System | HALT, NOP, SYS, OUT, FETCH | None |
| 10 - 19 | Stack Logic | DUP, DROP, SWAP, OVER | None |
| 20 - 29 | Math & Logic | ADD, SUB, MUL, DIV, MOD | None |
| 30 - 49 | Reserved | None | |
| 50 - 59 | Data Transfer | PUSH, GET, SET | Yes (Value/Reg) |
| 60 - 69 | Flow Control | LABEL, BRA, BRZ, BNZ, BRP, BRN | Yes (Address) |
| 70 - 99 | reserved | | Yes |

## SYSCALL TABLE
| ID | Group | Name | Description |
| :--- | :--- | :--- | :--- |
| 10 | Console | PRINT_NUM | Print number to console |
| 11 | Console | PRINT_CHAR | Print character to console |
| 20 | Input | READ_CHAR | Read character from keyboard |
| 30 | System | GET_TICKS | Get system time in ticks |
| 50 | Device | UDC_CMD | Send command to UDC device |

## SIMPL example programs

# Example 1
    PUSH 12
    PUSH 30
    ADD 
    OUT
    PUSH 10         ; where 10 is the syscall to print on console
    OUT
    SYS
    HALT


# Example 2
    PUSH 10         # \"PUSH" 10
    SET A           # \"SET" 0

    LABEL loop      # \"LABEL \"loop"
        GET A       # \"GET" 0
        BRZ exit    # \"BRZ" \"exit"

        GET A       # \"GET" 0
        PUSH 1      # \"PUSH" 1
        SUB         # \"SUB"
        SET A       # \"SET" 0

        BRA loop    # \"BRA" \"loop"
    LABEL exit      # \"LABEL \"exit"
        HALT        # \"HALT"

# Example 3
    PUSH 10

    LABEL loop
        DUP 
        BRZ exit

        PUSH 1
        SUB
        BRA loop
    LABEL exit
        DROP
        HALT



### Project Status Summary

## update: 2 feb 2026

Project status is GREEN. Excellent progress has been made on the VVM library.
The foundational 'Setup runtime env' phase is now largely complete.

A key architectural decision was made to split the library into two parts:
1. `vvm_env_lib`: Defines the VVM environment (constants, opcodes, status codes).
2. `vvm_core_lib`: Will contain the core execution logic (`VVM.create`, `VVM.run`).
This separation of concerns is a best practice and sets a solid foundation.

The `VVM.init` function in `vvm_env_lib` is fully implemented and tested.
It successfully populates the `opcode_table` for the transpiler and the
`opcode_runtimes` dispatch table for the executor. The main test program
verifies this functionality with debug prints, confirming the setup is correct.

All runtime instruction handlers (`s_*`) have been created as stubs, and the
VVM memory layout and status codes are now formally defined as constants.

The project is now perfectly positioned to begin the next major phase:
implementing the core logic in `vvm_core_lib.stacks`. The immediate next
steps are to build out the `VVM.create` and `VVM.run` functions.

## update: 3 feb 2026

Project status remains GREEN. Today was a day of significant progress and crucial debugging.

The first major part of `VVM.create` is now complete and verified. The function
successfully allocates and initializes the VVM header structure in memory.
Debugger output confirms that all header fields (Status, Size, absolute PC,
absolute SP, and Host Pointer) are being set correctly.

Several important architectural decisions were solidified: both the Program
Counter (PC) and Stack Pointer (SP) will be stored as absolute memory
addresses, an optimization that will significantly speed up the `VVM.run` loop.

A series of subtle but critical pointer-related issues were identified and
resolved, particularly concerning pointer indirection when passing arguments
to `VVM.create` and when accessing the `SIMPL_code` deque. These fixes have
made the foundation of the library much more robust.

With the VVM header creation now stable, the project is ready to proceed with
the first pass of the transpiler: "Pass 1: Label Scanning (The Scout)".

## update: 4 feb 2026

Project status is GREEN. The `VVM.create` function is now feature-complete and fully verified.

The two-pass transpiler is working flawlessly. 
"Pass 1: The Scout" correctly identifies all labels and calculates their relative offsets. 
"Pass 2: The Baker" then uses this information to generate correct bytecode, successfully resolving label names into absolute jump addresses.

Significant progress was made in the "Baker" phase:
-   A crucial memory overflow check was added to ensure the transpiled code fits within the allocated VVM size.
-   The logic to handle operands for `GET` and `SET` was implemented and debugged, correctly converting register name strings (e.g., `"A"`) into their integer equivalents (e.g., `0`).

Debugger output confirms that the VVM header, code section, and all operand types (literals, addresses, registers) are being written to memory exactly as expected. 
The `VVM.create` function is now considered stable and robust.

The project is now ready to move on to the execution phase, starting with the implementation of `VVM.start` and `VVM.run`.

## append update: 4 feb 2026

Project status is GREEN. The execution engine (`VVM.start` and `VVM.run`) has been successfully implemented but not yet verified.

Key achievements:
-   `VVM.start` is fully functional. It correctly initializes the VVM state, resets the PC, and loads arguments into the registers (A..Z). A critical bug involving global variable collision during the argument loading loop was identified and resolved by isolating the function's state.
-   `VVM.run` now implements a robust Fetch-Decode-Execute cycle. It correctly handles:
    -   Instruction fetching and PC advancement.
    -   Operand fetching for instructions that require them (opcodes > 49).
    -   The complex state machine required for System Calls (`Running` -> `Sys` -> `Idle` -> `Running`), ensuring the VVM pauses execution while the host handles the request.
-   `VVM.check_syscalls` stub is be implemented to handle the host-side logic of the syscall handshake.

## update: 5 feb 2026

Project status is GREEN. The execution engine (`VVM.start` and `VVM.run`) has been successfully verified with a test script.

Key achievements:
-   Implemented and verified runtime handlers for `s_push`, `s_add`, `s_out`, and `s_halt`.
-   `s_push` correctly pushes values to the VVM stack, updating the SP.
-   `s_add` correctly pops two values, adds them, and pushes the result, using isolated temporary variables to avoid state collision.
-   `s_halt` correctly sets the VVM status to `Halted`.
-   Refactored `VVMpeek` and `VVMpoke` into `vvm_env_lib` to be accessible by all handlers.
-   Verified the execution of a simple SIMPL script (`PUSH 12`, `PUSH 30`, `ADD`, `HALT`) using the debugger, confirming correct stack manipulation and program flow.

## append update: 5 feb 2026

Project status is GREEN. Today marked a major milestone with the successful implementation and debugging of the entire VVM syscall mechanism. The VVM is now fully operational and capable of interacting with the host system.

Key achievements:

-   **Syscall Architecture:**
    -   Designed and documented a foundational set of system calls, including Console I/O, User Input, and System/Device control.
    -   Made a key architectural decision to use an "Implicit Contract" for syscalls, where the Syscall ID implies the number of arguments. This improves performance and code clarity.

-   **Syscall Implementation:**
    -   A `syscall_table` dictionary was created and populated in `VVM.init` to map syscall IDs to their handlers.
    -   The `VVM.check_syscalls` function was implemented as a robust dispatcher that executes the correct handler based on the ID.
    -   The first syscall, `s_print_num`, was successfully implemented and tested, allowing the VVM to print a number to the host console.

-   **Critical Debugging & Verification:**
    -   A complex bug in the `VVM.run` state machine was identified and resolved. The issue was a subtle but critical syntax error (`ELSE IF`) common in stack-based languages.
    -   Fixing this bug stabilized the entire `Running -> Sys -> Idle -> Running` lifecycle, making the VVM's interaction with the host reliable and predictable.

-   **Instruction Set Expansion:**
    -   Completed the arithmetic instruction set by implementing the `s_sub`, `s_mul`, `s_div`, and `s_mod` runtime handlers, making the VVM capable of all basic math operations.

With the core execution loop, math operations, and host communication now complete and verified, the VVM is ready for the implementation of more advanced features, such as flow control and register manipulation.

## append update: 5 feb 2026 (Part 2)

Project status is GREEN. A key architectural refinement was made regarding register addressing.

Key Decision:
-   **Integer Register Indices:** To ensure portability and simplify the VVM loader, register operands in the bytecode will now be stored as integer indices (0-25) rather than string pointers or names (e.g., "A").
-   **Compiler Responsibility:** The responsibility for translating register names (like "A", "B") into indices (0, 1) is moved to the compiler/tokenizer layer. The VVM loader (`VVM.create`) now expects raw integers.
-   **Implementation:** The `VVM.create` function was updated to remove the ASCII conversion logic and instead implements a range check (0-25) to ensure valid register access. This makes the bytecode serialization-friendly and the loader more robust.

## update: 6 feb 2026

Project status is GREEN. Significant progress has been made in expanding the VVM's instruction set and refining the runtime environment.

Key achievements:
-   **Math Handlers:** The full suite of arithmetic operations (`s_add`, `s_sub`, `s_mul`, `s_div`, `s_mod`) has been implemented and verified.
    -   A critical safety check for **division by zero** was added to `s_div` and `s_mod`, preventing host system crashes.
    -   The handlers follow a consistent, robust pattern using isolated temporary variables (`_math_a`, `_math_b`).
-   **Stack Logic:** Handlers for `s_dup`, `s_drop`, `s_swap`, and `s_over` have been implemented.
    -   `s_dup` was optimized to avoid redundant memory writes.
    -   `s_swap` correctly swaps values in place without modifying the stack pointer.
-   **Code Review:** A comprehensive review of `vvm_env_lib.stacks` confirmed the library's structural integrity and correctness. A minor bug in `s_sub` (an incorrect zero-check) was identified and slated for removal.
-   **Optimization:** An attempt to use inline assembly (`USTACK`/`STACK`) for math ops was explored but correctly reverted due to the dynamic memory model of the VVM. The Stacks-based implementation remains the correct approach.

The project is now poised to tackle the final major components: flow control (`s_bra`, etc.) and register access (`s_get`, `s_set`).

## append update: 6 feb 2026 (Part 2)

Identified a limitation in the host Stacks compiler/toolchain.

-   **Negative Literals:** The host compiler does not correctly handle negative integer literals (e.g., `-3`) in the source code, leading to crashes.
-   **Workaround:** Use positive integers and subtraction (e.g., `3` then `SUB` or `0 3 -`) or a `NEGATE` operation if available to generate negative values at runtime. The VVM itself handles negative numbers correctly once they are on the stack.

## append update: 6 feb 2026 (Part 3)

Project status is GREEN. The VVM instruction set is nearing completion.

Key achievements:
-   **Flow Control:** Implemented and verified `s_bra`, `s_brz`, `s_bnz`, `s_brp`, and `s_brn`. Loops and conditionals are now functional.
-   **Register Access:** Implemented `s_get` and `s_set` using integer indices (0-25), enabling variable storage in the VVM.
-   **Math Extensions:** Implemented `s_neg` (Negate) to support negative number generation and arithmetic.
-   **Verification:** Successfully ran a test program counting from -3 to 0 using `NEG`, `ADD`, and `BRZ`, confirming the stability of the new instructions and the workaround for host compiler limitations.

Next steps: Implement the remaining system calls (`PRINT_CHAR`, `READ_CHAR`) and the `FETCH` instruction.

## append update: 6 feb 2026 (Part 4)

Project status is GREEN. A major architectural decision has been made to support SIMPL libraries and subroutines.

Key Decision:
-   **Dedicated Return Stack:** To enable efficient `CALL` and `RET` instructions without code bloat (inlining) or data stack corruption, the VVM will implement a dedicated Return Stack.
-   **Memory Layout:** The Return Stack will be located at the top of the VVM's allocated memory and grow downwards. This allows it to dynamically share the free space with the Code section (which grows upwards), maximizing memory efficiency.





### Start 7 feb 2026
### Next project description: Subroutines & Completeness

## ##
Building on the solid foundation of the VVM, this week focuses on enabling modular programming through subroutines and recursion.
The introduction of the Return Stack is the critical enabler for this.
Once `CALL` and `RET` are functional, we can implement the remaining IO instructions and verify the system with complex algorithms.
## ##

Steps todo list:

- [x] **Implement Return Stack Architecture**
    - [x] Define `VVM_RSP` constant (Offset 5).
    - [x] Update `VVM.create` to initialize `VVM_RSP` to the end of the allocated memory block.
    - [x] Implement `CALL` (Opcode ~66): Push `PC` to Return Stack, Jump to Label.
    - [x] Implement `RET` (Opcode ~06): Pop `PC` from Return Stack.
    - [x] Add runtime collision detection: `if PC >= RSP` then `Error`.

- [ ] **Complete Instruction Set**
    - [x] Implement `FETCH` (Opcode 04): Read from `VVM_HOST_PTR` to TOS.
    - [ ] Implement Syscalls: `PRINT_CHAR` (11) and `READ_CHAR` (21).

- [x] **Verification & Stress Testing**
    - [x] Write a test program using `CALL`/`RET` (e.g., a simple function).
    - [x] Write a recursive test program (e.g., Factorial or Fibonacci) to stress the Return Stack.


## update: 7 feb 2026

Project status is GREEN. The VVM now supports subroutines and recursion, marking a major milestone.

Key achievements:
-   **Return Stack Architecture:**
    -   Implemented a dedicated Return Stack growing downwards from the top of VVM memory (`VVM_RSP`).
    -   Updated `VVM.create` to initialize `VVM_RSP` correctly based on the allocated VVM size.
-   **Flow Control Instructions:**
    -   Implemented `s_call` (Opcode 66): Pushes PC to Return Stack and jumps to label.
    -   Implemented `s_ret` (Opcode 06): Pops PC from Return Stack and restores execution flow.
-   **Safety Mechanisms:**
    -   Implemented runtime collision detection (`PC >= RSP`) in `s_call`.
    -   This protects the host system from infinite recursion crashes (Stack Overflow).
-   **Verification:**
    -   Validated the architecture with a recursive Factorial program (`5! = 120`).
    -   Confirmed collision detection using a deliberate infinite recursion test.
    -   The VVM is now a fully functional, Turing-complete execution environment.


### Start 12 feb 2026
### Next project description: The "Scalar Stacks" Compiler Target

## ##
To run Stacks code on the VVM, we need a new target in the compiler.
This target will produce SIMPL bytecode instead of Stern-ATX Assembly.
We accept the "ZX81 Constraints": No arrays, no string literals, max 26 variables.
## ##


### Before coding:
Since this partial project has a mind-blowing impact and touches several existing 'system' files of the tool-chain,
I want to make really sure we are reading the same page from the same book here.

The toolchain files we are going to touch/create are:
compiler/codegen.py         Refactor to extract BaseGenerator.
compiler/simplgen.py        (New) The SIMPL target generator.
compiler/compiler.py        Add target flag logic.
Makefile.mk                 Add build rules for VVM files.

The current build process (Makefile):
1) Compile libraries (src/libs) to .smod.
2) Compile kernel files (src/kernel_files) to .asm includes.
3) Compile boot file (src/boot_files) to .asm.
4) Compile apps to .asm.
5) Assemble microcode.
6) Assemble final binaries.

The NEW build process adds "Step 0":
0) Compile Stacks files from `src/vvm` to Stacks library files (`.stacks`) in `src/generated_libs` using `--target simpl`.
1) Compile libraries: Check `src/libs` AND `src/generated_libs`, compiling them to `.smod`.
2) ... (Rest remains the same).

**Important Note on Makefile:**
The `wildcard` function in Make is evaluated at parse time. If we rely on `wildcard` to find the generated libraries in `src/generated_libs`, it will fail after a `make clean` because the directory will be empty when Make starts.
We must explicitly define the VVM source files and their expected generated library names in the Makefile, rather than relying on `wildcard` for the generated directory.

**Compiler Architecture Refactoring:**
* **Refactoring Strategy:** Instead of `SimplGenerator` inheriting directly from the ASM `CodeGenerator` (which would inherit unwanted ASM logic), we should extract a `BaseGenerator` class.
    * `BaseGenerator` (in `codegen.py`): Handles AST traversal, symbol tables, and scope management.
    * `AsmGenerator` (in `codegen.py`): Inherits `BaseGenerator`, emits Stern-ATX Assembly (Existing logic).
    * `SimplGenerator` (in `simplgen.py`): Inherits `BaseGenerator`, emits SIMPL macros.
* This ensures the new generator starts with a clean slate and doesn't accidentally emit ASM code.
* `SimplGenerator` will throw errors for unsupported features (Arrays, Strings, Structs, ASM blocks).
* All production rules for supported instruction had to be defined in the simplgen.py file
  These overrule the default codegen rules.

**Compiler Interface:**
* Add a new flag: `--target simpl` (default is `asm`).

### Design Spec: Compiler Refactoring

**1. BaseGenerator (Abstract Parent)**
*   **Location:** `compiler/codegen.py`
*   **Responsibilities:**
    *   **State:** Manages `symbols`, `constants`, `functions`, `scopes`, and `label_counter`.
    *   **Helpers:** Provides `declare_variable()`, `lookup_variable()`, `new_label()`, and `error()`.
    *   **Traversal:** Provides the `visit()` dispatcher.
*   **Note:** Does NOT contain any emission logic (`emit()`). It is purely for AST state management.

**2. AsmGenerator (ASM Target)**
*   **Location:** `compiler/codegen.py`
*   **Inherits:** `BaseGenerator`
*   **Responsibilities:**
    *   Implements `visit_*` methods to emit Stern-ATX Assembly.
    *   Manages physical memory concepts (Stack Frames, Heap).

**3. SimplGenerator (SIMPL Target)**
*   **Location:** `compiler/simplgen.py`
*   **Inherits:** `BaseGenerator`
*   **Responsibilities:**
    *   Implements `visit_*` methods to emit SIMPL tokens (via Stacks MACRO syntax).
    *   **Register Allocator:** Maps variables to VVM Registers (0-25).
    *   **Constraints:** Throws errors for unsupported features (Arrays, Strings, ASM).

##

Steps todo list:

- [x] **Phase 1: Compiler Refactoring (The Split)**
    - [x] Extract `BaseGenerator` class in `codegen.py`.
        - [x] Move AST traversal logic (Visitor pattern) to Base.
        - [x] Move Symbol Table and Scope management to Base.
    - [x] Refactor existing `CodeGenerator` to `AsmGenerator` (inheriting from `BaseGenerator`) in `codegen.py`.
        - [x] Keep only ASM-specific emission logic in `AsmGenerator`.
    - [x] Verify that the current build (ASM target) still works correctly.

- [x] **Phase 2: New Target Infrastructure**
    - [x] Create `simplgen.py` containing `SimplGenerator` (inherits `BaseGenerator`).
    - [x] Update `compiler.py` to handle `--target simpl` flag.
    - [x] Implement Output Strategy: Generate a `.stacks` file with a `MACRO` that pushes SIMPL tokens to a deque.

- [ ] **Phase 3: Scalar Stacks Implementation**
    - [x] **Register Allocator:** Map `VALUE` names to VVM Registers (0-25). Error if > 26.
    - [x] **Math & Logic:** Implement visitors for `+ - * / %` -> `ADD SUB MUL DIV MOD`.
    - [x] **Built-ins:** Implement `RND` -> `RND` opcode (requires adding `s_rnd` to `vvm_env_lib`).
        - [x] **PRINT**
        - [x] **ABS**
        - [x] **NEGATE**
        - [x] **CONST**
        - [x] **VAR** is creating an register label without initiazation. where VALUE set an deault value
        - [x] **LIST** Not supported, trow an error, 
                like: LIST, STRING, Stack Stings, USE, INCLUDE
        - [x] **DEF** Should produce code at the end of the code block
        - [x] **MACRO** should inline the code
        - [x] **Comparison** ==, !=, < and > implemented
    - [x] **Flow Control:** Implement visitors for `IF/WHILE` -> `BRZ/BRA/LABEL`.
    - [x] **Safety:** Automatically append `HALT` at the end of the generated program.
    - [x] **Function calls:** Implement `Call` -> `CALL` opcode.
    - [x] **Constraints:** Throw explicit errors for `ASM {}`, Strings, Arrays, and Structs.

- [x] **Phase 4: Build System & Verification**
    - [x] **Makefile Updates:**
        - [x] Explicitly list VVM source files (avoid `wildcard` trap).
        - [x] Add rules to compile `src/vvm/*.stacks` -> `src/simpl_libs/*_lib.stacks`.
    - [x] **Integration Test:**
        - [x] Create `src/vvm/fib.stacks` (used `test_simpl.stacks` for initial verification).
        - [x] Compile it to SIMPL library.
        - [x] Write a host test program to load and run the Fibonacci VVM.


## update: 8 feb 2026

Project status is GREEN. Phase 1 of the compiler refactoring is complete and verified.
The `codegen.py` file has been successfully refactored to support multiple compilation targets.

Key achievements:
-   **BaseGenerator Extraction:** Created a new abstract base class `BaseGenerator` that handles:
    -   AST Traversal (Visitor Pattern).
    -   Symbol Table and Constant management.
    -   Scope context (`current_context`) and label generation counters.
-   **AsmGenerator Specialization:** Renamed the original `CodeGenerator` to `AsmGenerator`.
    -   It now inherits from `BaseGenerator`.
    -   It retains all Stern-ATX Assembly emission logic.
-   **Backward Compatibility:** Added `CodeGenerator = AsmGenerator` alias to ensure existing tools (`compiler.py`) continue to work without modification.
-   **Bug Fix:** Identified and resolved a critical issue in `visit_ProgramNode` where function bodies were being incorrectly filtered out during module compilation.
-   **Verification:** Confirmed that the generated assembly output for existing projects is bit-for-bit identical to the previous version.

This lays the solid foundation required for Phase 2: implementing the `SimplGenerator`.


## update: 8 feb 2026 (Phase 2)

Project status is GREEN. Phase 2 "New Target Infrastructure" is complete.
The compiler now supports a new target architecture: SIMPL (Stacks Intermediate Machine Programming Language).

Key achievements:
-   **SimplGenerator Implementation:** Created `compiler/simplgen.py`.
    -   Inherits from `BaseGenerator` to reuse AST traversal.
    -   Implements a "Meta-Compiler" strategy: instead of binary, it emits Stacks source code (a MACRO).
    -   This MACRO, when executed by the Host, populates a Deque with SIMPL bytecode tokens.
-   **Compiler Interface:** Updated `compiler.py` to accept `--target simpl`.
    -   Defaults to `asm` for backward compatibility.
    -   Automatically handles output paths for generated libraries (`src/simpl_libs`).
-   **Dependency Injection:** The generated macros accept a deque pointer argument (`_sq_`), allowing flexible loading of VVM code into any host deque.
-   **Verification:** Successfully compiled a test script (`test_simpl.stacks`) into a valid Stacks library (`simpl_test_simpl_lib.stacks`).
    -   Verified correct register allocation (mapping variables to indices 0-25).
    -   Verified flow control translation (flattening IF/ELSE to BRZ/BRA/LABEL).

The infrastructure is now ready for Phase 3: implementing the full Scalar Stacks language feature set.


## update: 8 feb 2026 (Phase 4)

Project status is GREEN. Phase 4 "Build System & Verification" is complete.
The full cross-compilation pipeline is now operational.

Key achievements:
-   **Automated Build Pipeline:** Updated `Makefile.mk` to automatically:
    1.  Find `.stacks` files in `src/vvm`.
    2.  Compile them to SIMPL loader libraries in `src/simpl_libs` using `--target simpl`.
    3.  Compile those libraries into `.smod` modules for the OS.
-   **Parser Update:** Updated `parser.py` to search `src/simpl_libs` for macros, enabling seamless `INCLUDE`.
-   **Integration Success:** Verified the pipeline by running two concurrent VVMs:
    -   VVM0 running code compiled from `test_simpl.stacks`.
    -   VVM1 running manually written test code.
    -   Both executed correctly, confirming the stability of the entire toolchain.



## append update: 9 feb 2026 (Part 2)

Project status is GREEN. The VVM instruction set is now complete with the implementation of `FETCH`.

Key achievements:
- **FETCH Instruction:** The `s_fetch` runtime handler was implemented in `vvm_env_lib.stacks`. This instruction allows the VVM to read a single value from the host communication deque and push it onto its data stack.
- **I/O Architecture:** A key architectural decision was solidified regarding I/O operations that return data.
    - The `FETCH` instruction will not be exposed directly to the high-level "Scalar Stacks" programmer.
    - Instead, the `SimplGenerator` compiler is responsible for upholding the "syscall contract".
    - For high-level commands that expect a return value (e.g., a future `READ_CHAR`), the compiler will automatically emit the full `... SYS, FETCH` sequence.
    - This keeps the high-level language simple while correctly using the low-level VVM capabilities.
- **Syscall Contract:** It was decided that any syscall returning data will place exactly one value on the host deque, to be retrieved by a single `FETCH`. This "one-to-one" contract simplifies the VVM core and the compiler logic.

The VVM is now fully equipped to handle bidirectional communication with the host, paving the way for implementing interactive programs.




## update: 9 feb 2026

Project status is GREEN. Today marked the functional completion and philosophical hardening of Phase 3, the "Scalar Stacks" compiler target.

Key achievements:
- **Compiler Correctness:** A major architectural flaw in `simplgen.py` was corrected. Function definitions (`DEF`) are now correctly buffered and emitted at the end of the program block, preceded by an automatic `HALT`. This ensures correct execution flow and prevents fall-through bugs.
- **VVM Instruction Set Expansion:** The VVM's capabilities were significantly enhanced by adding a full suite of comparison operators (`EQ`, `NE`, `LT`, `GT`) and new built-in math functions (`ABS`, `RND`). The `simplgen.py` generator was updated to map the corresponding high-level Stacks words to these new opcodes.
- **Robustness and Debugging:**
    - A critical race condition causing "Invalid Syscall" errors was diagnosed and fixed. The issue stemmed from multiple VVMs sharing a single host communication deque; the fix involved providing dedicated deques for each VVM instance.
    - The `s_abs` handler was made more robust by replacing multiplication by `-1` with subtraction from `0`, working around a known host compiler limitation with negative literals.
    - The GCD test algorithm was corrected, demonstrating the successful use of the new comparison operators.
- **Language Scoping & Hardening:**
    - Key architectural decisions were made to strictly enforce the "Scalar Stacks" constraints.
    - Pointer-like operators (`&`, `*`), dynamic execution (`EXEC`), and host assembly calls (backtick ` `) were explicitly deemed out-of-scope for this target.
    - The `simplgen.py` compiler was updated to throw clear, descriptive errors when these unsupported features are used, guiding the developer and hardening the toolchain.
- **Phase Completion:** A final review confirmed that all requirements for Phase 3 have been met. The `simplgen` target is now capable of compiling a significant subset of the Stacks language into executable VVM bytecode. The project is ready to move into a more intensive testing and verification phase.





##### Some last notes
When the SimplGenerator encounters the word READ_SENSOR, it would be responsible for emitting the entire sequence required to get the data:

OUT (to send the sensor channel ID to the host)
PUSH <syscall_id_for_read_sensor>
OUT (to send the syscall ID)
SYS (to trigger the host and wait)
FETCH (to retrieve the sensor value the host placed on the deque)
From the programmer's perspective, they just write READ_SENSOR, and a value magically appears on the top of the stack. They don't need to know that a FETCH was involved, just as they don't need to know that PRINT involves a SYS call. The compiler handles the implementation details.

In summary: Keep it simple. A syscall that returns data puts one value on the host deque. A FETCH instruction retrieves that one value. This keeps the VVM core clean, the compiler's job easy, and the overall architecture robust and predictable.


## update: 13 feb 2026

Project status is GREEN. The "Scalar Stacks" compiler target and VVM runtime are fully operational and verified.

Key achievements:
- **IO Implementation:**
    - Implemented `visit_IONode` in `simplgen.py` to translate high-level `IO` commands into the VVM syscall protocol (`OUT` args -> `OUT` command -> `SYS` -> `FETCH` result).
    - Implemented `s_UDC_IO` (Syscall 50) in `vvm_env_lib.stacks`. It correctly pops arguments from the host deque, calls the host runtime (`rt_udc_control`), and pushes return values back if required.
- **Verification:**
    - Successfully compiled and ran `fly.stacks` (Plotter demo) and `chaos3.stacks` (Fractal demo) on the VVM.
    - Verified multi-tasking: The host correctly schedules two concurrent VVM instances driving different devices (Plotter and Screen).
- **Performance Analysis:**
    - Confirmed that I/O context switching is the primary bottleneck. Pure math performance is high, but frequent syscalls (like drawing individual pixels) incur a cost due to the VVM -> Host -> Kernel -> Python round-trip.

### Start 13 feb 2026
### Next project description: Custom Syscalls & "Escape the Box"

## ##
To enable high-performance gaming and scripting, we will extend the VVM with a Foreign Function Interface (FFI).
This allows the VVM to call custom host functions for heavy lifting (physics, rendering), effectively turning the VVM into a scripting engine.
## ##

Architectural Decision: "Rich EXEC"
- We will repurpose the `EXEC` instruction in Scalar Stacks to act as a synchronous bridge.
- **Signature:** `Arg1 ... ArgN argc retc Syscall_ID EXEC`
- **Mechanism:** The `s_exec` handler will:
    1. Pop `Syscall_ID`, `retc`, and `argc`.
    2. Pop `argc` items from VVM Stack and push to Host Deque.
    3. Push `Syscall_ID` to Host Deque.
    4. Execute the Host Dispatcher (synchronously).
    5. Pop `retc` items from Host Deque and push to VVM Stack.
- This atomic operation handles the entire call/return cycle, eliminating the need for manual `FETCH` or `RESULT` keywords in high-level code.

Steps todo list:
- [ ] **Host Side (FFI)**
    - [ ] Implement `VVM.register_syscall` in `vvm_env_lib` to allow dynamic registration of handlers.
    - [ ] Implement a Host Dispatcher to route custom syscall IDs to their functions.
- [ ] **VVM Side (Runtime)**
    - [ ] Implement `s_exec` handler with the "Rich EXEC" logic (Stack shuffling).
- [ ] **Compiler Side**
    - [ ] Update `simplgen.py` to support `EXEC` node (currently raises error).
- [ ] **Game Project: "Escape the Box"**
    - [ ] Create `escape.stacks` (Host Engine) and `script.stacks` (VVM Game Logic).
    - [ ] Implement game loop and rendering on Host.
    - [ ] Implement game logic (movement, state) on VVM.






### Future Idea: VVM Disk Loader

## ##
To further decouple applications from the OS kernel and reduce memory usage, we can implement a dynamic loader that reads SIMPL bytecode directly from the Virtual Disk.
This eliminates the need to embed SIMPL code as static data or `DEQUE.append` calls in the host binary.
## ##

Architecture:
- **Compiler Flag:** Add `--target simpl-bin` to `simplgen.py`.
    - Output: A text-based binary file (e.g., `.vm`) containing raw integer bytecode (one instruction per line).
    - Pre-hashing: String tokens (opcodes, labels) are hashed to integers at compile time.
- **Loader Library:** Create `vvm_loader_lib.stacks` (based on `disk_utils.stacks`).
    - Function: `load_simpl_from_disk ( filename_ptr deque_ptr -- )`
    - Logic: Open file, read line-by-line, parse integer, push to deque.

Benefits:
- **Memory Efficiency:** Host program memory is not consumed by the SIMPL bytecode.
- **Flexibility:** Games can be updated or swapped without recompiling the kernel/host.
- **Scalability:** Allows for much larger SIMPL programs limited only by VVM memory size, not Host program memory.


Implementation plan:

The simplgen should has an helper to hash the strings.
    hash_val = 5381
    for val in vals:
        hash_val = ((hash_val * 33) + val)

And keepstrack of the binary output

while code generation, it should generate an libray and a binary output format
the binary output should contain integer, one per line
where \"PUSH" stores the hash of "PUSH" to the binary output stream
a value like 20, is just cast as 20 to the output stream

At the end is should write the stacks library, like it does now.
and the binary file <source>_sbc.bin in the bin/apps directory (the vdisk directory)

the VVM core library shouldbe extended with an VVM.loader method
with reads the binary an put the values on the deque

SIMPL_code "filename_sbc" VVM.load

###

## update: 14 feb 2026

Project status is GREEN. The VVM Disk Loader is fully implemented and verified.

Key achievements:
- **Compiler Support:**
    - Updated `simplgen.py` to support a "Dual Output" strategy. It now generates the standard Stacks library (Macro) AND a raw binary file (`.bin`) in `bin/apps/`.
    - Implemented `djb2_hash` in Python to pre-calculate opcode and label hashes, ensuring the binary file contains a pure stream of integers compatible with the VVM.
    - Enforced the `sbc_<filename>.bin` naming convention for SIMPL Byte Code files.
- **Runtime Loader:**
    - Implemented `VVM.loadcode` in `vvm_core_lib.stacks`.
    - This function reads the integer stream from the disk file and populates the target deque, effectively replicating the behavior of the static macros but at runtime.
    - Reused low-level disk routines from `disk_utils` for efficient block reading.
- **Verification:**
    - Successfully converted the `fly` and `chaos3` demos to binary format.
    - The host test program was refactored to use `VVM.loadcode`, reducing the host binary size to a mere ~750 words while driving two concurrent VVM instances.
    - This confirms the architecture's scalability: the host kernel size is now decoupled from the size and complexity of the user applications.
- **Optimization:**
    - Simplified `VVM.loadcode` by removing negative number parsing. The compiler handles negative literals by emitting `PUSH <abs_val>` and `NEGATE`, so the binary stream is strictly positive integers. This reduces loader complexity and overhead.





########### 
## Update 16 feb 2026

### Let go back in time and work on the Rich EXEC / FFI API
before starting code i like to make sure i realy did understand what i read on this page


To initialize/regsister an host side routine inside the VVM i need an register method
eg:  &pointer_to_function <syscall-id> VVM.bind

where the pointer points to the function and syscall_id must be an free syscall-id
The ID must be in the custom range [100 .. 200] and managed by the programmer

The VVM.register_syscall lives in the VVM_core_lib
And add the syscall_id and function pointers to the syscall_table dictionary

on the side of the compiler.
the simpl target simply emits the EXEC opcode.

`Arg1 ... ArgN argc retc Syscall_ID EXEC`

on the side of the VVM Runtime (s_exec handler):
This handler performs the "Rich" logic synchronously using Direct Stack Marshaling:
(This avoids the overhead of the Host Deque entirely)

1) Pop Syscall_ID, retc, argc from VVM Stack.
2) Transfer argc items from VVM Stack directly to Host Data Stack.
   (Careful with order! VVM Stack Top -> Host Stack Top might reverse args)
3) Look up Syscall_ID in syscall_table.
4) EXEC the handler immediately (Synchronous call).
5) Transfer retc items from Host Data Stack directly to VVM Stack.


Log: 

- Build an VVM.bind in vvm_core_lib to register an function as an VVM custom syscall
- Inluded EXEC in simplgen target and vvm_env_lib

## update: 16 feb 2026 (FFI Completion)

Project status is GREEN. The "Rich EXEC" FFI architecture is fully implemented and verified.

Key achievements:
- **Host-Side Registration:**
    - Implemented `VVM.bind` in `vvm_core_lib`. It allows dynamic binding of host function pointers to custom syscall IDs (>= 100).
    - Enforced safety checks to prevent overwriting system syscalls.
- **Compiler Support:**
    - Enabled the `EXEC` instruction in `simplgen.py`. The compiler now emits the correct opcode, allowing high-level scripts to trigger the FFI.
- **Runtime Bridge (`s_exec`):**
    - Implemented the complex `s_exec` handler in `vvm_env_lib`.
    - **Direct Stack Marshaling:** Successfully implemented the logic to transfer arguments from the VVM stack to the Host stack and return values back, bypassing the overhead of intermediate deques.
    - **Order Preservation:** Crucially, the handler preserves argument order during the transfer (VVM Stack -> Host Stack) and return value order (Host Stack -> VVM Stack).
    - **Synchronous Execution:** The handler executes the host function immediately within the VVM's time slice, enabling atomic operations.
- **Verification:**
    - Validated the entire pipeline with a "42 Circle" test: A VVM script successfully called a host addition function via `EXEC`, passed arguments, and received the correct result.
