### Start 1 feb 2026
### Next project description and todo list to build this

GEMINI: DO NOT START CODING, JUST ADVISE ON THIS PLAN!!

## ##
In this project i like to develop an Stacks library to run code in Sandboxes or sort of VM
Since the Stern-ATX is already an Virtual machine, those sandboxes also called VVM, (Virtual on Virtual Machine)
The ultimate goal is to end up with an new SIMPL target for my Stacks compilers, so ican use an subset of Stacks language to run on this VVM

An VVM is an memory construction with an 
    VVM-status,             Running, Error, Idle, SYS, Halt
    VVM-size,               default 1024 (or 1024xN)
    VVM-PC,                 program counter, an absolute memory address
    VVM-SP,                 stack pointer, an absolute memory address
    VVM-stack,              (size 16)
    VVM-registers           26 registers [A ..Z], 
    VVM-HOST-pointer,       a deque pointer to communcate with the host computer (the stern-ATX)
    VVM-code                The code section of the VVM (size - HEADER)

The size of the VVM is set at initialisation, the smallest is 1024 word (like an ZX81 on VVM), but can be exteded with blocks of 1024 words as long it fits in memory
The VVM's can live high in program memory, or in an reserved block in extended memory of the Stern-ATX

The VVM are programmed in an language called Stacks Intermediate Machine Programming Language what actually is an Intermediate Language (IL) for the VVM
The SIMPL code is transpiled to byte code, for efficient store in the VVM-code section

The SIMPL instructions can have zero or one operand, like 
    PUSH <value>
    GET <register>
    SET <register>
    ADD
    SUB
    MUL
    BRA <label adres>           Jump always
    BRZ <label adres>           jump when zero
    BRP <label adres>           jump when positive
    BNZ <label adres>           jump when not zero
    BRN <label adres>           jump when negative

    OUT                         saves TOS to VVM-HOST-pointer
    SYS                         calls the syscall system of the host, the arguments are on the VVM-HOST-pointer
                                When SYS is called, and the previous status was running it does not update the PC
                                after returning from the SYSCALL and the status is IDLE, update the PC to the next instruction and set the status to running
    FETCH                       reads the VVM-HOST-pointer and put the value TOS

    LABEL <label>               Label directive

    etc. etc....

where byte code instructions are integers [0..100], registers are integers [0 .. 25] and integer values.
to create an VVM i expect an Stacks instruction like
    &SIMPL-code VVM-size &VVM-HOST-pointer &VVM-pointer VVM.create

    Where 
    &SIMPL-code, is the pointer to an deque holding the raw SIMPL code tokens,
    VVM-size, the size of the VVM, minimal 1024 words, or 1024xN words for larger machines
    &VVM-HOST-pointer, pointer to an already defined deque for VVM -  Host communication
    &VVM-pointer, Named pointer where the VVM lives in memory.

    During creation the Memory structure is setup and the SIMPL code is transpiled to byte code and loaded at VVM-code

to start an VVM i expect an Stacks instruction like
    arg1 ... argn argc &VVM-pointer VVM.start

    where
    &VVM-pointer, named pointer where the VVM lives in memory.
    argc, the number of arguments
    arg1 .. argn, the arguments 

    After creation the VVM status is halt, this method places the argument in registers (A..Z), and set the status to running
    The arguments will be stored in the register table where A holds argc, the arguments in B .. Z





To crank the VVM i expect an Stacks instruction like
    &VVM-pointer VVM.run

    where
    &VVM-pointer, named pointer where the VVM lives in memory.

    it read an instruction and execute/finish them in one tick,
    it calls SYS routines using the VVM-HOST-pointer deque

    The VVM Status is used as follows
    When the status is:
        Running:        The VVM will execute the next instruction 'normally', The status will remain running
        Error:          No execution, the host knows this VVM is in trouble, the status will remain Error
        Idle:           Is set by the host after running an SYSCALL, and return values is set on the deque, 
        SYS:            Is set by the VVM after issueing an SYSCALL, when the VVM sees an SYS status, it return, status remains SYS
        Halt:           No execution, the host knows the VVM is halted normaly, the status will remain Halt

To run Syscalls on the host by VVM-request
    &VVM-pointer VVM.check_syscalls

    where
    &VVM-pointer, named pointer where the VVM lives in memory.

    It checks the status and if required it starts the syscall, by
    reading the syscall-ID from the VVM-HOST-pointer,
    The syscalls knows the number of arguments.
    reading the arguments from the VVM-host-pointer,
    executes the SYSCALL
    puts the optional results to VVM-HOST-pointer,
    update the status to Idle,
     *) its programmers responsibility to get the Results when returning in SIMPL




The Stacks main programming running on the Stern-ATX should, first create the VVM, then run/crank them in a loop.
Where the main can run an other function/program, whille running this crank-loop.

to supports this all we need:
    &SIMPL-code,        type deque, hold the raw tokens of the SIMPL code. Used for both transpiler passes.
    # &SIMPL-code2 is no longer needed. The std_deque library supports non-destructive
    # traversal, allowing two passes (Scout and Baker) over the same deque.

    &VVM-HOST-pointer,  type deque, holds syscall arguments

    opcodes-table,      type dict,  Size 100, To translate the SIMPL instruction to the opcode \"PUSH" -> 0, \"ADD" -> 1
    # Obsolete due to new opcode schema
    # opcodes-length    type list,  size 100, (i expect max 100 SIMPL instructions), where the index is opcode, and the value 0 or 1 the length of the instruction
    opcodes-runtimes    type list,  size 100, where the index is the opcode, and the value an pointer to the opcode handler to run the instruction
    label-addresses     type dict,  size 50,  to store the label addresses (max 50 labels)

    &VVM-pointer        type VAR,   An named pointer to the VVM, where the VVM lives in memory VAR VVM1 <address> (eg 14336), its programmers responsibility to make sure this is an free 1kxN memory block
    
## ##   



Steps todo list:

- [ ] **Main program to test this all**
    - [x] Include the **new** VVM_library
    - [x] Specify memory location of the VVM
    - [x] Declare VVM-HOST-pointer
    - [x] Declare &SIMPL-code, and push a simple test script on it

- [ ] **Develop the VVM_library**
    - [ ] **Optimization Tip:**
        - [ ] Ensure your opcode handlers are written in the fastest native Stacks words available 
        - [ ] Or even ASM blocks if the Stern-ATX supports them.
        - [ ] Beaware of the new opcode table, 0 .. 49 no arguments, 50 .. 99 one argument
    - [ ] **Setup runtime env**
        - [/] Write runtime handlers (Stubs created)
        - [ ] Write Syscall handlers
        - [x] Create/populate opcodes-table
        - [-] Create/populate opcodes-length [Due a new opcode schema, this is not needed]
        - [x] Create/populate opcodes-runtimes
        - [-] Create &SIMPL-code2 [Obsolete due to single-deque transpiler strategy]
        - [x] Define VVM-HEADER (Constants defined in vvm_env_lib)
    - [ ] **VVM.create**
        - [x] Create memory structure
        - [x] Pass 1: Label Scanning (The Scout)
        - [x] Pass 2: Bytecode Baking (The Baker)
        - [x] Transpile code
        - [x] Load code to VM
    - [ ] **VVM.start**
        - [x] Place the arguments in the registers
        - [x] Set the PC to 0
        - [x] Set the status to running
    - [ ] **VVM.run**
        - [x] Check status
        - [x] Fetch instruction
        - [x] Look-up Handler, and execute handler
    - [ ] **VVM.check_syscalls**
        - [ ] Check if any action (running a syscall) is expected, and execute


### some developer information

## VVM memory structure
| Offset | Name | Description |
| :--- | :--- | :--- |
| 0 | VVM.STATUS | 0=Idle, 1=Running, 2=Error, 3=SYS, 4=Halt |
| 1 | VVM.SIZE | Size in 1024-word blocks |
| 2 | VVM.PC | Program Counter (Absolute Memory Address) |
| 3 | VVM.SP | Stack Pointer (Absolute Memory Address) |
| 4 | VVM.HOST_PTR | Pointer to the communication Deque |
| 6-21 | VVM.STACK | The 16-word internal data stack |
| 22-47 | VVM.REGS | Registers A-Z (26 words) |
| 50+ | VVM.CODE | The Start of Bytecode |


## OPCODE table
| Range | Group | Example Opcodes | Operand |
| :--- | :--- | :--- | :--- |
| 00 - 09 | System | HALT, NOP, SYS, OUT, FETCH | None |
| 10 - 19 | Stack Logic | DUP, DROP, SWAP, OVER | None |
| 20 - 29 | Math & Logic | ADD, SUB, MUL, DIV, MOD | None |
| 30 - 49 | Reserved | None | |
| 50 - 59 | Data Transfer | PUSH, GET, SET | Yes (Value/Reg) |
| 60 - 69 | Flow Control | LABEL, BRA, BRZ, BNZ, BRP, BRN | Yes (Address) |
| 70 - 99 | reserved | | Yes |


## SIMPL example programs

# Example 1
    PUSH 12
    PUSH 30
    ADD 
    OUT
    PUSH 10         ; where 10 is the syscall to print on console
    OUT
    SYS
    HALT


# Example 2
    PUSH 10         # \"PUSH" 10
    SET A           # \"SET" 0

    LABEL loop      # \"LABEL \"loop"
        GET A       # \"GET" 0
        BRZ exit    # \"BRZ" \"exit"

        GET A       # \"GET" 0
        PUSH 1      # \"PUSH" 1
        SUB         # \"SUB"
        SET A       # \"SET" 0

        BRA loop    # \"BRA" \"loop"
    LABEL exit      # \"LABEL \"exit"
        HALT        # \"HALT"

# Example 3
    PUSH 10

    LABEL loop
        DUP 
        BRZ exit

        PUSH 1
        SUB
        BRA loop
    LABEL exit
        DROP
        HALT



### Project Status Summary

## update: 2 feb 2026

Project status is GREEN. Excellent progress has been made on the VVM library.
The foundational 'Setup runtime env' phase is now largely complete.

A key architectural decision was made to split the library into two parts:
1. `vvm_env_lib`: Defines the VVM environment (constants, opcodes, status codes).
2. `vvm_core_lib`: Will contain the core execution logic (`VVM.create`, `VVM.run`).
This separation of concerns is a best practice and sets a solid foundation.

The `VVM.init` function in `vvm_env_lib` is fully implemented and tested.
It successfully populates the `opcode_table` for the transpiler and the
`opcode_runtimes` dispatch table for the executor. The main test program
verifies this functionality with debug prints, confirming the setup is correct.

All runtime instruction handlers (`s_*`) have been created as stubs, and the
VVM memory layout and status codes are now formally defined as constants.

The project is now perfectly positioned to begin the next major phase:
implementing the core logic in `vvm_core_lib.stacks`. The immediate next
steps are to build out the `VVM.create` and `VVM.run` functions.

## update: 3 feb 2026

Project status remains GREEN. Today was a day of significant progress and crucial debugging.

The first major part of `VVM.create` is now complete and verified. The function
successfully allocates and initializes the VVM header structure in memory.
Debugger output confirms that all header fields (Status, Size, absolute PC,
absolute SP, and Host Pointer) are being set correctly.

Several important architectural decisions were solidified: both the Program
Counter (PC) and Stack Pointer (SP) will be stored as absolute memory
addresses, an optimization that will significantly speed up the `VVM.run` loop.

A series of subtle but critical pointer-related issues were identified and
resolved, particularly concerning pointer indirection when passing arguments
to `VVM.create` and when accessing the `SIMPL_code` deque. These fixes have
made the foundation of the library much more robust.

With the VVM header creation now stable, the project is ready to proceed with
the first pass of the transpiler: "Pass 1: Label Scanning (The Scout)".

## update: 4 feb 2026

Project status is GREEN. The `VVM.create` function is now feature-complete and fully verified.

The two-pass transpiler is working flawlessly. 
"Pass 1: The Scout" correctly identifies all labels and calculates their relative offsets. 
"Pass 2: The Baker" then uses this information to generate correct bytecode, successfully resolving label names into absolute jump addresses.

Significant progress was made in the "Baker" phase:
-   A crucial memory overflow check was added to ensure the transpiled code fits within the allocated VVM size.
-   The logic to handle operands for `GET` and `SET` was implemented and debugged, correctly converting register name strings (e.g., `"A"`) into their integer equivalents (e.g., `0`).

Debugger output confirms that the VVM header, code section, and all operand types (literals, addresses, registers) are being written to memory exactly as expected. 
The `VVM.create` function is now considered stable and robust.

The project is now ready to move on to the execution phase, starting with the implementation of `VVM.start` and `VVM.run`.

## append update: 4 feb 2026

Project status is GREEN. The execution engine (`VVM.start` and `VVM.run`) has been successfully implemented but not yet verified.

Key achievements:
-   `VVM.start` is fully functional. It correctly initializes the VVM state, resets the PC, and loads arguments into the registers (A..Z). A critical bug involving global variable collision during the argument loading loop was identified and resolved by isolating the function's state.
-   `VVM.run` now implements a robust Fetch-Decode-Execute cycle. It correctly handles:
    -   Instruction fetching and PC advancement.
    -   Operand fetching for instructions that require them (opcodes > 49).
    -   The complex state machine required for System Calls (`Running` -> `Sys` -> `Idle` -> `Running`), ensuring the VVM pauses execution while the host handles the request.
-   `VVM.check_syscalls` stub is be implemented to handle the host-side logic of the syscall handshake.

## update: 5 feb 2026

Project status is GREEN. The execution engine (`VVM.start` and `VVM.run`) has been successfully verified with a test script.

Key achievements:
-   Implemented and verified runtime handlers for `s_push`, `s_add`, `s_out`, and `s_halt`.
-   `s_push` correctly pushes values to the VVM stack, updating the SP.
-   `s_add` correctly pops two values, adds them, and pushes the result, using isolated temporary variables to avoid state collision.
-   `s_halt` correctly sets the VVM status to `Halted`.
-   Refactored `VVMpeek` and `VVMpoke` into `vvm_env_lib` to be accessible by all handlers.
-   Verified the execution of a simple SIMPL script (`PUSH 12`, `PUSH 30`, `ADD`, `HALT`) using the debugger, confirming correct stack manipulation and program flow.
