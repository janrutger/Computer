.name "stern_rom"
.registers I A B C K L M X Y Z

# Base ROM definitions for the STERN instruction set

def 10=NOP {
    .format zero
    set_cpu_state(FETCH)
}

def 11=HALT {
    .format zero
    set_cpu_state(HALT)
}

def 20=JMPF {
    .format one_addr
    brs(false)      ; jump when the status bit is set to true
    load_immediate(PC, $1)
:false
    set_cpu_state(FETCH)
}

def 21=JMPT {
    .format one_addr
    brs(true)
    bra(end)
:true
    load_immediate(PC, $1)
:end
    set_cpu_state(FETCH)
}

def 22=JMP {
    .format one_addr
    load_immediate(PC, $1)
    set_cpu_state(FETCH)
}

def 30=LD {
    .format two_reg_reg
    move_reg($1, $2)
    set_cpu_state(FETCH)
}

def 31=LDI {
    .format two_reg_val
    load_immediate($1, $2)
    set_cpu_state(FETCH)
}

def 32=LDM {
    .format two_reg_addr
    read_mem_adres($2, $1)
    set_cpu_state(FETCH)
}

def 40=STO {
    .format two_reg_addr
    store_mem_adres($2, $1)
    set_cpu_state(FETCH)
}

def 50=ADD {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu_add()
    move_reg($1, Ra)
    set_cpu_state(FETCH)
}

def 51=ADDI {
    .format two_reg_val
    move_reg(Ra, $1)
    load_immediate(Rb, $2)
    alu_add()
    move_reg($1, Ra)
    set_cpu_state(FETCH)
}

def 52=SUB {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu_sub()
    move_reg($1, Ra)
    set_cpu_state(FETCH)
}

def 70=TST {
    .format two_reg_val
    move_reg(Ra, $1)
    load_immediate(Rb, $2)
    alu_cmp()
    beq(true)                 ; jump to true
    set_status_bit(FALSE)
    bra(end)                  ; jump to end
:true
    set_status_bit(TRUE)
:end
    set_cpu_state(FETCH)
}

def 71=TSTE {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu_cmp()
    beq(true)                 ; jump to true
    set_status_bit(FALSE)
    bra(end)                  ; jump to end
:true
    set_status_bit(TRUE)
:end
    set_cpu_state(FETCH)
}

def 72=TSTG {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu_sub()
    brz(true)                 ; jump to true
    brn(true)                 ; jump to true
    set_status_bit(TRUE)
    bra(end)                  ; jump to end
:true
    set_status_bit(FALSE)
:end
    set_cpu_state(FETCH)
}

# INC r mem (opcode 80)
# eg: INC R1 100 -> 801100
# op1: register, op2: memory address
def 80=INC {
    .format two_reg_addr
    read_mem_adres($2, Ra)   ; Read value from memory(op2) into internal register Ra
    move_reg($1, Ra)         ; Move the original value from Ra to the destination register op1
    alu_inc()                ; Increment the value in Ra
    store_mem_adres($2, Ra)   ; Store the incremented value back to memory(op2)
    set_cpu_state(FETCH)
}

# DEC r mem (opcode 81)
# eg: DEC R1 100 -> 811100
# op1: register, op2: memory address
def 81=DEC {
    .format two_reg_addr
    read_mem_adres($2, Ra)   ; Read value from memory(op2) into internal register Ra
    alu_dec()                ; Decrement the value in Ra
    move_reg($1, Ra)         ; Move the decremented value back to the destination register op1
    store_mem_adres($2, Ra)  ; Store the decremented value back to memory(op2)
    set_cpu_state(FETCH)
}

def 90=PUSH {
    .format one_reg
    move_reg(Ra, SP)
    store_mem_reg(SP, $1)
    alu_dec()
    move_reg(SP, Ra)
    set_cpu_state(FETCH)
}

def 91=POP {
    .format one_reg
    read_mem_reg(Ra, SP)
    alu_inc()
    move_reg(SP, Ra)
    read_mem_reg(SP, $1)
    set_cpu_state(FETCH)
}