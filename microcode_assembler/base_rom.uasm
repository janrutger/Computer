.name "stern_rom"
.registers I A B C K L M X Y Z

# Base ROM definitions for the STERN instruction set

def 10=NOP {
    .format zero
    set_cpu_state(SLEEP)
    ;  set_cpu_state(FETCH)
}

def 11=HALT {
    .format zero
    set_cpu_state(HALT)
}

def 12=RET {
    .format zero
    move_reg(Ra, SP)        ; Ra = SP
    alu(INC)                ; Ra = Ra + 1 (SP is now effectively incremented in Ra)
    move_reg(SP, Ra)        ; SP = Ra (SP is updated)
    read_mem_reg(SP, PC)    ; PC = memory[SP] (read the saved PC)
    ;  set_cpu_state(FETCH)
}

def 13=EI {
    .format zero
    set_interrupt_flag(TRUE)
    ;  set_cpu_state(FETCH)
}

def 14=DI {
    .format zero
    set_interrupt_flag(FALSE)
    ;  set_cpu_state(FETCH)
}

def 15=RTI {
    .format zero
    shadow(RESTORE)
}

def 20=JMPF {
    .format one_addr
    branch(S, false)      ; jump when the status bit is set to true
    load_immediate(PC, $1)
:false
    ;  set_cpu_state(FETCH)
}

def 21=JMPT {
    .format one_addr
    branch(S, true)
    branch(A, end)
:true
    load_immediate(PC, $1)
:end
    ;  set_cpu_state(FETCH)
}

def 22=JMP {
    .format one_addr
    load_immediate(PC, $1)
    ;  set_cpu_state(FETCH)
}

def 24=CALL {
    .format one_addr
    move_reg(Ra, SP)        ; Ra = SP
    store_mem_reg(SP, PC)   ; Store PC (return address) at SP
    alu(DEC)                ; Decrement SP
    move_reg(SP, Ra)        ; Update SP
    load_immediate(PC, $1)  ; Load target address into PC
    ;  set_cpu_state(FETCH)
}


def 25=CALLX {
    .format one_addr
    move_reg(Ra, SP)        ; Ra = SP
    store_mem_reg(SP, PC)   ; Store PC (return address) at SP
    alu(DEC)                ; Decrement SP
    move_reg(SP, Ra)        ; Update SP

    ; Calculate effective address: arg1 + R0 (index register I)
    read_mem_adres($1, Ra)  ; Ra = value at address arg1
    move_reg(Rb, R0)        ; Rb = R0 (index register I)
    alu(ADD)                ; Ra = Ra + Rb (effective address)
    move_reg(PC, Ra)        ; Load effective address into PC
    ;  set_cpu_state(FETCH)
}

def 26=INT {
    .format one_addr
    shadow(SAVE)                ; Save registers, including PC
    set_interrupt_flag(FALSE)   ; Disable interrupts
    read_mem_adres($1, Ra)      ; Ra = value at address from argument (syscall table base address)
    move_reg(Rb, R0)            ; Rb = syscall ID (from register I/R0)
    alu(ADD)                    ; Ra = Ra + Rb (address of the handler pointer)
    read_mem_reg(Ra, PC)        ; Read the handler pointer from memory (jump to the handler)  
    ;  set_cpu_state(FETCH)
}

def 30=LD {
    .format two_reg_reg
    move_reg($1, $2)
    ;  set_cpu_state(FETCH)
}

def 31=LDI {
    .format two_reg_val
    load_immediate($1, $2)
    ;  set_cpu_state(FETCH)
}

def 32=LDM {
    .format two_reg_addr
    read_mem_adres($2, $1)
    ;  set_cpu_state(FETCH)
}

def 33=LDX {
    .format two_reg_addr
    read_mem_adres($2, Ra)   ; Read value from memory(op2) into Ra
    move_reg(Rb, R0)         ; Rb = R0 (index register)
    alu(ADD)                 ; Ra = Ra + Rb (effective address)
    read_mem_reg(Ra, $1)     ; Read value from effective address (Ra) into $1
    ;  set_cpu_state(FETCH)
}

def 40=STO {
    .format two_reg_addr
    store_mem_adres($2, $1)
    ;  set_cpu_state(FETCH)
}

def 41=STX {
    .format two_reg_addr
    read_mem_adres($2, Ra)   ; Read value from memory(op2)
    move_reg(Rb, R0)         ; Rb = R0 (index register)
    alu(ADD)                 ; Ra = Ra + Rb (effective address)
    store_mem_reg(Ra, $1)    ; Store value of op1 at effective address (Ra)
    ;  set_cpu_state(FETCH)
}

def 50=ADD {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu(ADD)
    move_reg($1, Ra)
    ;  set_cpu_state(FETCH)
}

def 51=ADDI {
    .format two_reg_val
    move_reg(Ra, $1)
    load_immediate(Rb, $2)
    alu(ADD)
    move_reg($1, Ra)
    ;  set_cpu_state(FETCH)
}

def 52=SUB {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu(SUB)
    move_reg($1, Ra)
    ;  set_cpu_state(FETCH)
}

def 53=SUBI {
    .format two_reg_val
    move_reg(Ra, $1)
    load_immediate(Rb, $2)
    alu(SUB)
    move_reg($1, Ra)
    ;  set_cpu_state(FETCH)
}

def 60=MUL {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu(MUL)
    move_reg($1, Ra)
    ;  set_cpu_state(FETCH)
}

def 61=MULI {
    .format two_reg_val
    move_reg(Ra, $1)
    load_immediate(Rb, $2)
    alu(MUL)
    move_reg($1, Ra)
    ;  set_cpu_state(FETCH)
}

def 63=DIVI {
    .format two_reg_val
    move_reg(Ra, $1)
    load_immediate(Rb, $2)
    alu(DIV)
    move_reg($1, Ra)
    ;  set_cpu_state(FETCH)
}

def 65=DMOD {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu(MOD)
    move_reg($1, Ra)
    move_reg($2, Rb)
    ;  set_cpu_state(FETCH)
}


def 70=TST {
    .format two_reg_val
    move_reg(Ra, $1)
    load_immediate(Rb, $2)
    alu(CMP)
    branch(E, true)                 ; jump to true
    set_status_bit(FALSE)
    branch(A, end)                  ; jump to end
:true
    set_status_bit(TRUE)
:end
    ;  set_cpu_state(FETCH)
}

def 71=TSTE {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu(CMP)
    branch(E, true)                 ; jump to true
    set_status_bit(FALSE)
    branch(A, end)                  ; jump to end
:true
    set_status_bit(TRUE)
:end
    ;  set_cpu_state(FETCH)
}

def 72=TSTG {
    .format two_reg_reg
    move_reg(Ra, $1)
    move_reg(Rb, $2)
    alu(SUB)
    branch(Z, true)                 ; jump to true
    branch(N, true)                 ; jump to true
    set_status_bit(TRUE)
    branch(A, end)                  ; jump to end
:true
    set_status_bit(FALSE)
:end
    ;  set_cpu_state(FETCH) 
}
  
# INC r mem (opcode 80)
# eg: INC R1 100 -> 801100
# op1: register, op2: memory address
def 80=INC {
    .format two_reg_addr
    read_mem_adres($2, Ra)   ; Read value from memory(op2) into internal register Ra
    move_reg($1, Ra)         ; Move the original value from Ra to the destination register op1
    alu(INC)
    store_mem_adres($2, Ra)   ; Store the incremented value back to memory(op2)
    ;  set_cpu_state(FETCH)
}

# DEC r mem (opcode 81)
# eg: DEC R1 100 -> 811100
# op1: register, op2: memory address
def 81=DEC {
    .format two_reg_addr
    read_mem_adres($2, Ra)   ; Read value from memory(op2) into internal register Ra
    alu(DEC)
    move_reg($1, Ra)         ; Move the decremented value back to the destination register op1
    store_mem_adres($2, Ra)  ; Store the decremented value back to memory(op2)
    ;  set_cpu_state(FETCH)
}

def 82=ANDI {
    .format two_reg_val
    move_reg(Ra, $1)
    load_immediate(Rb, $2)
    alu(AND)
    move_reg($1, Ra)
    ;  set_cpu_state(FETCH)
}

def 90=PUSH {
    .format one_reg
    move_reg(Ra, SP)
    store_mem_reg(SP, $1)
    alu(DEC)
    move_reg(SP, Ra)
    ;  set_cpu_state(FETCH)
}

def 91=POP {
    .format one_reg
    move_reg(Ra, SP)        ; Ra = SP
    alu(INC)                ; Ra = Ra + 1 (SP is now effectively incremented in Ra)
    move_reg(SP, Ra)        ; SP = Ra (SP is updated)
    read_mem_reg(SP, $1)    ; $1 = memory[SP] (read the value at the new SP)
    ;  set_cpu_state(FETCH)
}


# --- Data Stack Instructions ---
# These instructions operate on a data stack defined by a single-word pointer in memory.
# The instruction's address argument points to this pointer.
# Convention: mem[addr] = absolute_address_of_stack_top

def 92=STACK {
    .format two_reg_addr
    # Pushes register $1 onto a data stack. $2 is the address of the stack pointer.
    # The stack pointer at mem[$2] holds the absolute address of the top of the stack.
    # This is a post-increment push.  (to stack the value)

    # Step 1: Read SP.
    read_mem_adres($2, Ra)      ; Ra = current stack pointer value (SP)

    # Step 2: Store the value from the source register ($1) at the current SP address.
    store_mem_reg(Ra, $1)

    # Step 3: Increment SP and store it back.
    alu(INC)                    ; Ra = new stack pointer value (SP + 1)
    load_immediate(Rb, $2)      ; Rb = address of the stack pointer variable
    store_mem_reg(Rb, Ra)       ; Store the new SP value back.

    ;  set_cpu_state(FETCH)
}

def 93=USTACK {
    .format two_reg_addr
    # Pops a value into register $1 from a data stack. $2 is the address of the stack pointer.
    # The stack pointer at mem[$2] holds the absolute address of the top of the stack.
    # This is a pre-decrement pop.  (to unstack the value)

    # Step 1: Read SP and decrement it.
    read_mem_adres($2, Ra)      ; Ra = current stack pointer value (SP)
    alu(DEC)                    ; Ra = new stack pointer value (SP - 1)

    # Step 2: Store the new SP back.
    load_immediate(Rb, $2)      ; Rb = address of the stack pointer variable
    store_mem_reg(Rb, Ra)       ; Store the new SP value back.

    # Step 3: Read the value from the new top of the stack.
    # Ra still holds the new SP.
    read_mem_reg(Ra, $1)        ; Read the value from the top of the stack into the destination register $1.

    ;  set_cpu_state(FETCH)
}

def 94=GPU {
    .format one_reg
    gpu($1)
    ;  set_cpu_state(FETCH)
}

def 95=CALLS {
    .format one_addr
    # Pops a function address from the data stack and calls it.
    # $1 is the address of the data stack pointer.

    # 1. Push current PC to Hardware Return Stack (Standard CALL logic)
    move_reg(Ra, SP)            ; Ra = Hardware SP
    store_mem_reg(SP, PC)       ; Store Return Address (PC) at Hardware SP
    alu(DEC)                    ; Ra = Ra - 1
    move_reg(SP, Ra)            ; Update Hardware SP

    # 2 & 3. Pop Target Address from Data Stack
    read_mem_adres($1, Ra)      ; Ra = Data Stack Pointer
    alu(DEC)                    ; Ra = Ra - 1
    load_immediate(Rb, $1)      ; Rb = Address of Data Stack Pointer variable
    store_mem_reg(Rb, Ra)       ; Update Data Stack Pointer in memory
    read_mem_reg(Ra, Rb)        ; Rb = Target Address (read from new top of stack)

    # 4. Jump to Target
    move_reg(PC, Rb)            ; PC = Target Address
    ;  set_cpu_state(FETCH)
}
